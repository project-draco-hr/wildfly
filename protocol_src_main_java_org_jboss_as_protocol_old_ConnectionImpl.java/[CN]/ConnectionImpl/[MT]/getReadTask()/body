{
  return new Runnable(){
    @Override public void run(){
      boolean closed=false;
      OutputStream mos=null;
      try {
        Pipe pipe=null;
        final InputStream is=socket.getInputStream();
        final int bufferSize=8192;
        final byte[] buffer=new byte[bufferSize];
        for (; ; ) {
          int cmd=is.read();
switch (cmd) {
case -1:
{
              CONNECTION_LOGGER.trace("Received end of stream");
              safeHandleShutdown();
              boolean done;
              if (mos != null) {
                mos.close();
                pipe.await();
              }
synchronized (lock) {
                readDone=true;
                done=writeDone;
              }
              if (done) {
                StreamUtils.safeClose(socket);
                safeHandleFinished();
              }
              closed=true;
              closed();
              return;
            }
case CHUNK_START:
{
            if (mos == null) {
              pipe=new Pipe(8192);
              final InputStream pis=pipe.getIn();
              mos=pipe.getOut();
              readExecutor.execute(new Runnable(){
                @Override public void run(){
                  safeHandleMessage(new MessageInputStream(pis));
                }
              }
);
            }
            int cnt=StreamUtils.readInt(is);
            CONNECTION_LOGGER.tracef("Received data chunk of size %d",Integer.valueOf(cnt));
            while (cnt > 0) {
              int sc=is.read(buffer,0,Math.min(cnt,bufferSize));
              if (sc == -1) {
                throw MESSAGES.unexpectedEndOfStream();
              }
              mos.write(buffer,0,sc);
              cnt-=sc;
            }
            break;
          }
case CHUNK_END:
{
          CONNECTION_LOGGER.trace("Received end data marker");
          if (mos != null) {
            mos.close();
            pipe.await();
            mos=null;
            pipe=null;
          }
          break;
        }
default :
{
        throw MESSAGES.invalidCommandByte(cmd);
      }
  }
}
}
 catch (IOException e) {
safeHandlerFailure(e);
}
 finally {
StreamUtils.safeClose(mos);
if (!closed) {
  closed();
}
}
}
}
;
}
