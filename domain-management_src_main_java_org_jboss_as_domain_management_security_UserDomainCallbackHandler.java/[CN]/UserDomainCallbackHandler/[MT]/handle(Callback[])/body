{
  final ModelNode userMap=this.userDomain;
  List<Callback> toRespondTo=new LinkedList<Callback>();
  String userName=null;
  ModelNode user=null;
  for (  Callback current : callbacks) {
    if (current instanceof AuthorizeCallback) {
      toRespondTo.add(current);
    }
 else     if (current instanceof NameCallback) {
      NameCallback nameCallback=(NameCallback)current;
      userName=nameCallback.getDefaultName();
      if (userMap.get(USER).hasDefined(userName)) {
        user=userMap.get(USER,userName);
      }
    }
 else     if (current instanceof PasswordCallback) {
      toRespondTo.add(current);
    }
 else     if (current instanceof RealmCallback) {
      String realm=((RealmCallback)current).getDefaultText();
      if (this.realm.equals(realm) == false) {
        throw MESSAGES.invalidRealm(realm,this.realm);
      }
    }
 else {
      throw new UnsupportedCallbackException(current);
    }
  }
  for (  Callback current : toRespondTo) {
    if (current instanceof AuthorizeCallback) {
      AuthorizeCallback acb=(AuthorizeCallback)current;
      boolean authorized=acb.getAuthenticationID().equals(acb.getAuthorizationID());
      if (authorized == false) {
        SECURITY_LOGGER.tracef("Checking 'AuthorizeCallback', authorized=false, authenticationID=%s, authorizationID=%s.",acb.getAuthenticationID(),acb.getAuthorizationID());
      }
      acb.setAuthorized(authorized);
    }
 else     if (current instanceof PasswordCallback) {
      if (user == null) {
        SECURITY_LOGGER.tracef("User '%s' not found.",userName);
        throw new UserNotFoundException(userName);
      }
      String password=user.require(PASSWORD).asString();
      ((PasswordCallback)current).setPassword(password.toCharArray());
    }
  }
}
