{
  final SecurityRolesMetaData mappedRoles=(SecurityRolesMetaData)incommingMappedRoles;
  final SecurityContext securityContext=doPrivileged(securityContext());
  if (securityContext == null) {
    return false;
  }
  RoleGroup roleGroup=null;
  RunAs runAs=securityContext.getIncomingRunAs();
  if (runAs != null && runAs instanceof RunAsIdentity) {
    RunAsIdentity runAsIdentity=(RunAsIdentity)runAs;
    roleGroup=runAsIdentity.getRunAsRolesAsRoleGroup();
  }
 else {
    AuthorizationManager am=securityContext.getAuthorizationManager();
    SecurityContextCallbackHandler scb=new SecurityContextCallbackHandler(securityContext);
    final Subject authenticatedSubject=getSubjectInfo(securityContext).getAuthenticatedSubject();
    roleGroup=getSubjectRoles(am,scb,authenticatedSubject);
  }
  if (roleGroup == null) {
    return false;
  }
  List<Role> roles=roleGroup.getRoles();
  Set<String> requiredRoles=new HashSet<String>();
  for (  String current : roleNames) {
    requiredRoles.add(current);
  }
  Set<String> actualRoles=new HashSet<String>();
  for (  Role current : roles) {
    actualRoles.add(current.getRoleName());
  }
  if (mappedRoles != null) {
    Principal callerPrincipal=getCallerPrincipal();
    Set<String> mapped=mappedRoles.getSecurityRoleNamesByPrincipal(callerPrincipal.getName());
    if (mapped != null) {
      actualRoles.addAll(mapped);
    }
  }
  if (!Collections.disjoint(requiredRoles,actualRoles)) {
    return true;
  }
  if (roleLinks != null) {
    for (    final String actualRole : actualRoles) {
      final Set<String> aliases=this.getRoleAliases(actualRole,roleLinks);
      if (!Collections.disjoint(requiredRoles,aliases)) {
        return true;
      }
    }
  }
  return false;
}
