{
  String realm=challengeParameters.get(REALM);
  String username=challengeParameters.get(USERNAME);
  if (realm == null || realm.length() == 0 || username == null || username.length() == 0) {
    return null;
  }
  RealmCallback rcb=new RealmCallback("Realm",realm);
  NameCallback ncb=new NameCallback("Username",username);
  PasswordCallback pcb=new PasswordCallback("Password",false);
  Callback[] callbacks=new Callback[]{rcb,ncb,pcb};
  try {
    callbackHandler.handle(callbacks);
  }
 catch (  UserNotFoundException e) {
    if (log.isDebugEnabled()) {
      log.debug(e.getMessage());
    }
    return null;
  }
catch (  IOException e) {
    throw new IllegalStateException("CallbackHander not suitable for Digest authentication.");
  }
catch (  UnsupportedCallbackException e) {
    throw new IllegalStateException("CallbackHander not suitable for Digest authentication.");
  }
  try {
    MessageDigest md=MessageDigest.getInstance(MD5);
    md.update(challengeParameters.get(USERNAME).getBytes());
    md.update(COLON);
    md.update(challengeParameters.get(REALM).getBytes());
    md.update(COLON);
    md.update(new String(pcb.getPassword()).getBytes());
    byte[] ha1=HexUtil.convertToHexBytes(md.digest());
    md.update(httpExchange.getRequestMethod().getBytes());
    md.update(COLON);
    md.update(challengeParameters.get(URI).getBytes());
    byte[] ha2=HexUtil.convertToHexBytes(md.digest());
    md.update(ha1);
    md.update(COLON);
    md.update(challengeParameters.get(NONCE).getBytes());
    md.update(COLON);
    md.update(ha2);
    byte[] expectedResponse=HexUtil.convertToHexBytes(md.digest());
    byte[] actualResponse=challengeParameters.get(RESPONSE).getBytes();
    if (MessageDigest.isEqual(expectedResponse,actualResponse)) {
      return new HttpPrincipal(challengeParameters.get(USERNAME),challengeParameters.get(REALM));
    }
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalStateException("Unable to perform digest validation as MD5 is unavailable.",e);
  }
  return null;
}
