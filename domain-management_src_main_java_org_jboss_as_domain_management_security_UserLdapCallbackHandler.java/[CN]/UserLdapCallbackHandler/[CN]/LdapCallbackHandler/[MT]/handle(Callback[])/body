{
  if (callbacks.length == 1 && callbacks[0] instanceof AuthorizeCallback) {
    AuthorizeCallback acb=(AuthorizeCallback)callbacks[0];
    String authenticationId=acb.getAuthenticationID();
    String authorizationId=acb.getAuthorizationID();
    boolean authorized=authenticationId.equals(authorizationId);
    if (authorized == false) {
      SECURITY_LOGGER.tracef("Checking 'AuthorizeCallback', authorized=false, authenticationID=%s, authorizationID=%s.",authenticationId,authorizationId);
    }
    acb.setAuthorized(authorized);
    return;
  }
  VerifyPasswordCallback verifyPasswordCallback=null;
  String username=null;
  for (  Callback current : callbacks) {
    if (current instanceof NameCallback) {
      username=((NameCallback)current).getDefaultName();
    }
 else     if (current instanceof RealmCallback) {
    }
 else     if (current instanceof VerifyPasswordCallback) {
      verifyPasswordCallback=(VerifyPasswordCallback)current;
    }
 else {
      throw new UnsupportedCallbackException(current);
    }
  }
  if (username == null || username.length() == 0) {
    SECURITY_LOGGER.trace("No username or 0 length username supplied.");
    throw MESSAGES.noUsername();
  }
  if (verifyPasswordCallback == null) {
    SECURITY_LOGGER.trace("No password supplied.");
    throw MESSAGES.noPassword();
  }
  String password=verifyPasswordCallback.getPassword();
  if (password == null || (allowEmptyPassword == false && password.length() == 0)) {
    SECURITY_LOGGER.trace("No password or 0 length password supplied.");
    throw MESSAGES.noPassword();
  }
  final VerifyPasswordCallback theVpc=verifyPasswordCallback;
  LdapConnectionHandler lch=createLdapConnectionHandler();
  try {
    SearchResult<LdapEntry> searchResult=userSearcherInjector.getValue().search(lch,username);
    LdapEntry ldapEntry=searchResult.getResult();
    final PasswordCredential cachedCredential=searchResult.getAttachment(PASSWORD_KEY);
    if (cachedCredential != null) {
      if (cachedCredential.verify(password)) {
        SECURITY_LOGGER.tracef("Password verified for user '%s' (using cached password)",username);
        verifyPasswordCallback.setVerified(true);
        sharedState.put(LdapEntry.class.getName(),ldapEntry);
        if (username.equals(ldapEntry.getSimpleName()) == false) {
          sharedState.put(SecurityRealmService.LOADED_USERNAME_KEY,ldapEntry.getSimpleName());
        }
      }
 else {
        SECURITY_LOGGER.tracef("Password verification failed for user (using cached password) '%s'",username);
        verifyPasswordCallback.setVerified(false);
      }
    }
 else {
      try {
        LdapConnectionHandler verificationHandler=lch;
        URI referralUri=ldapEntry.getReferralUri();
        if (referralUri != null) {
          verificationHandler=verificationHandler.findForReferral(referralUri);
        }
        if (verificationHandler != null) {
          verificationHandler.verifyIdentity(ldapEntry.getDistinguishedName(),password);
          SECURITY_LOGGER.tracef("Password verified for user '%s' (using connection attempt)",username);
          verifyPasswordCallback.setVerified(true);
          searchResult.attach(PASSWORD_KEY,new PasswordCredential(password));
          sharedState.put(LdapEntry.class.getName(),ldapEntry);
          if (username.equals(ldapEntry.getSimpleName()) == false) {
            sharedState.put(SecurityRealmService.LOADED_USERNAME_KEY,ldapEntry.getSimpleName());
          }
        }
 else {
          SECURITY_LOGGER.tracef("Password verification failed for user '%s', no connection for referral '%s'",username,referralUri.toString());
          verifyPasswordCallback.setVerified(false);
        }
      }
 catch (      Exception e) {
        SECURITY_LOGGER.tracef("Password verification failed for user (using connection attempt) '%s'",username);
        verifyPasswordCallback.setVerified(false);
      }
    }
  }
 catch (  Exception e) {
    SECURITY_LOGGER.trace("Unable to verify identity.",e);
    throw MESSAGES.cannotPerformVerification(e);
  }
 finally {
    if (shareConnection && lch != null && theVpc != null && theVpc.isVerified()) {
      sharedState.put(LdapConnectionHandler.class.getName(),lch);
    }
 else {
      lch.close();
    }
  }
}
