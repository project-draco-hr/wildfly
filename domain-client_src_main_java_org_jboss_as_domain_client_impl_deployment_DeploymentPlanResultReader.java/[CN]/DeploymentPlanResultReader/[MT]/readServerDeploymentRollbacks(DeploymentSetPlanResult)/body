{
  UUID actionId=unmarshal(unmarshaller,UUID.class);
  DeploymentActionResultImpl actionResult=(DeploymentActionResultImpl)setResult.getDeploymentActionResults().get(actionId);
  ServerIdentity serverId=readServerIdentity();
  expectHeader(DomainClientProtocol.RETURN_SERVER_DEPLOYMENT_RESULT);
  @SuppressWarnings("unchecked") UpdateResultHandlerResponse<Void> urhr=unmarshal(unmarshaller,UpdateResultHandlerResponse.class);
  if (actionResult != null) {
    DeploymentActionImpl action=(DeploymentActionImpl)actionResult.getDeploymentAction();
    for (    DomainUpdateListener<?> listener : action.getListeners()) {
      if (urhr.isCancelled()) {
        listener.handleRollbackCancellation(serverId);
      }
 else       if (urhr.getFailureResult() != null) {
        listener.handleRollbackFailure(urhr.getFailureResult(),serverId);
      }
 else       if (urhr.isRolledBack()) {
        listener.handleRollbackFailure(new RollbackCancelledException("Rollback of deployment action " + actionId + "was itself rolled back"),serverId);
      }
 else       if (urhr.isTimedOut()) {
        listener.handleRollbackTimeout(serverId);
      }
 else {
        listener.handleRollbackSuccess(serverId);
      }
    }
    ServerGroupDeploymentActionResult sgdar=actionResult.getResultsByServerGroup().get(serverId.getServerGroupName());
    ServerUpdateResultImpl<Void> sur=(ServerUpdateResultImpl<Void>)sgdar.getResultByServer().get(serverId.getServerName());
    sur.markRolledBack(urhr);
  }
  return unmarshaller.readByte();
}
