{
  if (acceptable.size() > 1) {
    Map<NetworkInterface,Set<InetAddress>> preferred=new HashMap<NetworkInterface,Set<InetAddress>>();
    for (    NetworkInterface ni : acceptable.keySet()) {
      if (ni.isUp()) {
        preferred.put(ni,acceptable.get(ni));
      }
    }
    if (preferred.size() > 0) {
      acceptable=preferred;
    }
  }
  if (acceptable.size() > 1) {
    Map<NetworkInterface,Set<InetAddress>> preferred=new HashMap<NetworkInterface,Set<InetAddress>>();
    for (    NetworkInterface ni : acceptable.keySet()) {
      if (!ni.isLoopback()) {
        preferred.put(ni,acceptable.get(ni));
      }
    }
    if (preferred.size() > 0) {
      acceptable=preferred;
    }
  }
  if (acceptable.size() > 1) {
    Map<NetworkInterface,Set<InetAddress>> preferred=new HashMap<NetworkInterface,Set<InetAddress>>();
    for (    NetworkInterface ni : acceptable.keySet()) {
      if (!ni.isPointToPoint()) {
        preferred.put(ni,acceptable.get(ni));
      }
    }
    if (preferred.size() > 0) {
      acceptable=preferred;
    }
  }
  if (hasMultipleMatches(acceptable)) {
    Map<NetworkInterface,Set<InetAddress>> preferred=new HashMap<NetworkInterface,Set<InetAddress>>();
    for (    Map.Entry<NetworkInterface,Set<InetAddress>> entry : acceptable.entrySet()) {
      Set<InetAddress> acceptableAddresses=entry.getValue();
      if (acceptableAddresses.size() > 1) {
        Set<InetAddress> preferredAddresses=null;
        for (        InetAddress addr : acceptableAddresses) {
          if (!addr.isLinkLocalAddress()) {
            if (preferredAddresses == null) {
              preferredAddresses=new HashSet<InetAddress>();
              preferred.put(entry.getKey(),preferredAddresses);
            }
            preferredAddresses.add(addr);
          }
        }
      }
 else {
        acceptable.put(entry.getKey(),acceptableAddresses);
      }
    }
    if (preferred.size() > 0) {
      acceptable=preferred;
    }
  }
  Map.Entry<NetworkInterface,Set<InetAddress>> entry=acceptable.entrySet().iterator().next();
  return Collections.singletonMap(entry.getKey(),Collections.singleton(entry.getValue().iterator().next()));
}
