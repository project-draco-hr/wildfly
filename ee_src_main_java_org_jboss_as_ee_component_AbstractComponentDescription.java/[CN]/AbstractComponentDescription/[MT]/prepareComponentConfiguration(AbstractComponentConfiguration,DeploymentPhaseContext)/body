{
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  final Module module=deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);
  final DeploymentReflectionIndex index=deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.REFLECTION_INDEX);
  final Map<MethodIdentifier,Method> componentMethods=new HashMap<MethodIdentifier,Method>();
  final Map<Method,InterceptorFactory> componentToInterceptorFactory=new IdentityHashMap<Method,InterceptorFactory>();
  Class<?> componentClass=configuration.getComponentClass();
  Class<?> currentClass=componentClass;
  do {
    final ClassReflectionIndex<?> classIndex=index.getClassIndex(currentClass);
    for (    Method componentMethod : classIndex.getMethods()) {
      final MethodIdentifier methodIdentifier=MethodIdentifier.getIdentifierForMethod(componentMethod);
      int modifiers=componentMethod.getModifiers();
      if (!Modifier.isStatic(modifiers) && !Modifier.isFinal(modifiers)) {
        componentMethods.put(MethodIdentifier.getIdentifierForMethod(componentMethod),componentMethod);
        final List<InterceptorFactory> theInterceptorFactories=new ArrayList<InterceptorFactory>();
        theInterceptorFactories.addAll(configuration.getComponentInstanceSystemInterceptorFactories());
        if (!methodExcludeClassInterceptors.contains(methodIdentifier)) {
          for (          final InterceptorDescription interceptor : classInterceptors) {
            registerComponentInterceptor(interceptor,configuration,module,index,theInterceptorFactories);
          }
        }
        List<InterceptorDescription> methodLevelInterceptors=methodInterceptors.get(methodIdentifier);
        if (methodLevelInterceptors != null)         for (        final InterceptorDescription interceptor : methodLevelInterceptors) {
          registerComponentInterceptor(interceptor,configuration,module,index,theInterceptorFactories);
        }
        for (        Map.Entry<String,InterceptorMethodDescription> entry : aroundInvokeMethods.entrySet()) {
          try {
            final InterceptorMethodDescription aroundInvoke=entry.getValue();
            final Class<?> methodDeclaringClass=module.getClassLoader().loadClass(entry.getKey());
            final ClassReflectionIndex<?> methodDeclaringClassIndex=index.getClassIndex(methodDeclaringClass);
            final Method aroundInvokeMethod=methodDeclaringClassIndex.getMethod(Object.class,aroundInvoke.getIdentifier().getName(),InvocationContext.class);
            theInterceptorFactories.add(new MethodInterceptorFactory(AbstractComponent.INSTANCE_FACTORY,aroundInvokeMethod));
          }
 catch (          ClassNotFoundException e) {
            throw new DeploymentUnitProcessingException("Failed to load interceptor class " + entry.getKey());
          }
        }
        theInterceptorFactories.addAll(interceptorFactories);
        theInterceptorFactories.add(new MethodInvokingInterceptorFactory(AbstractComponent.INSTANCE_FACTORY,componentMethod));
        componentToInterceptorFactory.put(componentMethod,Interceptors.getChainedInterceptorFactory(theInterceptorFactories));
        processComponentMethod(configuration,componentMethod);
        if (asynchronousMethods.contains(methodIdentifier) || asynchronousViews.contains(currentClass.getName())) {
          if (!Void.TYPE.isAssignableFrom(componentMethod.getReturnType()) && !Future.class.isAssignableFrom(componentMethod.getReturnType())) {
            throw new DeploymentUnitProcessingException("Invalid asynchronous method [" + componentMethod + "].  Asynchronous methods must return either void or Future<V>.");
          }
          configuration.addAsynchronousMethod(componentMethod);
        }
      }
    }
    currentClass=currentClass.getSuperclass();
  }
 while (currentClass != null);
  configuration.addPostConstructComponentLifecycles(getPostConstructComponentLifecycles());
  configuration.addPostConstructComponentLifecycles(createLifecycless(getPostConstructs(),module,index));
  configuration.addPreDestroyComponentLifecycles(createLifecycless(getPreDestroys(),module,index));
  configuration.addPostConstructLifecycles(createLifecycleInterceptors(getPostConstructs(),module,index));
  configuration.addPreDestroyLifecycles(createLifecycleInterceptors(getPreDestroys(),module,index));
  configuration.addPreDestroyComponentLifecycles(getPreDestroyComponentLifecycles());
  final Map<Class<?>,List<LifecycleInterceptorFactory>> interceptorPreDestroys=configuration.getInterceptorPreDestroys();
  for (  InterceptorDescription interceptorDescription : getClassInterceptors()) {
    final Class<?> interceptorClass;
    try {
      interceptorClass=Class.forName(interceptorDescription.getInterceptorClassName(),false,componentClass.getClassLoader());
    }
 catch (    ClassNotFoundException e) {
      throw new DeploymentUnitProcessingException("Failed to load interceptor class " + interceptorDescription.getInterceptorClassName(),e);
    }
    interceptorPreDestroys.put(interceptorClass,createLifecycleInterceptors(interceptorDescription.getPreDestroys(),module,index));
  }
  final Map<Class<?>,ProxyFactory<?>> proxyFactories=configuration.getProxyFactories();
  final Map<Method,InterceptorFactory> viewToInterceptorFactory=configuration.getInterceptorFactoryMap();
  for (  String viewClassName : viewClassNames) {
    final Class<?> viewClass;
    try {
      viewClass=Class.forName(viewClassName,false,componentClass.getClassLoader());
    }
 catch (    ClassNotFoundException e) {
      throw new DeploymentUnitProcessingException("Failed to load view class " + viewClassName,e);
    }
    final ProxyFactory<?> factory=getProxyFactory(viewClass);
    proxyFactories.put(viewClass,factory);
    final List<Method> methods=new ArrayList<Method>();
    for (    Method viewMethod : factory.getCachedMethods()) {
      methods.add(viewMethod);
      Method componentMethod=componentMethods.get(MethodIdentifier.getIdentifierForMethod(viewMethod));
      if (componentMethod != null) {
        viewToInterceptorFactory.put(viewMethod,componentToInterceptorFactory.get(componentMethod));
      }
      processViewMethod(configuration,viewClass,viewMethod,componentMethod);
    }
  }
  final Map<ServiceName,InjectedValue<Object>> dependencyInjections=configuration.getDependencyInjections();
  for (  Map.Entry<ServiceName,ServiceBuilder.DependencyType> entry : dependencies.entrySet()) {
    InjectedValue<Object> value=new InjectedValue<Object>();
    dependencyInjections.put(entry.getKey(),value);
  }
}
