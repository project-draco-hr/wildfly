{
  Set<String> allEntries=null;
synchronized (pathEntries) {
    if (event == Event.UPDATED) {
      allEntries=new LinkedHashSet<String>();
      allEntries.add(name);
      getAllDependentsForRestartCheck(allEntries,name);
    }
 else {
      allEntries=Collections.singleton(name);
    }
  }
  Map<String,Set<Callback>> triggerCallbacks=new LinkedHashMap<String,Set<Callback>>();
synchronized (callbacks) {
    for (    String pathName : allEntries) {
      Map<Event,Set<Callback>> callbacksByEvent=callbacks.get(pathName);
      if (callbacksByEvent != null) {
        Set<Callback> callbacksForEntry=callbacksByEvent.get(event);
        if (callbacksForEntry != null) {
          triggerCallbacks.put(pathName,new LinkedHashSet<Callback>(callbacksForEntry));
        }
      }
    }
  }
  PathEventContextImpl pathEventContext=new PathEventContextImpl(operationContext,event);
  for (  Map.Entry<String,Set<Callback>> entry : triggerCallbacks.entrySet()) {
    for (    Callback cb : entry.getValue()) {
      cb.pathModelEvent(pathEventContext,entry.getKey());
      if (pathEventContext.restart) {
        return pathEventContext;
      }
    }
  }
  return pathEventContext;
}
