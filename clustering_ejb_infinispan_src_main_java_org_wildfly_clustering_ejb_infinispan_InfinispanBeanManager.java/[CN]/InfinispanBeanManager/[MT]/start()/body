{
  this.executor=new StampedLockServiceExecutor();
  for (  KeyAffinityService<?> service : this.affinityServices) {
    service.start();
  }
  final List<Scheduler<I>> schedulers=new ArrayList<>(2);
  Time timeout=this.expiration.getTimeout();
  if ((timeout != null) && (timeout.getValue() >= 0)) {
    schedulers.add(new BeanExpirationScheduler<>(this.batcher,new ExpiredBeanRemover<>(this.beanFactory),this.expiration));
  }
  if (this.passivation.isEvictionAllowed()) {
    schedulers.add(new BeanEvictionScheduler<>(this.beanName + ".eviction",this.batcher,this.beanFactory,this.dispatcherFactory,this.passivation));
  }
  this.scheduler=new Scheduler<I>(){
    @Override public void schedule(    I id){
      for (      Scheduler<I> scheduler : schedulers) {
        scheduler.schedule(id);
      }
    }
    @Override public void cancel(    I id){
      for (      Scheduler<I> scheduler : schedulers) {
        scheduler.cancel(id);
      }
    }
    @Override public void cancel(    Locality locality){
      for (      Scheduler<I> scheduler : schedulers) {
        scheduler.cancel(locality);
      }
    }
    @Override public void close(){
      for (      Scheduler<I> scheduler : schedulers) {
        scheduler.close();
      }
    }
  }
;
  this.dispatcher=this.dispatcherFactory.createCommandDispatcher(this.beanName + ".schedulers",this.scheduler);
  this.beanCache.addListener(this,this.filter);
  this.schedule(this.beanCache,new SimpleLocality(false),new ConsistentHashLocality(this.beanCache));
}
