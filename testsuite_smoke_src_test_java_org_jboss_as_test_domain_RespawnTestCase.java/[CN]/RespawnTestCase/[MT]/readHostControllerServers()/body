{
  final ModelNode operation=new ModelNode();
  operation.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.READ_RESOURCE_OPERATION);
  operation.get(ModelDescriptionConstants.OP_ADDR).set(PathAddress.pathAddress(PathElement.pathElement("host","local")).toModelNode());
  operation.get(ModelDescriptionConstants.RECURSIVE).set(true);
  final long time=System.currentTimeMillis() + TIMEOUT;
  boolean hasOne=false;
  boolean hasTwo=false;
  do {
    final ModelControllerClient client=ModelControllerClient.Factory.create(InetAddress.getLocalHost(),HC_PORT);
    Thread hack=new Thread(new Runnable(){
      @Override public void run(){
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
        }
        StreamUtils.safeClose(client);
      }
    }
);
    hack.start();
    try {
      final ModelNode result=client.execute(operation);
      if (result.get(ModelDescriptionConstants.OUTCOME).asString().equals(ModelDescriptionConstants.SUCCESS)) {
        final ModelNode model=result.require(ModelDescriptionConstants.RESULT);
        hasOne=model.get(ModelDescriptionConstants.HOST,ModelDescriptionConstants.LOCAL,ModelDescriptionConstants.RUNNING_SERVER).hasDefined(SERVER_ONE);
        hasTwo=model.get(ModelDescriptionConstants.HOST,ModelDescriptionConstants.LOCAL,ModelDescriptionConstants.RUNNING_SERVER).hasDefined(SERVER_TWO);
        if (hasOne && hasTwo) {
          return;
        }
      }
    }
 catch (    IOException e) {
    }
 finally {
      hack.interrupt();
      StreamUtils.safeClose(client);
    }
    Thread.sleep(200);
  }
 while (System.currentTimeMillis() < time);
  Assert.assertTrue(hasOne);
  Assert.assertTrue(hasTwo);
}
