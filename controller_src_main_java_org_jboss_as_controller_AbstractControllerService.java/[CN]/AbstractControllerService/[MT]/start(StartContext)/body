{
  if (configurationPersister == null) {
    throw ControllerLogger.ROOT_LOGGER.persisterNotInjected();
  }
  final ServiceController<?> serviceController=context.getController();
  final ServiceContainer container=serviceController.getServiceContainer();
  final ServiceTarget target=context.getChildTarget();
  final ExecutorService executorService=injectedExecutorService.getOptionalValue();
  WritableAuthorizerConfiguration authorizerConfig=authorizer.getWritableAuthorizerConfiguration();
  authorizerConfig.reset();
  ManagementResourceRegistration rootResourceRegistration=rootDescriptionProvider != null ? ManagementResourceRegistration.Factory.create(rootDescriptionProvider,authorizerConfig) : ManagementResourceRegistration.Factory.create(rootResourceDefinition,authorizerConfig);
  final ModelControllerImpl controller=new ModelControllerImpl(container,target,rootResourceRegistration,new ContainerStateMonitor(container),configurationPersister,processType,runningModeControl,prepareStep,processState,executorService,expressionResolver,authorizer,auditLogger);
  initModel(controller.getRootResource(),controller.getRootRegistration(),controller.getModelControllerResource());
  this.controller=controller;
  final long bootStackSize=getBootStackSize();
  final Thread bootThread=new Thread(null,new Runnable(){
    public void run(){
      try {
        try {
          boot(new BootContext(){
            public ServiceTarget getServiceTarget(){
              return target;
            }
          }
);
        }
  finally {
          processState.setRunning();
        }
      }
 catch (      Throwable t) {
        container.shutdown();
        if (t instanceof StackOverflowError) {
          ROOT_LOGGER.errorBootingContainer(t,bootStackSize,BOOT_STACK_SIZE_PROPERTY);
        }
 else {
          ROOT_LOGGER.errorBootingContainer(t);
        }
      }
 finally {
        bootThreadDone();
      }
    }
  }
,"Controller Boot Thread",bootStackSize);
  bootThread.start();
}
