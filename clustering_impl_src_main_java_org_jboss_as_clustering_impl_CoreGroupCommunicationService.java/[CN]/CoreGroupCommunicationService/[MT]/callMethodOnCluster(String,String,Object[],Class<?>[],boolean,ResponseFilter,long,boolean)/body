{
  MethodCall m=new MethodCall(serviceName + "." + methodName,args,types);
  RequestOptions options=new RequestOptions(ResponseMode.GET_ALL,methodTimeout,false,new NoHandlerForRPCRspFilter(filter));
  if (excludeSelf) {
    options.setExclusionList(this.channel.getAddress());
  }
  if (this.channel.flushSupported()) {
    this.flushBlockGate.await(this.getMethodCallTimeout());
  }
  boolean trace=ClusteringImplLogger.ROOT_LOGGER.isTraceEnabled();
  if (trace) {
    ClusteringImplLogger.ROOT_LOGGER.tracef("calling synchronous method on cluster, serviceName=%s, methodName=%s, members=%s, excludeSelf=%s",serviceName,methodName,this.groupView,excludeSelf);
  }
  try {
    RspList<T> rsp=this.dispatcher.callRemoteMethods(null,m,options);
    List<T> result=this.processResponseList(rsp,serviceName,methodName,args,trace);
    if (!excludeSelf && this.directlyInvokeLocal && (filter == null || filter.needMoreResponses())) {
      try {
        invokeDirectly(serviceName,methodName,args,types,result,filter);
      }
 catch (      Exception e) {
        if ((filter == null) || filter.isAcceptable(e,this.me)) {
          ClusteringImplLogger.ROOT_LOGGER.debugf(e,"%s local invocation failure: %s(%s)",serviceName,methodName,(args != null) ? Arrays.asList(args) : "");
        }
      }
    }
    return result;
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Error e) {
    throw e;
  }
catch (  InterruptedException e) {
    throw e;
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
