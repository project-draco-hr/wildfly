{
  if (!cancelled) {
    boolean fail=false;
    AsyncFuture<Long> future=null;
    try {
      if (interval < 1 || System.currentTimeMillis() - channelHandler.getLastMessageReceivedTime() > interval) {
        future=channelHandler.executeRequest(ManagementPingRequest.INSTANCE,null).getResult();
        Long id=future.get(timeout,TimeUnit.MILLISECONDS);
        if (!cancelled && remoteConnectionID != null && !remoteConnectionID.equals(id)) {
          HostControllerLogger.DOMAIN_LOGGER.slaveHostControllerChanged(hostName);
          fail=true;
        }
 else {
          remoteConnectionID=id;
        }
      }
    }
 catch (    IOException e) {
      HostControllerLogger.DOMAIN_LOGGER.debug("Caught exception sending ping request",e);
    }
catch (    InterruptedException e) {
      safeCancel(future);
      Thread.currentThread().interrupt();
    }
catch (    ExecutionException e) {
      HostControllerLogger.DOMAIN_LOGGER.debug("Caught exception sending ping request",e);
    }
catch (    TimeoutException e) {
      if (!cancelled) {
        fail=true;
        HostControllerLogger.DOMAIN_LOGGER.slaveHostControllerUnreachable(hostName,timeout);
      }
      safeCancel(future);
    }
 finally {
      if (fail) {
        Channel channel=null;
        try {
          channel=channelHandler.getChannel();
        }
 catch (        IOException e) {
        }
        StreamUtils.safeClose(channel);
      }
 else       if (!cancelled && interval > 0) {
        scheduler.schedule(this,interval,TimeUnit.MILLISECONDS);
      }
    }
  }
}
