{
  if (log.isTraceEnabled()) {
    log.trace("nullifying foreign keys");
  }
  Connection con=null;
  PreparedStatement[] ps=new PreparedStatement[fkConstraints.length];
  try {
    final JDBCCMPFieldBridge2[] pkFields=(JDBCCMPFieldBridge2[])entity.getPrimaryKeyFields();
    con=dataSource.getConnection();
    for (int i=0; i < rowsWithNullFks.size(); ++i) {
      final Row row=(Row)rowsWithNullFks.get(i);
      final ForeignKeyConstraint[] cons=row.fkUpdates;
      for (int c=0; c < fkConstraints.length; ++c) {
        if (cons[c] == null || row.state == DELETED && !cons[c].selfReference)         continue;
        PreparedStatement s=ps[c];
        if (s == null) {
          if (log.isDebugEnabled()) {
            log.debug("nullifying fk: " + cons[c].nullFkSql);
          }
          s=con.prepareStatement(cons[c].nullFkSql);
          ps[c]=s;
        }
        int paramInd=1;
        for (int fInd=0; fInd < pkFields.length; ++fInd) {
          JDBCCMPFieldBridge2 pkField=pkFields[fInd];
          Object fieldValue=row.fields[pkField.getRowIndex()];
          paramInd=pkField.setArgumentParameters(s,paramInd,fieldValue);
        }
        final int affected=s.executeUpdate();
        if (affected != 1) {
          throw new EJBException("Affected " + affected + " rows while expected just one");
        }
      }
    }
  }
  finally {
    for (int i=0; i < ps.length; ++i) {
      JDBCUtil.safeClose(ps[i]);
    }
    JDBCUtil.safeClose(con);
  }
}
