{
  final Cache<?,?> jvmRouteCache=cacheContainer.getCache();
  Registry.RegistryEntryProvider<String,Void> provider=new Registry.RegistryEntryProvider<String,Void>(){
    @Override public String getKey(){
      return jvmRoute;
    }
    @Override public Void getValue(){
      return null;
    }
  }
;
  final RegistryService<String,Void> registry=new RegistryService<String,Void>(provider);
  registry.getCacheInjector().inject(jvmRouteCache);
  DistributedCacheManagerFactory factory=new DistributedCacheManagerFactory();
  factory.getCacheContainerInjector().inject(cacheContainer);
  factory.getCacheConfigurationInjector().inject(jvmRouteCache.getCacheConfiguration());
  factory.getRegistryInjector().inject(registry);
  factory.getLockManagerInjector().inject(((ExtendedCacheManager)cacheContainer).getLockManager());
  Engine engine=new MockEngine();
  engine.setName("jboss.web");
  engine.setJvmRoute(jvmRoute);
  Host host=new MockHost();
  host.setName("localhost");
  engine.addChild(host);
  StandardContext context=new StandardContext();
  context.setName(warName);
  context.setDomain(jvmRoute);
  host.addChild(context);
  try {
    DistributableSessionManager<OutgoingDistributableSessionData> manager=new DistributableSessionManager<OutgoingDistributableSessionData>(factory,context,metaData){
      @Override public void start() throws LifecycleException {
        try {
          jvmRouteCache.start();
          registry.start(mock(StartContext.class));
          super.start();
        }
 catch (        Exception e) {
          throw new IllegalStateException(e);
        }
      }
      @Override public void stop() throws LifecycleException {
        try {
          super.stop();
          if (jvmRouteCache.getStatus().allowInvocations()) {
            registry.stop(mock(StopContext.class));
            jvmRouteCache.stop();
          }
        }
 catch (        Exception e) {
          throw new IllegalStateException(e);
        }
      }
    }
;
    context.setManager(manager);
    manager.setMaxInactiveInterval(maxInactiveInterval);
    return manager;
  }
 catch (  ClusteringNotSupportedException e) {
    throw new IllegalStateException(e);
  }
}
