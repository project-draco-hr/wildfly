{
  if (cacheContainer == null) {
    throw new IllegalStateException("Failed to initialize distributedManagerFactory");
  }
  final Cache sessionCache=cacheContainer.getCache();
  final Cache jvmRouteCache=cacheContainer.getCache(JVM_ROUTE_CACHE_NAME);
  DistributedCacheManagerFactory factory=new DistributedCacheManagerFactory();
  factory.getSessionCacheInjector().inject(sessionCache);
  factory.getJvmRouteCacheInjector().inject(jvmRouteCache);
  final CoreGroupCommunicationService service=new CoreGroupCommunicationService();
  service.setChannel(((JGroupsTransport)sessionCache.getCacheManager().getTransport()).getChannel());
  service.setScopeId(Integer.valueOf(0).shortValue());
  final SharedLocalYieldingClusterLockManager lockManager=new SharedLocalYieldingClusterLockManager("lock",service,service);
  factory.getLockManagerInjector().inject(lockManager);
  try {
    DistributableSessionManager<OutgoingDistributableSessionData> manager=new DistributableSessionManager<OutgoingDistributableSessionData>(factory,mock(Container.class),metaData){
      @Override public synchronized void start() throws LifecycleException {
        try {
          service.start();
          lockManager.start();
          jvmRouteCache.start();
          sessionCache.start();
          super.start();
        }
 catch (        Exception e) {
          throw new LifecycleException(e);
        }
      }
      @Override public void stop() throws LifecycleException {
        try {
          super.stop();
          sessionCache.stop();
          jvmRouteCache.stop();
          lockManager.stop();
          service.stop();
        }
 catch (        Exception e) {
          throw new LifecycleException(e);
        }
      }
    }
;
    setupContainer(warName,jvmRoute,manager);
    manager.setMaxInactiveInterval(maxInactiveInterval);
    return manager;
  }
 catch (  ClusteringNotSupportedException e) {
    throw new IllegalStateException(e);
  }
}
