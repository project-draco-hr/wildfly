{
  final List<ExtensionJar> jars=extensions.get(name);
  if (jars != null)   for (  ExtensionJar extensionJar : jars) {
    final VirtualFile root=extensionJar.root;
    final String implVendorId=extensionJar.implVendorId;
    if (requiredVendorId != null && !requiredVendorId.equals(implVendorId)) {
      log.debugf("Skipping extension JAR %s because vendor ID %s does not match required vendor ID %s",root.getName(),requiredVendorId,implVendorId);
      continue;
    }
    if (minSpecVersion != null) {
      final String specVersion=extensionJar.specVersion;
      if (specVersion == null) {
        log.debugf("Skipping extension JAR %s because spec version is missing but %s is required",root.getName(),minSpecVersion);
        continue;
      }
      try {
        if (compareVersion(minSpecVersion,specVersion) > 0) {
          log.debugf("Skipping extension JAR %s because spec version %s is less than required version %s",root.getName(),specVersion,minSpecVersion);
          continue;
        }
      }
 catch (      NumberFormatException e) {
        log.debugf("Skipping extension JAR %s because version compare of spec version failed");
        continue;
      }
    }
    if (minImplVersion != null) {
      final String implVersion=extensionJar.implVersion;
      if (implVersion == null) {
        log.debugf("Skipping extension JAR %s because impl version is missing but %s is required",root.getName(),minImplVersion);
        continue;
      }
      try {
        if (compareVersion(minImplVersion,implVersion) > 0) {
          log.debugf("Skipping extension JAR %s because impl version %s is less than required version %s",root.getName(),implVersion,minImplVersion);
          continue;
        }
      }
 catch (      NumberFormatException e) {
        log.debugf("Skipping extension JAR %s because version compare of impl version failed");
        continue;
      }
    }
    log.debugf("Matched extension JAR %s",root);
    return new ResourceRoot(name,root,new MountHandle(extensionJar.handle));
  }
  return null;
}
