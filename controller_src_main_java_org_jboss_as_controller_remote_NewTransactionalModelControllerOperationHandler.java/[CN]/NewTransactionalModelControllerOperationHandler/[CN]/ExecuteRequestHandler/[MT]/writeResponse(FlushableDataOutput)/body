{
  executorService.execute(new Runnable(){
    @Override public void run(){
      final OperationMessageHandlerProxy messageHandlerProxy=new OperationMessageHandlerProxy(getContext(),executeRequestContext.getBatchId());
      final ProxyOperationControlProxy control=new ProxyOperationControlProxy(executeRequestContext);
      final ModelNode result;
      try {
        result=controller.execute(operation,messageHandlerProxy,control,new OperationAttachmentsProxy(getContext(),executeRequestContext.getBatchId(),attachmentsLength));
      }
 catch (      Exception e) {
        final ModelNode failure=new ModelNode();
        failure.get(OUTCOME).set(FAILED);
        failure.get(FAILURE_DESCRIPTION).set(e.getClass().getName() + ":" + e.getMessage());
        control.operationFailed(failure);
        return;
      }
      if (result.hasDefined(FAILURE_DESCRIPTION)) {
        control.operationFailed(result);
      }
 else {
        try {
          executeRequestContext.awaitTxCompleted();
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          executeRequestContext.setError("Error waiting for Tx commit/rollback");
        }
        control.operationCompleted(result);
      }
    }
  }
);
  try {
    executeRequestContext.awaitPreparedOrFailed();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new IOException("Thread was interrupted waiting for the operation to prepare/fail");
  }
}
