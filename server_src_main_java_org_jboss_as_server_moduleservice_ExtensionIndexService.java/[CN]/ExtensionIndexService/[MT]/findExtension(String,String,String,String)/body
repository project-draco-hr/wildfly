{
  final Set<ExtensionJar> jars=extensions.get(name.trim());
  if (jars != null)   for (  ExtensionJar extensionJar : jars) {
    final String implVendorId=extensionJar.implVendorId;
    if (requiredVendorId != null && !requiredVendorId.equals(implVendorId.trim())) {
      log.debugf("Skipping extension JAR %s because vendor ID %s does not match required vendor ID %s",extensionJar.path,requiredVendorId,implVendorId);
      continue;
    }
    if (minSpecVersion != null) {
      final String specVersion=extensionJar.specVersion;
      if (specVersion == null) {
        log.debugf("Skipping extension JAR %s because spec version is missing but %s is required",extensionJar.path,minSpecVersion);
        continue;
      }
      try {
        if (compareVersion(minSpecVersion.trim(),specVersion) > 0) {
          log.debugf("Skipping extension JAR %s because spec version %s is less than required version %s",extensionJar.path,specVersion,minSpecVersion);
          continue;
        }
      }
 catch (      NumberFormatException e) {
        log.debugf("Skipping extension JAR %s because version compare of spec version failed");
        continue;
      }
    }
    if (minImplVersion != null) {
      final String implVersion=extensionJar.implVersion;
      if (implVersion == null) {
        log.debugf("Skipping extension JAR %s because impl version is missing but %s is required",extensionJar.path,minImplVersion);
        continue;
      }
      try {
        if (compareVersion(minImplVersion.trim(),implVersion) > 0) {
          log.debugf("Skipping extension JAR %s because impl version %s is less than required version %s",extensionJar.path,implVersion,minImplVersion);
          continue;
        }
      }
 catch (      NumberFormatException e) {
        log.debugf("Skipping extension JAR %s because version compare of impl version failed");
        continue;
      }
    }
    log.debugf("Matched extension JAR %s",extensionJar.path);
    return extensionJar.moduleIdentifier;
  }
  return null;
}
