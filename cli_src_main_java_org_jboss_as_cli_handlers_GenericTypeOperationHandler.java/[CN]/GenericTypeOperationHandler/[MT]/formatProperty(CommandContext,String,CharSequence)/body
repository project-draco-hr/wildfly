{
  final StringBuilder prop=new StringBuilder();
  prop.append(' ').append(argName);
  int spaces=DASH_OFFSET - prop.length();
  do {
    prop.append(' ');
    --spaces;
  }
 while (spaces >= 0);
  int terminalWidth=ctx.getTerminalWidth();
  if (terminalWidth <= 0) {
    terminalWidth=80;
  }
  int dashIndex=prop.length();
  int textOffset=dashIndex + 3;
  int textLength=terminalWidth - textOffset;
  prop.append(" - ");
  if (descr.length() <= textLength) {
    prop.append(descr);
    prop.append(Util.LINE_SEPARATOR);
  }
 else {
    int lineStart=0;
    int lineNo=1;
    while (lineStart < descr.length()) {
      prop.ensureCapacity(terminalWidth);
      if (lineStart > 0) {
        if (lineNo == 3 && dashIndex > DASH_OFFSET) {
          textOffset=DASH_OFFSET + 2;
          textLength=terminalWidth - textOffset;
        }
        for (int i=0; i < textOffset; ++i) {
          prop.append(' ');
        }
      }
      int lastCharIndex=lineStart + textLength;
      if (lastCharIndex >= descr.length()) {
        lastCharIndex=descr.length();
        prop.append(descr.subSequence(lineStart,lastCharIndex));
        lineStart=lastCharIndex;
      }
 else {
        while (lastCharIndex >= lineStart && !Character.isWhitespace(descr.charAt(lastCharIndex))) {
          --lastCharIndex;
        }
        if (lastCharIndex <= lineStart) {
          lastCharIndex=lineStart + textLength;
          prop.append(descr.subSequence(lineStart,lastCharIndex));
          lineStart=lastCharIndex;
        }
 else {
          prop.append(descr.subSequence(lineStart,lastCharIndex));
          lineStart=lastCharIndex + 1;
        }
      }
      prop.append(Util.LINE_SEPARATOR);
      ++lineNo;
    }
  }
  ctx.printLine(prop.toString());
}
