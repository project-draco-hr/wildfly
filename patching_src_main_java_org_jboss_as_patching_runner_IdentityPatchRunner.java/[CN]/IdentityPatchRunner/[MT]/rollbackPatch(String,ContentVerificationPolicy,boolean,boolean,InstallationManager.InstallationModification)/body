{
  if (Constants.BASE.equals(patchId)) {
    throw PatchMessages.MESSAGES.cannotRollbackPatch(patchId);
  }
  final List<String> patches=new ArrayList<String>();
  final List<String> oneOffs=modification.getPatchIDs();
  final int index=oneOffs.indexOf(patchId);
  if (index == -1) {
    if (patchId.equals(modification.getCumulativePatchID())) {
      patches.addAll(oneOffs);
      patches.add(modification.getCumulativePatchID());
    }
 else {
      throw PatchMessages.MESSAGES.cannotRollbackPatch(patchId);
    }
  }
 else   if (index == 0) {
    patches.add(patchId);
  }
 else {
    if (rollbackTo) {
      for (int i=0; i <= index; i++) {
        patches.add(oneOffs.get(i));
      }
    }
 else {
      throw PatchMessages.MESSAGES.cannotRollbackPatch(patchId);
    }
  }
  final File historyDir=installedImage.getPatchHistoryDir(patchId);
  if (!historyDir.exists()) {
    throw PatchMessages.MESSAGES.cannotRollbackPatch(patchId);
  }
  final File patchXml=new File(historyDir,Constants.ROLLBACK_XML);
  if (!patchXml.exists()) {
    throw PatchMessages.MESSAGES.cannotRollbackPatch(patchId);
  }
  final File workDir=createTempDir();
  final PatchContentProvider provider=PatchContentProvider.ROLLBACK_PROVIDER;
  final IdentityPatchContext context=new IdentityPatchContext(workDir,provider,contentPolicy,modification,ROLLBACK,installedImage);
  try {
    for (    final String rollback : patches) {
      if (!Constants.BASE.equals(rollback)) {
        rollback(rollback,context);
      }
    }
    final IdentityPatchContext.PatchEntry identity=context.getIdentityEntry();
    final IdentityRollbackCallback callback=new IdentityRollbackCallback(patchId,patches,resetConfiguration,identity.getDirectoryStructure());
    try {
      return executeTasks(context,callback);
    }
 catch (    Exception e) {
      context.cancel(callback);
      PatchLogger.ROOT_LOGGER.debugf(e,"failed to rollback patch %s",patchId);
      throw rethrowException(e);
    }
  }
  finally {
    context.cleanup();
  }
}
