{
  final String realm=options.containsKey(REALM_OPTION) ? (String)options.get(REALM_OPTION) : DEFAULT_REALM;
  super.initialize(subject,callbackHandler,sharedState,options);
  securityRealm=AccessController.doPrivileged(new PrivilegedAction<SecurityRealm>(){
    public SecurityRealm run(){
      final ServiceController<?> controller=CurrentServiceContainer.getServiceContainer().getService(SecurityRealmService.BASE_SERVICE_NAME.append(realm));
      if (controller != null) {
        return (SecurityRealm)controller.getValue();
      }
      return null;
    }
  }
);
  if (securityRealm == null) {
    throw SecurityMessages.MESSAGES.realmNotFound(realm);
  }
  Set<AuthenticationMechanism> authMechs=securityRealm.getSupportedAuthenticationMechanisms();
  if (authMechs.contains(AuthenticationMechanism.DIGEST)) {
    chosenMech=AuthenticationMechanism.DIGEST;
  }
 else   if (authMechs.contains(AuthenticationMechanism.PLAIN)) {
    chosenMech=AuthenticationMechanism.PLAIN;
  }
 else {
    throw SecurityMessages.MESSAGES.noPasswordValidationAvailable(realm);
  }
  Map<String,String> mechOpts=securityRealm.getMechanismConfig(chosenMech);
  if (mechOpts.containsKey(VERIFY_PASSWORD_CALLBACK_SUPPORTED) && Boolean.parseBoolean(mechOpts.get(VERIFY_PASSWORD_CALLBACK_SUPPORTED))) {
    validationMode=ValidationMode.VALIDATION;
  }
 else {
    if (chosenMech == AuthenticationMechanism.DIGEST) {
      boolean plainTextDigest=true;
      if (mechOpts.containsKey(DIGEST_PLAIN_TEXT) && Boolean.parseBoolean(mechOpts.get(DIGEST_PLAIN_TEXT))) {
        validationMode=ValidationMode.PASSWORD;
      }
 else {
        validationMode=ValidationMode.DIGEST;
        try {
          hashUtil=new UsernamePasswordHashUtil();
        }
 catch (        NoSuchAlgorithmException e) {
          throw new IllegalStateException(e);
        }
      }
    }
 else {
      validationMode=ValidationMode.PASSWORD;
    }
  }
}
