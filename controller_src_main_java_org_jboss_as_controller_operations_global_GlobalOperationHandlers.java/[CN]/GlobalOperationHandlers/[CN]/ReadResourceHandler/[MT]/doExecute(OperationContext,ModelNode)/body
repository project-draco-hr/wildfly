{
  validator.validate(operation);
  final String opName=operation.require(OP).asString();
  final ModelNode opAddr=operation.get(OP_ADDR);
  final PathAddress address=PathAddress.pathAddress(opAddr);
  final int recursiveDepth=operation.get(RECURSIVE_DEPTH).asInt(0);
  final boolean recursive=recursiveDepth > 0 ? true : operation.get(RECURSIVE).asBoolean(false);
  final boolean queryRuntime=operation.get(INCLUDE_RUNTIME).asBoolean(false);
  final boolean proxies=operation.get(PROXIES).asBoolean(false);
  final boolean defaults=operation.get(INCLUDE_DEFAULTS).asBoolean(true);
  final Map<String,ModelNode> directAttributes=new HashMap<String,ModelNode>();
  final Map<String,ModelNode> directChildren=new HashMap<String,ModelNode>();
  final Map<String,ModelNode> metrics=queryRuntime ? new HashMap<String,ModelNode>() : Collections.<String,ModelNode>emptyMap();
  final Map<String,ModelNode> otherAttributes=new HashMap<String,ModelNode>();
  final Map<PathElement,ModelNode> childResources=recursive ? new LinkedHashMap<PathElement,ModelNode>() : Collections.<PathElement,ModelNode>emptyMap();
  final ReadResourceAssemblyHandler assemblyHandler=new ReadResourceAssemblyHandler(directAttributes,metrics,otherAttributes,directChildren,childResources);
  context.addStep(assemblyHandler,queryRuntime ? OperationContext.Stage.VERIFY : OperationContext.Stage.IMMEDIATE,queryRuntime);
  final ImmutableManagementResourceRegistration registry=context.getResourceRegistration();
  final Resource resource=nullSafeReadResource(context,registry);
  final Map<String,Set<String>> childrenByType=registry != null ? getChildAddresses(registry,resource,null) : Collections.<String,Set<String>>emptyMap();
  final ModelNode model=resource.getModel();
  if (model.isDefined()) {
    for (    String key : model.keys()) {
      if (!childrenByType.containsKey(key)) {
        directAttributes.put(key,model.get(key));
      }
    }
    if (defaults) {
      final DescriptionProvider descriptionProvider=registry.getModelDescription(PathAddress.EMPTY_ADDRESS);
      final Locale locale=getLocale(context,operation);
      final ModelNode nodeDescription=descriptionProvider.getModelDescription(locale);
      if (nodeDescription.isDefined() && nodeDescription.hasDefined(ATTRIBUTES)) {
        for (        String key : nodeDescription.get(ATTRIBUTES).keys()) {
          if ((!childrenByType.containsKey(key)) && (!directAttributes.containsKey(key) || !directAttributes.get(key).isDefined()) && nodeDescription.get(ATTRIBUTES).hasDefined(key)&& nodeDescription.get(ATTRIBUTES,key).hasDefined(DEFAULT)) {
            directAttributes.put(key,nodeDescription.get(ATTRIBUTES,key,DEFAULT));
          }
        }
      }
    }
  }
  for (  Map.Entry<String,Set<String>> entry : childrenByType.entrySet()) {
    String childType=entry.getKey();
    Set<String> children=entry.getValue();
    if (children.isEmpty()) {
      directAttributes.put(childType,new ModelNode());
    }
 else {
      for (      String child : children) {
        boolean storeDirect=!recursive;
        if (recursive) {
          PathElement childPE=PathElement.pathElement(childType,child);
          PathAddress relativeAddr=PathAddress.pathAddress(childPE);
          ImmutableManagementResourceRegistration childReg=registry.getSubModel(relativeAddr);
          if (childReg == null) {
            throw new OperationFailedException(new ModelNode().set(MESSAGES.noChildRegistry(childType,child)));
          }
          boolean proxy=childReg.isRemote();
          boolean runtimeResource=childReg.isRuntimeOnly();
          if (!runtimeResource || (queryRuntime && !proxy) || (proxies && proxy)) {
            final int newDepth=recursiveDepth > 0 ? recursiveDepth - 1 : 0;
            ModelNode rrOp=new ModelNode();
            rrOp.get(OP).set(opName);
            rrOp.get(OP_ADDR).set(PathAddress.pathAddress(address,childPE).toModelNode());
            rrOp.get(RECURSIVE).set(operation.get(RECURSIVE));
            rrOp.get(RECURSIVE_DEPTH).set(newDepth);
            rrOp.get(PROXIES).set(proxies);
            rrOp.get(INCLUDE_RUNTIME).set(queryRuntime);
            ModelNode rrRsp=new ModelNode();
            childResources.put(childPE,rrRsp);
            OperationStepHandler rrHandler=childReg.getOperationHandler(PathAddress.EMPTY_ADDRESS,opName);
            context.addStep(rrRsp,rrOp,rrHandler,OperationContext.Stage.IMMEDIATE);
          }
 else {
            storeDirect=true;
          }
        }
        if (storeDirect) {
          ModelNode childMap=directChildren.get(childType);
          if (childMap == null) {
            childMap=new ModelNode();
            childMap.setEmptyObject();
            directChildren.put(childType,childMap);
          }
          childMap.get(child);
        }
      }
    }
  }
  final Set<String> attributeNames=registry != null ? registry.getAttributeNames(PathAddress.EMPTY_ADDRESS) : Collections.<String>emptySet();
  for (  final String attributeName : attributeNames) {
    final AttributeAccess access=registry.getAttributeAccess(PathAddress.EMPTY_ADDRESS,attributeName);
    if (access == null) {
      continue;
    }
 else {
      final AttributeAccess.Storage storage=access.getStorageType();
      if (!queryRuntime && storage != AttributeAccess.Storage.CONFIGURATION) {
        continue;
      }
      final AccessType type=access.getAccessType();
      final OperationStepHandler handler=access.getReadHandler();
      if (handler != null) {
        directAttributes.remove(attributeName);
        final ModelNode attributeOperation=new ModelNode();
        attributeOperation.get(OP_ADDR).set(opAddr);
        attributeOperation.get(OP).set(READ_ATTRIBUTE_OPERATION);
        attributeOperation.get(NAME).set(attributeName);
        final ModelNode attrResponse=new ModelNode();
        if (type == AccessType.METRIC) {
          metrics.put(attributeName,attrResponse);
        }
 else {
          otherAttributes.put(attributeName,attrResponse);
        }
        context.addStep(attrResponse,attributeOperation,handler,OperationContext.Stage.IMMEDIATE);
      }
    }
  }
  context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
