{
  final PathAddress current=address.subAddress(base.size());
  final Iterator<PathElement> iterator=current.iterator();
  if (iterator.hasNext()) {
    final PathElement element=iterator.next();
    if (element.isMultiTarget()) {
      final String childType;
      if (element.getKey().equals("**")) {
        childType=null;
      }
 else {
        childType=element.getKey();
      }
      final ModelNodeRegistration registration=context.getModelNodeRegistration().getSubModel(base);
      final ModelNode model=context.readModel(base);
      final Map<String,Set<String>> resolved=getChildAddresses(registration,model,childType);
      for (      Map.Entry<String,Set<String>> entry : resolved.entrySet()) {
        final String key=entry.getKey();
        final Set<String> children=entry.getValue();
        if (children.isEmpty()) {
          continue;
        }
        if (element.isWildcard()) {
          for (          final String child : children) {
            execute(address,base.append(PathElement.pathElement(key,child)),context);
          }
        }
 else {
          for (          final String segment : element.getSegments()) {
            if (children.contains(segment)) {
              execute(address,base.append(PathElement.pathElement(key,segment)),context);
            }
          }
        }
      }
    }
 else {
      execute(address,base.append(element),context);
    }
  }
 else {
    final String operationName=operation.require(OP).asString();
    final ModelNode newOp=operation.clone();
    newOp.get(OP_ADDR).set(base.toModelNode());
    final ModelNode result=context.getResult().add();
    result.get(OP_ADDR).set(base.toModelNode());
    final NewStepHandler handler=context.getModelNodeRegistration().getOperationHandler(base,operationName);
    context.addStep(result,newOp,handler,NewOperationContext.Stage.MODEL);
  }
}
