{
  Map<String,Set<String>> result=new HashMap<String,Set<String>>();
  Set<PathElement> elements=registry.getChildAddresses(PathAddress.EMPTY_ADDRESS);
  for (  PathElement element : elements) {
    String childType=element.getKey();
    if (validChildType != null && !validChildType.equals(childType)) {
      continue;
    }
    final ImmutableManagementResourceRegistration childRegistration=registry.getSubModel(PathAddress.pathAddress(element));
    final AliasEntry aliasEntry=childRegistration.getAliasEntry();
    Set<String> set=result.get(childType);
    if (set == null) {
      set=new LinkedHashSet<String>();
      result.put(childType,set);
    }
    if (aliasEntry == null) {
      if (resource != null && resource.hasChildren(childType)) {
        set.addAll(resource.getChildrenNames(childType));
      }
    }
 else {
      PathAddress target=aliasEntry.convertToTargetAddress(addr.append(element));
      PathAddress targetParent=target.subAddress(0,target.size() - 1);
      Resource parentResource=context.readResourceFromRoot(targetParent);
      if (parentResource != null && parentResource.hasChildren(target.getLastElement().getKey())) {
        set.add(element.getValue());
      }
    }
    if (!element.isWildcard()) {
      ImmutableManagementResourceRegistration childReg=registry.getSubModel(PathAddress.pathAddress(element));
      if (childReg != null && childReg.isRuntimeOnly()) {
        set.add(element.getValue());
      }
    }
  }
  for (  String type : registry.getChildNames(PathAddress.EMPTY_ADDRESS)) {
    if ((validChildType == null || validChildType.equals(validChildType)) && !result.containsKey(type)) {
      result.put(type,Collections.<String>emptySet());
    }
  }
  return result;
}
