{
  super(reader);
  if (reader.getAttributeCount() > 0) {
    throw unexpectedAttribute(reader,0);
  }
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
switch (Namespace.forUri(reader.getNamespaceURI())) {
case THREADS_1_0:
{
        final Element element=Element.forName(reader.getLocalName());
switch (element) {
case THREAD_FACTORY:
{
            final ThreadFactoryElement threadFactoryElement=new ThreadFactoryElement(reader);
            final String name=threadFactoryElement.getName();
            if (threadFactories.containsKey(name)) {
              throw duplicateNamedElement(reader,name);
            }
            threadFactories.put(name,threadFactoryElement);
            break;
          }
case SCHEDULED_THREAD_POOL_EXECUTOR:
{
          final ScheduledThreadPoolExecutorElement executorElement=new ScheduledThreadPoolExecutorElement(reader);
          final String name=executorElement.getName();
          if (scheduledExecutors.containsKey(name)) {
            throw duplicateNamedElement(reader,name);
          }
          scheduledExecutors.put(name,executorElement);
          break;
        }
case BOUNDED_QUEUE_THREAD_POOL_EXECUTOR:
case QUEUELESS_THREAD_POOL_EXECUTOR:
case THREAD_FACTORY_EXECUTOR:
case UNBOUNDED_QUEUE_THREAD_POOL_EXECUTOR:
{
        final AbstractExecutorElement<?> executorElement;
switch (element) {
case BOUNDED_QUEUE_THREAD_POOL_EXECUTOR:
{
            executorElement=new BoundedQueueThreadPoolExecutorElement(reader);
            break;
          }
case QUEUELESS_THREAD_POOL_EXECUTOR:
{
          executorElement=new QueuelessThreadPoolExecutorElement(reader);
          break;
        }
case THREAD_FACTORY_EXECUTOR:
{
        executorElement=new ThreadFactoryExecutorElement(reader);
        break;
      }
case UNBOUNDED_QUEUE_THREAD_POOL_EXECUTOR:
{
      executorElement=new UnboundedQueueThreadPoolExecutor(reader);
      break;
    }
default :
{
    throw new IllegalStateException();
  }
}
final String name=executorElement.getName();
if (executors.containsKey(name)) {
throw duplicateNamedElement(reader,name);
}
executors.put(name,executorElement);
break;
}
default :
throw unexpectedElement(reader);
}
break;
}
default :
throw unexpectedElement(reader);
}
}
}
