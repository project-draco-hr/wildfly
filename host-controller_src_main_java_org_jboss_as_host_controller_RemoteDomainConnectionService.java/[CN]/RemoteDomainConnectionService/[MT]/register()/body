{
  boolean connected=false;
  final long timeout=30000;
  final long endTime=System.currentTimeMillis() + timeout;
  int retries=0;
  while (!connected) {
    RemoteDomainConnection.RegistrationResult result=null;
    try {
      result=connection.connect();
      connected=true;
    }
 catch (    IOException e) {
      Throwable cause=e;
      HostControllerLogger.ROOT_LOGGER.debugf(e,"failed to connect to %s:%d",localHostInfo.getRemoteDomainControllerHost(),localHostInfo.getRemoteDomainControllerPort());
      while ((cause=cause.getCause()) != null) {
        if (cause instanceof SaslException) {
          throw MESSAGES.authenticationFailureUnableToConnect(cause);
        }
 else         if (cause instanceof SSLHandshakeException) {
          throw MESSAGES.sslFailureUnableToConnect(cause);
        }
      }
      if (System.currentTimeMillis() > endTime) {
        throw MESSAGES.connectionToMasterTimeout(e,retries,timeout);
      }
      try {
        HostControllerLogger.ROOT_LOGGER.cannotConnect(localHostInfo.getRemoteDomainControllerHost(),localHostInfo.getRemoteDomainControllerPort(),e);
        ReconnectPolicy.CONNECT.wait(retries);
        retries++;
      }
 catch (      InterruptedException ie) {
        throw MESSAGES.connectionToMasterInterrupted();
      }
    }
    if (result != null && !result.isOK()) {
switch (result.getCode()) {
case HOST_ALREADY_EXISTS:
        throw new HostAlreadyExistsException(result.getMessage());
default :
      throw new IOException(new SlaveRegistrationException(result.getCode(),result.getMessage()).marshal());
  }
}
}
if (connected) {
handler.addHandlerFactory(new TransactionalProtocolOperationHandler(controller,handler));
masterProxy=ExistingChannelModelControllerClient.createAndAdd(handler);
}
}
