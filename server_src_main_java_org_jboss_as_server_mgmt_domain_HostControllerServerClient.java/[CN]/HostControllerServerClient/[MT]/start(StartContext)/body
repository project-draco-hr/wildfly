{
  this.processStateInjectedValue.getValue().addPropertyChangeListener(processStateListener);
  final ModelController controller=this.controller.getValue();
  context.asynchronous();
  try {
    final ProtocolChannelClient.Configuration configuration=new ProtocolChannelClient.Configuration();
    configuration.setEndpoint(endpointInjector.getValue());
    configuration.setConnectionTimeout(15000);
    configuration.setUri(new URI("remote://" + hostName + ":"+ port));
    final OptionMap original=configuration.getOptionMap();
    OptionMap.Builder builder=OptionMap.builder();
    builder.addAll(original);
    builder.set(Options.SASL_DISALLOWED_MECHANISMS,Sequence.of(JBOSS_LOCAL_USER));
    configuration.setOptionMap(builder.getMap());
    final CallbackHandler callbackHandler=new ClientCallbackHandler(userName,authKey);
    connection=new HostControllerServerConnection(serverProcessName,configuration,executor);
    connection.connect(callbackHandler,new ActiveOperation.CompletedCallback<Void>(){
      @Override public void completed(      Void result){
        final ManagementChannelHandler handler=connection.getChannelHandler();
        handler.addHandlerFactory(new TransactionalProtocolOperationHandler(controller,handler));
        remoteFileRepositoryValue.getValue().setRemoteFileRepositoryExecutor(new RemoteFileRepositoryExecutorImpl());
        context.complete();
      }
      @Override public void failed(      Exception e){
        context.failed(ServerMessages.MESSAGES.failedToConnectToHC(e));
      }
      @Override public void cancelled(){
        context.failed(ServerMessages.MESSAGES.cancelledHCConnect());
      }
    }
);
    handler=connection.getChannelHandler();
  }
 catch (  Exception e) {
    throw ServerMessages.MESSAGES.failedToConnectToHC(e);
  }
}
