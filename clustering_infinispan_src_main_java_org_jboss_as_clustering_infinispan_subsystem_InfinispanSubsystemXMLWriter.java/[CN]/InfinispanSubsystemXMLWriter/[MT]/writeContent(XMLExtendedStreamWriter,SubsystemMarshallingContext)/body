{
  context.startSubsystemElement(Namespace.CURRENT.getUri(),false);
  ModelNode model=context.getModelNode();
  if (model.isDefined()) {
    writer.writeAttribute(Attribute.DEFAULT_CACHE_CONTAINER.getLocalName(),model.require(ModelKeys.DEFAULT_CACHE_CONTAINER).asString());
    for (    Property entry : model.get(ModelKeys.CACHE_CONTAINER).asPropertyList()) {
      String containerName=entry.getName();
      ModelNode container=entry.getValue();
      writer.writeStartElement(Element.CACHE_CONTAINER.getLocalName());
      writer.writeAttribute(Attribute.NAME.getLocalName(),containerName);
      this.writeRequired(writer,Attribute.DEFAULT_CACHE,container,ModelKeys.DEFAULT_CACHE);
      this.writeAliases(writer,Attribute.ALIASES,container,ModelKeys.ALIASES);
      this.writeOptional(writer,Attribute.JNDI_NAME,container,ModelKeys.JNDI_NAME);
      this.writeOptional(writer,Attribute.START,container,ModelKeys.START);
      this.writeOptional(writer,Attribute.LISTENER_EXECUTOR,container,ModelKeys.LISTENER_EXECUTOR);
      this.writeOptional(writer,Attribute.EVICTION_EXECUTOR,container,ModelKeys.EVICTION_EXECUTOR);
      this.writeOptional(writer,Attribute.REPLICATION_QUEUE_EXECUTOR,container,ModelKeys.REPLICATION_QUEUE_EXECUTOR);
      if (container.hasDefined(ModelKeys.TRANSPORT)) {
        writer.writeStartElement(Element.TRANSPORT.getLocalName());
        ModelNode transport=container.get(ModelKeys.TRANSPORT,ModelKeys.TRANSPORT_NAME);
        this.writeOptional(writer,Attribute.STACK,transport,ModelKeys.STACK);
        this.writeOptional(writer,Attribute.EXECUTOR,transport,ModelKeys.EXECUTOR);
        this.writeOptional(writer,Attribute.LOCK_TIMEOUT,transport,ModelKeys.LOCK_TIMEOUT);
        this.writeOptional(writer,Attribute.SITE,transport,ModelKeys.SITE);
        this.writeOptional(writer,Attribute.RACK,transport,ModelKeys.RACK);
        this.writeOptional(writer,Attribute.MACHINE,transport,ModelKeys.MACHINE);
        writer.writeEndElement();
      }
      List<Property> cachesPL=new ArrayList<Property>();
      String[] cacheTypes={ModelKeys.LOCAL_CACHE,ModelKeys.INVALIDATION_CACHE,ModelKeys.REPLICATED_CACHE,ModelKeys.DISTRIBUTED_CACHE};
      for (      String cacheType : cacheTypes) {
        List<Property> cachesOfAType=getCachesAsPropertyList(model,containerName,cacheType);
        if (cachesOfAType != null)         cachesPL.addAll(cachesOfAType);
      }
      List<ModelNode> caches=new ArrayList<ModelNode>();
      for (      Property cacheEntry : cachesPL) {
        caches.add(cacheEntry.getValue());
      }
      for (      ModelNode cache : caches) {
        CacheMode mode=CacheMode.valueOf(cache.get(ModelKeys.CACHE_MODE).asString());
        if (mode.isClustered()) {
          if (mode.isDistributed()) {
            writer.writeStartElement(Element.DISTRIBUTED_CACHE.getLocalName());
            this.writeOptional(writer,Attribute.OWNERS,cache,ModelKeys.OWNERS);
            this.writeOptional(writer,Attribute.VIRTUAL_NODES,cache,ModelKeys.VIRTUAL_NODES);
            this.writeOptional(writer,Attribute.L1_LIFESPAN,cache,ModelKeys.L1_LIFESPAN);
          }
 else           if (mode.isInvalidation()) {
            writer.writeStartElement(Element.INVALIDATION_CACHE.getLocalName());
          }
 else {
            writer.writeStartElement(Element.REPLICATED_CACHE.getLocalName());
          }
          writer.writeAttribute(Attribute.MODE.getLocalName(),Mode.forCacheMode(mode).name());
          this.writeOptional(writer,Attribute.QUEUE_SIZE,cache,ModelKeys.QUEUE_SIZE);
          this.writeOptional(writer,Attribute.QUEUE_FLUSH_INTERVAL,cache,ModelKeys.QUEUE_FLUSH_INTERVAL);
          this.writeOptional(writer,Attribute.REMOTE_TIMEOUT,cache,ModelKeys.REMOTE_TIMEOUT);
        }
 else {
          writer.writeStartElement(Element.LOCAL_CACHE.getLocalName());
        }
        this.writeRequired(writer,Attribute.NAME,cache,ModelKeys.NAME);
        this.writeOptional(writer,Attribute.START,cache,ModelKeys.START);
        this.writeOptional(writer,Attribute.BATCHING,cache,ModelKeys.BATCHING);
        this.writeOptional(writer,Attribute.INDEXING,cache,ModelKeys.INDEXING);
        this.writeOptional(writer,Attribute.JNDI_NAME,cache,ModelKeys.JNDI_NAME);
        if (cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME).isDefined()) {
          writer.writeStartElement(Element.LOCKING.getLocalName());
          ModelNode locking=cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);
          this.writeOptional(writer,Attribute.ISOLATION,locking,ModelKeys.ISOLATION);
          this.writeOptional(writer,Attribute.STRIPING,locking,ModelKeys.STRIPING);
          this.writeOptional(writer,Attribute.ACQUIRE_TIMEOUT,locking,ModelKeys.ACQUIRE_TIMEOUT);
          this.writeOptional(writer,Attribute.CONCURRENCY_LEVEL,locking,ModelKeys.CONCURRENCY_LEVEL);
          writer.writeEndElement();
        }
        if (cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME).isDefined()) {
          writer.writeStartElement(Element.TRANSACTION.getLocalName());
          ModelNode transaction=cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME);
          this.writeOptional(writer,Attribute.STOP_TIMEOUT,transaction,ModelKeys.STOP_TIMEOUT);
          this.writeOptional(writer,Attribute.MODE,transaction,ModelKeys.MODE);
          this.writeOptional(writer,Attribute.LOCKING,transaction,ModelKeys.LOCKING);
          writer.writeEndElement();
        }
        if (cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME).isDefined()) {
          writer.writeStartElement(Element.EVICTION.getLocalName());
          ModelNode eviction=cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME);
          this.writeOptional(writer,Attribute.STRATEGY,eviction,ModelKeys.STRATEGY);
          this.writeOptional(writer,Attribute.MAX_ENTRIES,eviction,ModelKeys.MAX_ENTRIES);
          writer.writeEndElement();
        }
        if (cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME).isDefined()) {
          writer.writeStartElement(Element.EXPIRATION.getLocalName());
          ModelNode expiration=cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME);
          this.writeOptional(writer,Attribute.MAX_IDLE,expiration,ModelKeys.MAX_IDLE);
          this.writeOptional(writer,Attribute.LIFESPAN,expiration,ModelKeys.LIFESPAN);
          this.writeOptional(writer,Attribute.INTERVAL,expiration,ModelKeys.INTERVAL);
          writer.writeEndElement();
        }
        if (cache.get(ModelKeys.STATE_TRANSFER,ModelKeys.STATE_TRANSFER_NAME).isDefined()) {
          ModelNode stateTransfer=cache.get(ModelKeys.STATE_TRANSFER,ModelKeys.STATE_TRANSFER_NAME);
          writer.writeStartElement(Element.STATE_TRANSFER.getLocalName());
          this.writeOptional(writer,Attribute.ENABLED,stateTransfer,ModelKeys.ENABLED);
          this.writeOptional(writer,Attribute.TIMEOUT,stateTransfer,ModelKeys.TIMEOUT);
          this.writeOptional(writer,Attribute.CHUNK_SIZE,stateTransfer,ModelKeys.CHUNK_SIZE);
          writer.writeEndElement();
        }
        if (cache.get(ModelKeys.STORE,ModelKeys.STORE_NAME).isDefined()) {
          ModelNode store=cache.get(ModelKeys.STORE,ModelKeys.STORE_NAME);
          writer.writeStartElement(Element.STORE.getLocalName());
          this.writeRequired(writer,Attribute.CLASS,store,ModelKeys.CLASS);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
 else         if (cache.get(ModelKeys.FILE_STORE,ModelKeys.FILE_STORE_NAME).isDefined()) {
          ModelNode store=cache.get(ModelKeys.FILE_STORE,ModelKeys.FILE_STORE_NAME);
          writer.writeStartElement(Element.FILE_STORE.getLocalName());
          this.writeOptional(writer,Attribute.RELATIVE_TO,store,ModelKeys.RELATIVE_TO);
          this.writeOptional(writer,Attribute.PATH,store,ModelKeys.PATH);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
 else         if (cache.get(ModelKeys.JDBC_STORE,ModelKeys.JDBC_STORE_NAME).isDefined()) {
          ModelNode store=cache.get(ModelKeys.JDBC_STORE,ModelKeys.JDBC_STORE_NAME);
          writer.writeStartElement(Element.JDBC_STORE.getLocalName());
          this.writeRequired(writer,Attribute.DATASOURCE,store,ModelKeys.DATASOURCE);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          this.writeJDBCStoreTable(writer,Element.BUCKET_TABLE,store,ModelKeys.BUCKET_TABLE);
          this.writeJDBCStoreTable(writer,Element.ENTRY_TABLE,store,ModelKeys.ENTRY_TABLE);
          writer.writeEndElement();
        }
 else         if (cache.get(ModelKeys.REMOTE_STORE,ModelKeys.REMOTE_STORE_NAME).isDefined()) {
          ModelNode store=cache.get(ModelKeys.REMOTE_STORE,ModelKeys.REMOTE_STORE_NAME);
          writer.writeStartElement(Element.REMOTE_STORE.getLocalName());
          this.writeOptional(writer,Attribute.CACHE,store,ModelKeys.CACHE);
          this.writeOptional(writer,Attribute.SOCKET_TIMEOUT,store,ModelKeys.SOCKET_TIMEOUT);
          this.writeOptional(writer,Attribute.TCP_NO_DELAY,store,ModelKeys.TCP_NO_DELAY);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          for (          ModelNode remoteServer : store.get(ModelKeys.REMOTE_SERVERS).asList()) {
            writer.writeStartElement(Element.REMOTE_SERVER.getLocalName());
            writer.writeAttribute(Attribute.OUTBOUND_SOCKET_BINDING.getLocalName(),remoteServer.get(ModelKeys.OUTBOUND_SOCKET_BINDING).asString());
            writer.writeEndElement();
          }
          writer.writeEndElement();
        }
        writer.writeEndElement();
      }
      writer.writeEndElement();
    }
  }
  writer.writeEndElement();
}
