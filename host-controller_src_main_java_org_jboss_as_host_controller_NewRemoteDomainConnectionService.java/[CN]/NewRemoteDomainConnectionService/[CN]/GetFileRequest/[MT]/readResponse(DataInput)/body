{
  final File localPath;
switch (rootId) {
case NewDomainControllerProtocol.PARAM_ROOT_ID_FILE:
{
      localPath=localFileRepository.getFile(filePath);
      break;
    }
case NewDomainControllerProtocol.PARAM_ROOT_ID_CONFIGURATION:
{
    localPath=localFileRepository.getConfigurationFile(filePath);
    break;
  }
case NewDomainControllerProtocol.PARAM_ROOT_ID_DEPLOYMENT:
{
  byte[] hash=HashUtil.hexStringToByteArray(filePath);
  localPath=localFileRepository.getDeploymentRoot(hash);
  break;
}
default :
{
localPath=null;
}
}
expectHeader(input,NewDomainControllerProtocol.PARAM_NUM_FILES);
int numFiles=input.readInt();
log.debugf("Received %d files for %s",numFiles,localPath);
switch (numFiles) {
case -1:
{
break;
}
case 0:
{
if (!localPath.mkdirs()) {
throw new IOException("Unable to create local directory: " + localPath);
}
break;
}
default :
{
for (int i=0; i < numFiles; i++) {
expectHeader(input,NewDomainControllerProtocol.FILE_START);
expectHeader(input,NewDomainControllerProtocol.PARAM_FILE_PATH);
final String path=input.readUTF();
expectHeader(input,NewDomainControllerProtocol.PARAM_FILE_SIZE);
final long length=input.readLong();
log.debugf("Received file [%s] of length %d",path,length);
final File file=new File(localPath,path);
if (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) {
throw new IOException("Unable to create local directory " + localPath.getParent());
}
long totalRead=0;
OutputStream fileOut=null;
try {
fileOut=new BufferedOutputStream(new FileOutputStream(file));
final byte[] buffer=new byte[8192];
while (totalRead < length) {
int len=Math.min((int)(length - totalRead),buffer.length);
input.readFully(buffer,0,len);
fileOut.write(buffer,0,len);
totalRead+=len;
}
}
  finally {
if (fileOut != null) {
fileOut.close();
}
}
if (totalRead != length) {
throw new IOException("Did not read the entire file. Missing: " + (length - totalRead));
}
expectHeader(input,NewDomainControllerProtocol.FILE_END);
}
}
}
return localPath;
}
