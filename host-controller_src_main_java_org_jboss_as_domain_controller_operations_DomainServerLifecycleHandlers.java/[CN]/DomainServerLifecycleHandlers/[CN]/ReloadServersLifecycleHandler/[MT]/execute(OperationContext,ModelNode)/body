{
  context.acquireControllerLock();
  context.readResource(PathAddress.EMPTY_ADDRESS,false);
  final ModelNode model=Resource.Tools.readModel(context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS,true));
  final String group=getServerGroupName(operation);
  final boolean blocking=operation.get(BLOCKING).asBoolean(false);
  context.addStep(new OperationStepHandler(){
    @Override public void execute(    OperationContext context,    ModelNode operation) throws OperationFailedException {
      context.getServiceRegistry(true);
      Map<String,ProcessInfo> processes=serverInventory.determineRunningProcesses(true);
      final Set<String> serversInGroup=getServersForGroup(model,group);
      final Set<String> waitForServers=new HashSet<String>();
      for (      String serverName : processes.keySet()) {
        final String serverModelName=serverInventory.getProcessServerName(serverName);
        if (group == null || serversInGroup.contains(serverModelName)) {
          serverInventory.reloadServer(serverModelName,false);
          waitForServers.add(serverModelName);
        }
      }
      if (blocking) {
        serverInventory.awaitServersState(waitForServers,true);
      }
      context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
    }
  }
,Stage.RUNTIME);
  context.stepCompleted();
}
