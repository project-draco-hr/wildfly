def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, use_decimal=False, **kw):
    "Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n    document) to a Python object.\n\n    *encoding* determines the encoding used to interpret any\n    :class:`str` objects decoded by this instance (``'utf-8'`` by\n    default).  It has no effect when decoding :class:`unicode` objects.\n\n    Note that currently only encodings that are a superset of ASCII work,\n    strings of other encodings should be passed in as :class:`unicode`.\n\n    *object_hook*, if specified, will be called with the result of every\n    JSON object decoded and its return value will be used in place of the\n    given :class:`dict`.  This can be used to provide custom\n    deserializations (e.g. to support JSON-RPC class hinting).\n\n    *object_pairs_hook* is an optional function that will be called with\n    the result of any object literal decode with an ordered list of pairs.\n    The return value of *object_pairs_hook* will be used instead of the\n    :class:`dict`.  This feature can be used to implement custom decoders\n    that rely on the order that the key and value pairs are decoded (for\n    example, :func:`collections.OrderedDict` will remember the order of\n    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n    takes priority.\n\n    *parse_float*, if specified, will be called with the string of every\n    JSON float to be decoded.  By default, this is equivalent to\n    ``float(num_str)``. This can be used to use another datatype or parser\n    for JSON floats (e.g. :class:`decimal.Decimal`).\n\n    *parse_int*, if specified, will be called with the string of every\n    JSON int to be decoded.  By default, this is equivalent to\n    ``int(num_str)``.  This can be used to use another datatype or parser\n    for JSON integers (e.g. :class:`float`).\n\n    *parse_constant*, if specified, will be called with one of the\n    following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n    can be used to raise an exception if invalid JSON numbers are\n    encountered.\n\n    If *use_decimal* is true (default: ``False``) then it implies\n    parse_float=decimal.Decimal for parity with ``dump``.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg.\n\n    "
    if ((cls is None) and (encoding is None) and (object_hook is None) and (parse_int is None) and (parse_float is None) and (parse_constant is None) and (object_pairs_hook is None) and (not use_decimal) and (not kw)):
        return _default_decoder.decode(s)
    if (cls is None):
        cls = JSONDecoder
    if (object_hook is not None):
        kw['object_hook'] = object_hook
    if (object_pairs_hook is not None):
        kw['object_pairs_hook'] = object_pairs_hook
    if (parse_float is not None):
        kw['parse_float'] = parse_float
    if (parse_int is not None):
        kw['parse_int'] = parse_int
    if (parse_constant is not None):
        kw['parse_constant'] = parse_constant
    if use_decimal:
        if (parse_float is not None):
            raise TypeError('use_decimal=True implies parse_float=Decimal')
        kw['parse_float'] = Decimal
    return cls(encoding=encoding, **kw).decode(s)
