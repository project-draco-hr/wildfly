def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, **kw):
    "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n    will be skipped instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the some chunks written to ``fp``\n    may be ``unicode`` instances, subject to normal Python ``str`` to\n    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly\n    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely\n    to cause an error.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If *indent* is a string, then JSON array elements and object members\n    will be pretty-printed with a newline followed by that string repeated\n    for each level of nesting. ``None`` (the default) selects the most compact\n    representation without any newlines. For backwards compatibility with\n    versions of simplejson earlier than 2.1.0, an integer is also accepted\n    and is converted to a string with that many spaces.\n\n    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n    then it will be used instead of the default ``(', ', ': ')`` separators.\n    ``(',', ':')`` is the most compact JSON representation.\n\n    ``encoding`` is the character encoding for str instances, default is UTF-8.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *use_decimal* is true (default: ``True``) then decimal.Decimal\n    will be natively serialized to JSON with full precision.\n\n    If *namedtuple_as_object* is true (default: ``True``),\n    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded\n    as JSON objects.\n    \n    If *tuple_as_array* is true (default: ``True``),\n    :class:`tuple` (and subclasses) will be encoded as JSON arrays.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg.\n\n    "
    if ((not skipkeys) and ensure_ascii and check_circular and allow_nan and (cls is None) and (indent is None) and (separators is None) and (encoding == 'utf-8') and (default is None) and use_decimal and namedtuple_as_object and tuple_as_array and (not kw)):
        iterable = _default_encoder.iterencode(obj)
    else:
        if (cls is None):
            cls = JSONEncoder
        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, use_decimal=use_decimal, namedtuple_as_object=namedtuple_as_object, tuple_as_array=tuple_as_array, **kw).iterencode(obj)
    for chunk in iterable:
        fp.write(chunk)
