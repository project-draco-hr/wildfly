{
  return new AbstractEJBInterceptor(){
    @Override public Object processInvocation(    final InterceptorContext context) throws Exception {
      final EntityBeanComponent component=getComponent(context,EntityBeanComponent.class);
      final Object primaryKey=context.getPrivateData(EntityBeanComponent.PRIMARY_KEY_CONTEXT_KEY);
      if (primaryKey == null) {
        throw MESSAGES.primaryKeyIsNull();
      }
      final EntityBeanComponentInstance instance=component.getCache().get(primaryKey);
      if (instance.isRemoved()) {
        throw MESSAGES.instaceWasRemoved(component.getComponentName(),primaryKey);
      }
      try {
        context.putPrivateData(ComponentInstance.class,instance);
        return context.proceed();
      }
 catch (      Exception ex) {
        if (component.getApplicationException(ex.getClass(),context.getMethod()) != null) {
          throw ex;
        }
        if (ex instanceof ConcurrentAccessTimeoutException || ex instanceof ConcurrentAccessException) {
          throw ex;
        }
        if (ex instanceof RuntimeException || ex instanceof RemoteException) {
          if (ROOT_LOGGER.isTraceEnabled())           ROOT_LOGGER.trace("Discarding bean " + primaryKey + " because of exception",ex);
          component.getCache().discard(instance);
        }
        throw ex;
      }
catch (      final Error e) {
        if (ROOT_LOGGER.isTraceEnabled())         ROOT_LOGGER.trace("Discarding bean " + primaryKey + " because of error",e);
        component.getCache().discard(instance);
        throw e;
      }
catch (      final Throwable t) {
        if (ROOT_LOGGER.isTraceEnabled())         ROOT_LOGGER.trace("Discarding bean " + primaryKey + " because of Throwable",t);
        component.getCache().discard(instance);
        throw new RuntimeException(t);
      }
 finally {
        context.putPrivateData(ComponentInstance.class,null);
      }
    }
  }
;
}
