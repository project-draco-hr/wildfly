{
  final PathAddress address=getCacheContainerAddressFromOperation(operation);
  final String name=address.getLastElement().getValue();
  if (context.getProcessType().isServer() && !context.isBooting() && name.equals("ejb")) {
    Resource rootResource=context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS);
    PathElement ejbPath=PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM,"ejb3");
    if (rootResource.hasChild(ejbPath) && rootResource.getChild(ejbPath).hasChild(PathElement.pathElement("service","remote"))) {
      context.addStep(new OperationStepHandler(){
        @Override public void execute(        final OperationContext context,        final ModelNode operation) throws OperationFailedException {
          context.reloadRequired();
          context.completeStep(OperationContext.RollbackHandler.REVERT_RELOAD_REQUIRED_ROLLBACK_HANDLER);
        }
      }
,OperationContext.Stage.RUNTIME);
      return Collections.emptyList();
    }
  }
  final ServiceTarget target=context.getServiceTarget();
  ModelNode resolvedValue=null;
  final String defaultCache=(resolvedValue=CacheContainerResourceDefinition.DEFAULT_CACHE.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String jndiName=(resolvedValue=CacheContainerResourceDefinition.JNDI_NAME.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String listenerExecutor=(resolvedValue=CacheContainerResourceDefinition.LISTENER_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String evictionExecutor=(resolvedValue=CacheContainerResourceDefinition.EVICTION_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final String replicationQueueExecutor=(resolvedValue=CacheContainerResourceDefinition.REPLICATION_QUEUE_EXECUTOR.resolveModelAttribute(context,containerModel)).isDefined() ? resolvedValue.asString() : null;
  final ServiceController.Mode initialMode=StartMode.valueOf(CacheContainerResourceDefinition.START.resolveModelAttribute(context,containerModel).asString()).getMode();
  final boolean statistics=CacheContainerResourceDefinition.STATISTICS_ENABLED.resolveModelAttribute(context,containerModel).asBoolean();
  ServiceName[] aliases=null;
  if (containerModel.hasDefined(ModelKeys.ALIASES)) {
    List<ModelNode> list=operation.get(ModelKeys.ALIASES).asList();
    aliases=new ServiceName[list.size()];
    for (int i=0; i < list.size(); i++) {
      aliases[i]=EmbeddedCacheManagerService.getServiceName(list.get(i).asString());
    }
  }
  final ModuleIdentifier moduleId=(resolvedValue=CacheContainerResourceDefinition.MODULE.resolveModelAttribute(context,containerModel)).isDefined() ? ModuleIdentifier.fromString(resolvedValue.asString()) : null;
  final Transport transportConfig=containerModel.hasDefined(ModelKeys.TRANSPORT) && containerModel.get(ModelKeys.TRANSPORT).hasDefined(ModelKeys.TRANSPORT_NAME) ? new Transport() : null;
  String stack=null;
  String transportExecutor=null;
  Collection<ServiceController<?>> controllers=new LinkedList<>();
  boolean clustered=(transportConfig != null);
  if (clustered) {
    ModelNode transport=containerModel.get(ModelKeys.TRANSPORT,ModelKeys.TRANSPORT_NAME);
    if ((resolvedValue=TransportResourceDefinition.STACK.resolveModelAttribute(context,transport)).isDefined()) {
      stack=resolvedValue.asString();
    }
    String clusterName=name;
    if ((resolvedValue=TransportResourceDefinition.CLUSTER.resolveModelAttribute(context,transport)).isDefined()) {
      clusterName=resolvedValue.asString();
    }
    long lockTimeout=TransportResourceDefinition.LOCK_TIMEOUT.resolveModelAttribute(context,transport).asLong();
    if ((resolvedValue=TransportResourceDefinition.EXECUTOR.resolveModelAttribute(context,transport)).isDefined()) {
      transportExecutor=resolvedValue.asString();
    }
    transportConfig.setClusterName(clusterName);
    transportConfig.setLockTimeout(lockTimeout);
    controllers.addAll(this.installChannelServices(target,name,stack,verificationHandler));
    ChannelInstanceResourceDefinition.addChannelProtocolMetricsRegistrationStep(context,clusterName,stack);
    install(target,ClusterServiceInstaller.class,name,moduleId);
  }
 else {
    install(target,LocalServiceInstaller.class,name,moduleId);
  }
  controllers.add(this.installContainerConfigurationService(target,name,defaultCache,statistics,moduleId,stack,transportConfig,transportExecutor,listenerExecutor,evictionExecutor,replicationQueueExecutor,verificationHandler));
  controllers.add(this.installContainerService(target,name,aliases,transportConfig,initialMode,verificationHandler));
  controllers.add(this.installJndiService(target,name,jndiName,verificationHandler));
  controllers.add(this.installKeyAffinityServiceFactoryService(target,name,verificationHandler));
  controllers.add(this.installGlobalComponentRegistryService(target,name,transportConfig,verificationHandler));
  log.debugf("%s cache container installed",name);
  return controllers;
}
