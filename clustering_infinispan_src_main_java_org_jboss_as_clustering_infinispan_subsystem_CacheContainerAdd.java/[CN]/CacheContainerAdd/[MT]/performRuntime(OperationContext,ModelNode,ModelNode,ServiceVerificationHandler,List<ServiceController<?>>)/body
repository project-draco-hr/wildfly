{
  model=Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));
  final PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  final String name=address.getLastElement().getValue();
  ModelNode resolvedValue=null;
  final String defaultCache=((resolvedValue=CommonAttributes.DEFAULT_CACHE.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  final String startMode=((resolvedValue=CommonAttributes.START.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  final String jndiNameString=((resolvedValue=CommonAttributes.JNDI_NAME.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  final String listenerExecutor=((resolvedValue=CommonAttributes.LISTENER_EXECUTOR.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  final String evictionExecutor=((resolvedValue=CommonAttributes.EVICTION_EXECUTOR.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  final String replicationQueueExecutor=((resolvedValue=CommonAttributes.REPLICATION_QUEUE_EXECUTOR.resolveModelAttribute(context,model)).isDefined()) ? resolvedValue.asString() : null;
  boolean hasTransport=model.hasDefined(ModelKeys.TRANSPORT) && model.get(ModelKeys.TRANSPORT).hasDefined(ModelKeys.TRANSPORT_NAME);
  Transport transportConfig=hasTransport ? new Transport() : null;
  EmbeddedCacheManagerDependencies dependencies=new EmbeddedCacheManagerDependencies(transportConfig);
  ServiceName[] aliases=null;
  if (model.hasDefined(ModelKeys.ALIASES)) {
    List<ModelNode> list=operation.get(ModelKeys.ALIASES).asList();
    aliases=new ServiceName[list.size()];
    for (int i=0; i < list.size(); i++) {
      aliases[i]=EmbeddedCacheManagerService.getServiceName(list.get(i).asString());
    }
  }
  ServiceTarget target=context.getServiceTarget();
  ServiceName configServiceName=EmbeddedCacheManagerConfigurationService.getServiceName(name);
  ServiceBuilder<EmbeddedCacheManagerConfiguration> configBuilder=target.addService(configServiceName,new EmbeddedCacheManagerConfigurationService(name,defaultCache,dependencies)).addDependency(Services.JBOSS_SERVICE_MODULE_LOADER,ModuleLoader.class,dependencies.getModuleLoaderInjector()).addDependency(MBeanServerService.SERVICE_NAME,MBeanServer.class,dependencies.getMBeanServerInjector()).addDependency(DependencyType.OPTIONAL,EmbeddedCacheManagerConfigurationService.getClassLoaderServiceName(name),ClassLoader.class,dependencies.getClassLoaderInjector()).setInitialMode(ServiceController.Mode.ON_DEMAND);
  ServiceController.Mode initialMode=(startMode != null) ? StartMode.valueOf(startMode).getMode() : ServiceController.Mode.ON_DEMAND;
  ServiceName containerServiceName=EmbeddedCacheManagerService.getServiceName(name);
  InjectedValue<EmbeddedCacheManagerConfiguration> config=new InjectedValue<EmbeddedCacheManagerConfiguration>();
  ServiceBuilder<EmbeddedCacheManager> containerBuilder=target.addService(containerServiceName,new EmbeddedCacheManagerService(config)).addDependency(configServiceName,EmbeddedCacheManagerConfiguration.class,config).addAliases(aliases).setInitialMode(initialMode);
  newControllers.add(containerBuilder.install());
  String jndiName=(jndiNameString != null ? InfinispanJndiName.toJndiName(jndiNameString) : InfinispanJndiName.defaultCacheContainerJndiName(name)).getAbsoluteName();
  ContextNames.BindInfo bindInfo=ContextNames.bindInfoFor(jndiName);
  BinderService binder=new BinderService(bindInfo.getBindName());
  ServiceBuilder<ManagedReferenceFactory> binderBuilder=target.addService(bindInfo.getBinderServiceName(),binder).addAliases(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(jndiName)).addDependency(containerServiceName,CacheContainer.class,new ManagedReferenceInjector<CacheContainer>(binder.getManagedObjectInjector())).addDependency(bindInfo.getParentContextServiceName(),ServiceBasedNamingStore.class,binder.getNamingStoreInjector()).setInitialMode(ServiceController.Mode.PASSIVE);
  newControllers.add(binderBuilder.install());
  if (hasTransport) {
    ModelNode transport=model.get(ModelKeys.TRANSPORT,ModelKeys.TRANSPORT_NAME);
    final String stack=((resolvedValue=CommonAttributes.STACK.resolveModelAttribute(context,transport)).isDefined()) ? resolvedValue.asString() : null;
    final String cluster=((resolvedValue=CommonAttributes.CLUSTER.resolveModelAttribute(context,transport)).isDefined()) ? resolvedValue.asString() : name;
    final long lockTimeout=CommonAttributes.LOCK_TIMEOUT.resolveModelAttribute(context,transport).asLong();
    final String executor=((resolvedValue=CommonAttributes.EXECUTOR.resolveModelAttribute(context,transport)).isDefined()) ? resolvedValue.asString() : null;
    transportConfig.setLockTimeout(lockTimeout);
    addExecutorDependency(configBuilder,executor,transportConfig.getExecutorInjector());
    ServiceName channelServiceName=ChannelService.getServiceName(name);
    configBuilder.addDependency(channelServiceName,Channel.class,transportConfig.getChannelInjector());
    InjectedValue<ChannelFactory> channelFactory=new InjectedValue<ChannelFactory>();
    ServiceBuilder<Channel> channelBuilder=target.addService(channelServiceName,new ChannelService(cluster,channelFactory)).addDependency(ChannelFactoryService.getServiceName(stack),ChannelFactory.class,channelFactory).setInitialMode(ServiceController.Mode.ON_DEMAND);
    newControllers.add(channelBuilder.install());
  }
  addExecutorDependency(configBuilder,listenerExecutor,dependencies.getListenerExecutorInjector());
  addScheduledExecutorDependency(configBuilder,evictionExecutor,dependencies.getEvictionExecutorInjector());
  addScheduledExecutorDependency(configBuilder,replicationQueueExecutor,dependencies.getReplicationQueueExecutorInjector());
  newControllers.add(configBuilder.install());
  log.debugf("%s cache container installed",name);
}
