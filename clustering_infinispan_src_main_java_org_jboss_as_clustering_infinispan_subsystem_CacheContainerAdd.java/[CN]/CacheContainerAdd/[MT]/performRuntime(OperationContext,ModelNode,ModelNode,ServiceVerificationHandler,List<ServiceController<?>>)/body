{
  model=Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));
  final PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  final String name=address.getLastElement().getValue();
  String defaultCache=model.require(ModelKeys.DEFAULT_CACHE).asString();
  boolean hasTransport=model.hasDefined(ModelKeys.SINGLETON) && model.get(ModelKeys.SINGLETON).hasDefined(ModelKeys.TRANSPORT);
  Transport transportConfig=hasTransport ? new Transport() : null;
  EmbeddedCacheManagerDependencies dependencies=new EmbeddedCacheManagerDependencies(transportConfig);
  ServiceName[] aliases=null;
  if (model.hasDefined(ModelKeys.ALIASES)) {
    List<ModelNode> list=operation.get(ModelKeys.ALIASES).asList();
    aliases=new ServiceName[list.size()];
    for (int i=0; i < list.size(); i++) {
      aliases[i]=EmbeddedCacheManagerService.getServiceName(list.get(i).asString());
    }
  }
  ServiceTarget target=context.getServiceTarget();
  ServiceName serviceName=EmbeddedCacheManagerService.getServiceName(name);
  ServiceBuilder<EmbeddedCacheManager> containerBuilder=target.addService(serviceName,new EmbeddedCacheManagerService(name,defaultCache,dependencies)).addDependency(DependencyType.OPTIONAL,ServiceName.JBOSS.append("mbean","server"),MBeanServer.class,dependencies.getMBeanServerInjector()).addAliases(aliases).setInitialMode(ServiceController.Mode.ON_DEMAND);
  String jndiName=(model.hasDefined(ModelKeys.JNDI_NAME) ? InfinispanJndiName.toJndiName(model.get(ModelKeys.JNDI_NAME).asString()) : InfinispanJndiName.defaultCacheContainerJndiName(name)).getAbsoluteName();
  ContextNames.BindInfo bindInfo=ContextNames.bindInfoFor(jndiName);
  BinderService binder=new BinderService(bindInfo.getBindName());
  ServiceBuilder<ManagedReferenceFactory> binderBuilder=target.addService(bindInfo.getBinderServiceName(),binder).addAliases(ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(jndiName)).addDependency(serviceName,CacheContainer.class,new ManagedReferenceInjector<CacheContainer>(binder.getManagedObjectInjector())).addDependency(bindInfo.getParentContextServiceName(),ServiceBasedNamingStore.class,binder.getNamingStoreInjector()).setInitialMode(ServiceController.Mode.ON_DEMAND);
  newControllers.add(binderBuilder.install());
  if (hasTransport) {
    String stack=null;
    ModelNode transport=model.get(ModelKeys.SINGLETON,ModelKeys.TRANSPORT);
    if (transport.hasDefined(ModelKeys.STACK)) {
      stack=transport.get(ModelKeys.STACK).asString();
    }
    if (transport.hasDefined(ModelKeys.LOCK_TIMEOUT)) {
      transportConfig.setLockTimeout(transport.get(ModelKeys.LOCK_TIMEOUT).asLong());
    }
    addExecutorDependency(containerBuilder,transport,ModelKeys.EXECUTOR,transportConfig.getExecutorInjector());
    ServiceName channelServiceName=ChannelService.getServiceName(name);
    containerBuilder.addDependency(channelServiceName,Channel.class,transportConfig.getChannelInjector());
    InjectedValue<ChannelFactory> channelFactory=new InjectedValue<ChannelFactory>();
    ServiceBuilder<Channel> channelBuilder=target.addService(channelServiceName,new ChannelService(name,channelFactory)).addDependency(ChannelFactoryService.getServiceName(stack),ChannelFactory.class,channelFactory).setInitialMode(ServiceController.Mode.ON_DEMAND);
    newControllers.add(channelBuilder.install());
  }
  addExecutorDependency(containerBuilder,model,ModelKeys.LISTENER_EXECUTOR,dependencies.getListenerExecutorInjector());
  addScheduledExecutorDependency(containerBuilder,model,ModelKeys.EVICTION_EXECUTOR,dependencies.getEvictionExecutorInjector());
  addScheduledExecutorDependency(containerBuilder,model,ModelKeys.REPLICATION_QUEUE_EXECUTOR,dependencies.getReplicationQueueExecutorInjector());
  newControllers.add(containerBuilder.install());
  log.debugf("%s cache container installed",name);
}
