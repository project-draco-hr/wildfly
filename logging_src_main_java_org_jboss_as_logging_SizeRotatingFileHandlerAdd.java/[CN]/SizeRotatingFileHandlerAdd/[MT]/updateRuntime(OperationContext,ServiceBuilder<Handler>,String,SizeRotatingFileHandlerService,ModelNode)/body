{
  super.updateRuntime(context,serviceBuilder,name,service,model);
  final ModelNode append=APPEND.resolveModelAttribute(context,model);
  if (append.isDefined()) {
    service.setAppend(append.asBoolean());
  }
  final ModelNode file=FILE.resolveModelAttribute(context,model);
  if (file.isDefined()) {
    final HandlerFileService fileService=new HandlerFileService(PATH.resolveModelAttribute(context,file).asString());
    final ServiceBuilder<?> fileBuilder=context.getServiceTarget().addService(LogServices.handlerFileName(name),fileService);
    final ModelNode relativeTo=RELATIVE_TO.resolveModelAttribute(context,file);
    if (relativeTo.isDefined()) {
      fileBuilder.addDependency(AbstractPathService.pathNameOf(relativeTo.asString()),String.class,fileService.getRelativeToInjector());
    }
    fileBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();
    serviceBuilder.addDependency(LogServices.handlerFileName(name),String.class,service.getFileNameInjector());
  }
  final ModelNode maxBackupIndex=MAX_BACKUP_INDEX.resolveModelAttribute(context,model);
  if (maxBackupIndex.isDefined()) {
    service.setMaxBackupIndex(maxBackupIndex.asInt());
  }
  final ModelNode rotateSizeNode=ROTATE_SIZE.resolveModelAttribute(context,model);
  long rotateSize=ROTATE_SIZE.getDefaultValue().asLong();
  if (rotateSizeNode.isDefined()) {
    try {
      rotateSize=LoggingSubsystemParser.parseSize(rotateSizeNode.asString());
    }
 catch (    Throwable t) {
      throw new OperationFailedException(new ModelNode().set(t.getLocalizedMessage()));
    }
  }
  service.setRotateSize(rotateSize);
}
