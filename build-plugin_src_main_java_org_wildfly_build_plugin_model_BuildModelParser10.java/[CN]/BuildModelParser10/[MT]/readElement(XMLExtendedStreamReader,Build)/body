{
  boolean extractSchema=true;
  boolean copyModuleArtifacts=true;
  final Set<Attribute> required=EnumSet.noneOf(Attribute.class);
  final int count=reader.getAttributeCount();
  for (int i=0; i < count; i++) {
    final Attribute attribute=Attribute.of(reader.getAttributeName(i));
    required.remove(attribute);
switch (attribute) {
case EXTRACT_SCHEMA:
      extractSchema=Boolean.parseBoolean(propertyReplacer.replaceProperties(reader.getAttributeValue(i)));
    break;
case COPY_MODULE_ARTIFACTS:
  copyModuleArtifacts=Boolean.parseBoolean(propertyReplacer.replaceProperties(reader.getAttributeValue(i)));
break;
default :
throw unexpectedContent(reader);
}
}
if (!required.isEmpty()) {
throw missingAttributes(reader.getLocation(),required);
}
result.setExtractSchema(extractSchema);
result.setCopyModuleArtifacts(copyModuleArtifacts);
while (reader.hasNext()) {
switch (reader.nextTag()) {
case XMLStreamConstants.END_ELEMENT:
{
return;
}
case XMLStreamConstants.START_ELEMENT:
{
final Element element=Element.of(reader.getName());
switch (element) {
case SERVERS:
parseServers(reader,result);
break;
case ARTIFACTS:
parseArtifacts(reader,result);
break;
case CONFIG:
parseConfig(reader,result);
break;
case FILE_PERMISSIONS:
parseFilePermissions(reader,result);
break;
case MKDIRS:
parseMkdirs(reader,result);
break;
case LINE_ENDINGS:
parseLineEndings(reader,result);
break;
default :
throw unexpectedContent(reader);
}
break;
}
default :
{
throw unexpectedContent(reader);
}
}
}
throw endOfDocument(reader.getLocation());
}
