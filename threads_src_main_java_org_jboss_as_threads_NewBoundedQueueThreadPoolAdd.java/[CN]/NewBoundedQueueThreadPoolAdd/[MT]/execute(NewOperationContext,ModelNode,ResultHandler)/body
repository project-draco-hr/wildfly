{
  BoundedOperationParameters params=NewThreadsSubsystemThreadPoolOperationUtils.parseBoundedThreadPoolOperationParameters(operation);
  if (context instanceof NewRuntimeOperationContext) {
    ServiceTarget target=((NewRuntimeOperationContext)context).getServiceTarget();
    final ServiceName serviceName=ThreadsServices.executorName(params.getName());
    final BoundedQueueThreadPoolService service=new BoundedQueueThreadPoolService(params.getCoreThreads().getScaledCount(),params.getMaxThreads().getScaledCount(),params.getQueueLength().getScaledCount(),params.isBlocking(),params.getKeepAliveTime(),params.isAllowCoreTimeout());
    final ServiceBuilder<Executor> serviceBuilder=target.addService(serviceName,service);
    NewThreadsSubsystemThreadPoolOperationUtils.addThreadFactoryDependency(params.getThreadFactory(),serviceName,serviceBuilder,service.getThreadFactoryInjector(),target);
    serviceBuilder.install();
  }
  final ModelNode model=context.getSubModel();
  model.get(NAME).set(params.getName());
  if (params.getThreadFactory() != null) {
    model.get(THREAD_FACTORY).set(params.getThreadFactory());
  }
  if (params.getProperties() != null && params.getProperties().asList().size() > 0) {
    model.get(PROPERTIES).set(params.getProperties());
  }
  if (params.getMaxThreads() != null) {
    model.get(MAX_THREADS_COUNT).set(params.getMaxThreads().getCount());
    model.get(MAX_THREADS_PER_CPU).set(params.getMaxThreads().getPerCpu());
  }
  if (params.getKeepAliveTime() != null) {
    model.get(KEEPALIVE_TIME_DURATION).set(params.getKeepAliveTime().getDuration());
    model.get(KEEPALIVE_TIME_UNIT).set(params.getKeepAliveTime().getUnit().toString());
  }
  model.get(BLOCKING).set(params.isBlocking());
  if (params.getHandoffExecutor() != null) {
    model.get(HANDOFF_EXECUTOR).set(params.getHandoffExecutor());
  }
  model.get(ALLOW_CORE_TIMEOUT).set(params.isAllowCoreTimeout());
  if (params.getQueueLength() != null) {
    model.get(QUEUE_LENGTH_COUNT).set(params.getQueueLength().getCount());
    model.get(QUEUE_LENGTH_PER_CPU).set(params.getQueueLength().getPerCpu());
  }
  if (params.getCoreThreads() != null) {
    model.get(CORE_THREADS_COUNT).set(params.getCoreThreads().getCount());
    model.get(CORE_THREADS_PER_CPU).set(params.getCoreThreads().getPerCpu());
  }
  final ModelNode compensating=new ModelNode();
  compensating.get(ADDRESS).set(operation.require(ADDRESS));
  compensating.get(OPERATION).set(REMOVE);
  resultHandler.handleResultComplete(compensating);
  return Cancellable.NULL;
}
