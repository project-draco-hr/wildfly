{
  final Map<Location,ContentModification> originalModifications=new HashMap<Location,ContentModification>();
  for (  final ContentModification modification : originalPatch) {
    originalModifications.put(new Location(modification.getItem()),modification);
  }
  for (  final ContentModification modification : rollbackPatch) {
    final ContentItem item=modification.getItem();
    if (!filter.accepts(item)) {
      continue;
    }
    final Location location=new Location(item);
    final ContentModification original=originalModifications.remove(location);
    if (original == null) {
      if (modification.getType() != ModificationType.ADD) {
        throw new IllegalStateException(item.toString());
      }
    }
    final ContentEntry contentEntry=new ContentEntry(patchId,modification);
    ContentTaskDefinition definition=modifications.get(location);
    if (definition == null) {
      definition=new ContentTaskDefinition(location,contentEntry);
      modifications.put(location,definition);
    }
 else {
      boolean strict=true;
      if (strict) {
        final ContentEntry previous=definition.getTarget();
        final byte[] hash=previous.getItem().getContentHash();
        if (!Arrays.equals(hash,contentEntry.getTargetHash())) {
          throw new IllegalStateException();
        }
      }
      definition.setTarget(contentEntry);
    }
    if (original == null) {
      continue;
    }
    final byte[] currentContent=modification.getTargetHash();
    final byte[] originalContent=original.getItem().getContentHash();
    if (!Arrays.equals(currentContent,originalContent)) {
      definition.addConflict(contentEntry);
    }
 else {
      final byte[] backupItem=item.getContentHash();
      final byte[] originalTarget=original.getTargetHash();
      if (!Arrays.equals(backupItem,originalTarget)) {
        definition.addConflict(contentEntry);
      }
    }
  }
}
