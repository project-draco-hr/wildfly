{
  final String patchId=patch.getPatchId();
  final List<String> appliesTo=patch.getAppliesTo();
  if (!appliesTo.contains(patchInfo.getVersion())) {
    throw PatchMessages.MESSAGES.doesNotApply(appliesTo,patchInfo.getVersion());
  }
  final File workDir=new File(structure.getHistoryDir(patchId),"work");
  if (workDir.exists()) {
    recursiveDelete(workDir);
  }
  workDir.mkdirs();
  final PatchContentLoader loader=new PatchContentLoader(workDir);
  final PatchingContext context=new PatchingContext(patch,patchInfo,structure,loader);
  final File cachedContent=new File(workDir,"content");
  try {
    FileOutputStream os=null;
    try {
      os=new FileOutputStream(cachedContent);
      PatchUtils.copyStream(content,os);
      os.close();
    }
 catch (    IOException e) {
      throw new PatchingException(e);
    }
 finally {
      PatchUtils.safeClose(os);
    }
    try {
      unpack(cachedContent,workDir);
    }
 catch (    IOException e) {
      throw new PatchingException(e);
    }
    final File modules=new File(workDir,PatchContents.MODULES);
    if (modules.exists()) {
      final File patchDir=structure.getModulePatchDirectory(patchId);
      if (!modules.renameTo(patchDir)) {
        throw new PatchingException("...");
      }
    }
    final List<ContentTask> tasks=new ArrayList<ContentTask>();
    final List<MiscContentItem> problems=new ArrayList<MiscContentItem>();
    for (    final MiscContentModification modification : patch.getModifications()) {
      final ContentTask task=ContentTask.Factory.create(modification,context);
      try {
        if (!task.prepare(context)) {
          final MiscContentItem item=modification.getItem();
          if (context.isIgnored(item)) {
            problems.add(item);
          }
        }
        tasks.add(task);
      }
 catch (      IOException e) {
        throw new PatchingException(e);
      }
    }
    if (!problems.isEmpty()) {
      throw new PatchingException("...");
    }
    final List<MiscContentModification> rollbackTasks=new ArrayList<MiscContentModification>();
    try {
      for (      final ContentTask task : tasks) {
        if (context.isExcluded(task.getContentItem())) {
          continue;
        }
        final MiscContentModification rollback=task.execute(context);
        rollbackTasks.add(rollback);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return context.finish(patch);
  }
  finally {
    cachedContent.delete();
    if (!recursiveDelete(workDir)) {
      PatchLogger.ROOT_LOGGER.debugf("failed to remove work directory (%s)",workDir);
    }
  }
}
