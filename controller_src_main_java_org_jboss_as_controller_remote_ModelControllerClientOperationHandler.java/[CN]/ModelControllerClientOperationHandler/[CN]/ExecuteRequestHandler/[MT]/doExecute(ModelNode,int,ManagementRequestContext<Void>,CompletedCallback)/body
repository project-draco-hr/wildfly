{
  final ModelNode headers=operation.get(OPERATION_HEADERS);
  headers.get(CALLER_TYPE).set(USER);
  if (headers.hasDefined(DOMAIN_UUID)) {
    headers.remove(DOMAIN_UUID);
  }
  if (headers.hasDefined(EXECUTE_FOR_COORDINATOR)) {
    headers.remove(EXECUTE_FOR_COORDINATOR);
  }
  final ManagementRequestHeader header=ManagementRequestHeader.class.cast(context.getRequestHeader());
  final int batchId=header.getBatchId();
  final ModelNode result=new ModelNode();
  final boolean sendPreparedOperation=sendPreparedResponse(operation);
  final ModelController.OperationTransactionControl transactionControl=sendPreparedOperation ? new ModelController.OperationTransactionControl(){
    @Override public void operationPrepared(    ModelController.OperationTransaction transaction,    ModelNode result){
      transaction.commit();
      result.get(OUTCOME).set(SUCCESS);
      result.get(RESULT);
      callback.sendResponse(result);
    }
  }
 : ModelController.OperationTransactionControl.COMMIT;
  final OperationMessageHandlerProxy messageHandlerProxy=new OperationMessageHandlerProxy(channelAssociation,batchId);
  final OperationAttachmentsProxy attachmentsProxy=OperationAttachmentsProxy.create(channelAssociation,batchId,attachmentsLength);
  try {
    ROOT_LOGGER.tracef("Executing client request %d(%d)",batchId,header.getRequestId());
    result.set(controller.execute(operation,messageHandlerProxy,transactionControl,attachmentsProxy));
  }
 catch (  Exception e) {
    final ModelNode failure=new ModelNode();
    failure.get(OUTCOME).set(FAILED);
    failure.get(FAILURE_DESCRIPTION).set(e.getClass().getName() + ":" + e.getMessage());
    result.set(failure);
    attachmentsProxy.shutdown(e);
  }
 finally {
    ROOT_LOGGER.tracef("Executed client request %d",batchId);
  }
  callback.sendResponse(result);
}
