{
  final String patchId=operation.require(PATCH_ID).asString();
  context.acquireControllerLock();
  final ServiceController<?> mgrService=context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME);
  final InstallationManager mgr=(InstallationManager)mgrService.getValue();
  final PatchableTarget.TargetInfo info;
  try {
    info=mgr.getIdentity().loadTargetInfo();
  }
 catch (  IOException e) {
    throw new OperationFailedException("failed to load identity info",e);
  }
  if (info.getCumulativeID().equals(patchId)) {
    throw PatchManagementMessages.MESSAGES.patchActive(patchId);
  }
  if (info.getPatchIDs().contains(patchId)) {
    throw PatchManagementMessages.MESSAGES.patchActive(patchId);
  }
  final InstalledImage installedImage=info.getDirectoryStructure().getInstalledImage();
  final File history=installedImage.getPatchHistoryDir(patchId);
  if (history.exists()) {
    recursiveDelete(history);
  }
  final File patchRoot=installedImage.getPatchHistoryDir(patchId);
  if (patchRoot.exists()) {
    recursiveDelete(patchRoot);
  }
  context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
