{
  requireNoAttributes(reader);
  final Set<String> names=new HashSet<String>();
  while (reader.nextTag() != END_ELEMENT) {
    String uniqueName=null;
    String runtimeName=null;
    byte[] hash=null;
    String startInput=null;
    final int count=reader.getAttributeCount();
    for (int i=0; i < count; i++) {
      final String value=reader.getAttributeValue(i);
      if (reader.getAttributeNamespace(i) != null) {
        throw unexpectedAttribute(reader,i);
      }
 else {
        final Attribute attribute=Attribute.forName(reader.getAttributeLocalName(i));
switch (attribute) {
case NAME:
{
            if (!names.add(value)) {
              throw duplicateNamedElement(reader,value);
            }
            uniqueName=value;
            break;
          }
case RUNTIME_NAME:
{
          runtimeName=value;
          break;
        }
case SHA1:
{
        try {
          hash=HashUtil.hexStringToByteArray(value);
        }
 catch (        final Exception e) {
          throw new XMLStreamException("Value " + value + " for attribute "+ attribute.getLocalName()+ " does not represent a properly hex-encoded SHA1 hash",reader.getLocation(),e);
        }
        break;
      }
case ALLOWED:
{
      if (!Boolean.parseBoolean(value)) {
        throw new XMLStreamException("Attribute '" + attribute.getLocalName() + "' is not allowed",reader.getLocation());
      }
      break;
    }
case START:
{
    startInput=value;
    break;
  }
default :
throw unexpectedAttribute(reader,i);
}
}
}
if (uniqueName == null) {
throw missingRequired(reader,Collections.singleton(Attribute.NAME));
}
if (runtimeName == null) {
throw missingRequired(reader,Collections.singleton(Attribute.RUNTIME_NAME));
}
if (hash == null) {
throw missingRequired(reader,Collections.singleton(Attribute.SHA1));
}
final boolean toStart=startInput == null ? true : Boolean.parseBoolean(startInput);
requireNoContent(reader);
final ModelNode deploymentAddress=address.clone().add(DEPLOYMENT,uniqueName);
final ModelNode deploymentAdd=Util.getEmptyOperation(ADD,deploymentAddress);
deploymentAdd.get(RUNTIME_NAME).set(runtimeName);
deploymentAdd.get(HASH).set(hash);
list.add(deploymentAdd);
if (toStart) {
final ModelNode deployDeployment=Util.getEmptyOperation("deploy",deploymentAddress);
list.add(deployDeployment);
}
}
}
