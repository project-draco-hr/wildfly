{
  final InputStream inputStream=this.inputStream;
  final StringBuilder b=new StringBuilder();
  try {
    for (; ; ) {
      Status status=StreamUtils.readWord(inputStream,b);
      if (status == Status.END_OF_STREAM) {
        log.info("Received end of stream, shutting down " + processName);
        commandStream.closeSocketOutputStream();
        return;
      }
      try {
        final Command command=Command.valueOf(b.toString());
        OUT: switch (command) {
case ADD:
{
            if (status != Status.MORE) {
              break;
            }
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String name=b.toString();
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String workingDirectory=b.toString();
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String sizeString=b.toString();
            final int size;
            try {
              size=Integer.parseInt(sizeString,10);
            }
 catch (            NumberFormatException e) {
              e.printStackTrace(System.err);
              break;
            }
            final List<String> execCmd=new ArrayList<String>();
            for (int i=0; i < size; i++) {
              status=StreamUtils.readWord(inputStream,b);
              if (status != Status.MORE) {
                break OUT;
              }
              execCmd.add(b.toString());
            }
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String mapSizeString=b.toString();
            final int mapSize, lastEntry;
            try {
              mapSize=Integer.parseInt(mapSizeString,10);
              lastEntry=mapSize - 1;
            }
 catch (            NumberFormatException e) {
              e.printStackTrace(System.err);
              break;
            }
            final Map<String,String> env=new HashMap<String,String>();
            for (int i=0; i < mapSize; i++) {
              status=StreamUtils.readWord(inputStream,b);
              if (status != Status.MORE) {
                break OUT;
              }
              final String key=b.toString();
              status=StreamUtils.readWord(inputStream,b);
              if (status == Status.MORE || (i == lastEntry && status == Status.END_OF_LINE)) {
                env.put(key,b.toString());
              }
 else {
                break OUT;
              }
            }
            master.addProcess(name,execCmd,env,workingDirectory);
            break;
          }
case START:
{
          if (status != Status.MORE) {
            break;
          }
          status=StreamUtils.readWord(inputStream,b);
          final String name=b.toString();
          master.startProcess(name);
          break;
        }
case STOP:
{
        if (status != Status.MORE) {
          break;
        }
        status=StreamUtils.readWord(inputStream,b);
        final String name=b.toString();
        master.stopProcess(name);
        break;
      }
case REMOVE:
{
      if (status != Status.MORE) {
        break;
      }
      status=StreamUtils.readWord(inputStream,b);
      final String name=b.toString();
      master.removeProcess(name);
      break;
    }
case SEND:
{
    if (status != Status.MORE) {
      break;
    }
    status=StreamUtils.readWord(inputStream,b);
    final String recipient=b.toString();
    final List<String> msg=new ArrayList<String>(0);
    while (status == Status.MORE) {
      status=StreamUtils.readWord(inputStream,b);
      msg.add(b.toString());
    }
    master.sendMessage(processName,recipient,msg);
    break;
  }
case SEND_BYTES:
{
  if (status != Status.MORE) {
    break;
  }
  status=StreamUtils.readWord(inputStream,b);
  if (status == Status.MORE) {
    final String recipient=b.toString();
    CheckedBytes cb=StreamUtils.readCheckedBytes(inputStream);
    status=cb.getStatus();
    if (cb.getChecksum() != cb.getExpectedChecksum()) {
      log.error("Incorrect checksum on message for " + recipient);
    }
 else {
      master.sendMessage(processName,recipient,cb.getBytes(),cb.getExpectedChecksum());
    }
  }
  break;
}
case BROADCAST:
{
final List<String> msg=new ArrayList<String>(0);
while (status == Status.MORE) {
  status=StreamUtils.readWord(inputStream,b);
  msg.add(b.toString());
}
master.broadcastMessage(processName,msg);
break;
}
case BROADCAST_BYTES:
{
if (status == Status.MORE) {
CheckedBytes cb=StreamUtils.readCheckedBytes(inputStream);
status=cb.getStatus();
if (cb.getChecksum() != cb.getExpectedChecksum()) {
}
 else {
  master.broadcastMessage(processName,cb.getBytes(),cb.getExpectedChecksum());
}
}
break;
}
}
}
 catch (IllegalArgumentException e) {
log.error("Received unknown command: " + b.toString());
}
if (status == Status.MORE) StreamUtils.readToEol(inputStream);
}
}
 catch (Exception e) {
log.error("Output stream handler for process " + processName + " caught an exception; shutting down",e);
}
 finally {
safeClose(inputStream);
int exitCode=0;
for (; ; ) try {
exitCode=process.waitFor();
invokeStopProcessListeners(exitCode);
break;
}
 catch (InterruptedException e) {
}
boolean respawn=false;
synchronized (ManagedProcess.this) {
start=false;
if (exitCode != 0) respawn=!stopped;
}
if (respawn) respawn();
}
}
