{
  final ServiceContainer container=context.getController().getServiceContainer();
  final TrackingServiceTarget serviceTarget=new TrackingServiceTarget(container.subTarget());
  serviceTarget.addDependency(context.getController().getName());
  final DelegatingServiceRegistry serviceRegistry=new DelegatingServiceRegistry(container);
  final Bootstrap.Configuration configuration=this.configuration;
  final ServerEnvironment serverEnvironment=configuration.getServerEnvironment();
  final int threads=(int)(Runtime.getRuntime().availableProcessors() * 1.5f);
  final ExecutorService executor=new ThreadPoolExecutor(threads,threads,Long.MAX_VALUE,TimeUnit.NANOSECONDS,new LinkedBlockingQueue<Runnable>());
  container.setExecutor(executor);
  final ServerModel serverModel=new ServerModel(serverEnvironment.getServerName(),configuration.getPortOffset());
  final ServerConfigurationPersister persister=configuration.getConfigurationPersister();
  final ServerControllerImpl serverController=new ServerControllerImpl(serverModel,container,serverEnvironment,persister,executor);
  final List<AbstractServerModelUpdate<?>> updates;
  try {
    updates=persister.load(serverController);
  }
 catch (  Exception e) {
    throw new StartException(e);
  }
  final EnumMap<Phase,SortedSet<RegisteredProcessor>> deployers=new EnumMap<Phase,SortedSet<RegisteredProcessor>>(Phase.class);
  for (  Phase phase : Phase.values()) {
    deployers.put(phase,new ConcurrentSkipListSet<RegisteredProcessor>());
  }
  final BootUpdateContext bootUpdateContext=new BootUpdateContext(){
    public ServiceTarget getServiceTarget(){
      return serviceTarget;
    }
    public ServiceRegistry getServiceRegistry(){
      return serviceRegistry;
    }
    public void addDeploymentProcessor(    final Phase phase,    final int priority,    final DeploymentUnitProcessor processor){
      if (phase == null) {
        throw new IllegalArgumentException("phase is null");
      }
      if (processor == null) {
        throw new IllegalArgumentException("processor is null");
      }
      if (priority < 0) {
        throw new IllegalArgumentException("priority is invalid (must be >= 0)");
      }
      deployers.get(phase).add(new RegisteredProcessor(priority,processor));
    }
    public ServerEnvironment getServerEnvironment(){
      return serverEnvironment;
    }
  }
;
  log.info("Activating core services");
  serviceTarget.addService(ServerModel.SERVICE_NAME,new Service<ServerModel>(){
    public void start(    StartContext context) throws StartException {
    }
    public void stop(    StopContext context){
    }
    public ServerModel getValue() throws IllegalStateException, IllegalArgumentException {
      return serverModel;
    }
  }
).install();
  serverController.applyUpdates(updates,false,true);
  for (  AbstractServerModelUpdate<?> update : updates) {
    update.applyUpdateBootAction(bootUpdateContext);
  }
  serviceTarget.addService(ServerDeploymentRepository.SERVICE_NAME,new ServerDeploymentRepositoryImpl(serverEnvironment.getServerDeployDir(),serverEnvironment.getServerSystemDeployDir())).install();
  deploymentModuleLoader=new DeploymentModuleLoaderImpl(configuration.getModuleLoader());
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_DEPLOYMENT_MODULE_LOADER,new DeploymentUnitProcessor(){
    public void deploy(    DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
      phaseContext.getDeploymentUnit().putAttachment(Attachments.DEPLOYMENT_MODULE_LOADER,deploymentModuleLoader);
    }
    public void undeploy(    DeploymentUnit context){
      context.removeAttachment(Attachments.DEPLOYMENT_MODULE_LOADER);
    }
  }
));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MOUNT,new DeploymentRootMountProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_MANIFEST,new ManifestAttachmentProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_CLASS_PATH,new ManifestClassPathProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_LIST,new ManifestExtensionListProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_ANNOTATION_INDEX,new AnnotationIndexProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_MODULE,new ModuleDependencyProcessor()));
  deployers.get(Phase.CONFIGURE_MODULE).add(new RegisteredProcessor(Phase.CONFIGURE_MODULE_SPEC,new ModuleSpecProcessor()));
  deployers.get(Phase.MODULARIZE).add(new RegisteredProcessor(Phase.MODULARIZE_DEPLOYMENT,new ModuleDeploymentProcessor()));
  deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_MODULE_CONTEXT,new ModuleContextProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SAR_MODULE,new ServiceActivatorDependencyProcessor()));
  deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_SERVICE_ACTIVATOR,new ServiceActivatorProcessor()));
  final EnumMap<Phase,List<DeploymentUnitProcessor>> finalDeployers=new EnumMap<Phase,List<DeploymentUnitProcessor>>(Phase.class);
  for (  Map.Entry<Phase,SortedSet<RegisteredProcessor>> entry : deployers.entrySet()) {
    final SortedSet<RegisteredProcessor> processorSet=entry.getValue();
    final List<DeploymentUnitProcessor> list=new ArrayList<DeploymentUnitProcessor>(processorSet.size());
    for (    RegisteredProcessor processor : processorSet) {
      list.add(processor.processor);
    }
    finalDeployers.put(entry.getKey(),list);
  }
  DeployerChainsService.addService(serviceTarget,finalDeployers);
  this.serverController=serverController;
  bootServices=serviceTarget.getSet();
}
