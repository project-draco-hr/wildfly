{
  final ServiceContainer container=context.getController().getServiceContainer();
  final TrackingServiceTarget serviceTarget=new TrackingServiceTarget(container.subTarget());
  serviceTarget.addDependency(context.getController().getName());
  final Bootstrap.Configuration configuration=this.configuration;
  final ServerEnvironment serverEnvironment=configuration.getServerEnvironment();
  final int threads=(int)(Runtime.getRuntime().availableProcessors() * 1.5f);
  final ExecutorService executor=new ThreadPoolExecutor(threads,threads,Long.MAX_VALUE,TimeUnit.NANOSECONDS,new LinkedBlockingQueue<Runnable>());
  container.setExecutor(executor);
  final ExtensibleConfigurationPersister persister=configuration.getConfigurationPersister();
  final ServerControllerImpl serverController=new ServerControllerImpl(container,serverEnvironment,persister,injectedDeploymentRepository.getValue());
  serverController.init();
  final List<ModelNode> updates;
  try {
    updates=persister.load();
  }
 catch (  Exception e) {
    throw new StartException(e);
  }
  log.info("Activating core services");
  final AtomicInteger count=new AtomicInteger(1);
  final ResultHandler resultHandler=new ResultHandler(){
    @Override public void handleResultFragment(    final String[] location,    final ModelNode result){
    }
    @Override public void handleResultComplete(    final ModelNode compensatingOperation){
      if (count.decrementAndGet() == 0) {
      }
    }
    @Override public void handleFailed(    final ModelNode failureDescription){
      if (count.decrementAndGet() == 0) {
      }
    }
    @Override public void handleCancellation(){
      if (count.decrementAndGet() == 0) {
      }
    }
  }
;
  for (  ModelNode update : updates) {
    count.incrementAndGet();
    serverController.execute(update,resultHandler);
  }
  if (count.decrementAndGet() == 0) {
  }
  final EnumMap<Phase,SortedSet<RegisteredProcessor>> deployers=serverController.finishBoot();
  final File[] extDirs=serverEnvironment.getJavaExtDirs();
  final File[] newExtDirs=Arrays.copyOf(extDirs,extDirs.length + 1);
  newExtDirs[extDirs.length]=new File(serverEnvironment.getServerBaseDir(),"lib/ext");
  serviceTarget.addService(org.jboss.as.server.deployment.Services.JBOSS_DEPLOYMENT_EXTENSION_INDEX,new ExtensionIndexService(newExtDirs)).setInitialMode(ServiceController.Mode.ON_DEMAND).install();
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SERVICE_MODULE_LOADER,new DeploymentUnitProcessor(){
    @Override public void deploy(    DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
      phaseContext.getDeploymentUnit().putAttachment(Attachments.SERVICE_MODULE_LOADER,injectedModuleLoader.getValue());
      phaseContext.getDeploymentUnit().putAttachment(Attachments.EXTERNAL_MODULE_SERVICE,injectedExternalModuleServie.getValue());
    }
    @Override public void undeploy(    DeploymentUnit context){
      context.removeAttachment(Attachments.SERVICE_MODULE_LOADER);
    }
  }
));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MOUNT,new DeploymentRootMountProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MANIFEST,new ManifestAttachmentProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SUB_DEPLOYMENT,new SubDeploymentProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MODULE_IDENTIFIERS,new ModuleIdentifierProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_ANNOTATION_INDEX,new AnnotationIndexProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_COMPOSITE_ANNOTATION_INDEX,new CompositeIndexProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EAR_LIB_CLASS_PATH,new EarLibManifestClassPathProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_ADDITIONAL_MODULES,new AdditionalModuleProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_CLASS_PATH,new ManifestClassPathProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_LIST,new ManifestExtensionListProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_SERVICE_LOADER_DEPLOYMENT,new ServiceLoaderProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_MODULE,new ModuleDependencyProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SAR_MODULE,new ServiceActivatorDependencyProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_CLASS_PATH,new ModuleClassPathProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_EXTENSION_LIST,new ModuleExtensionListProcessor()));
  deployers.get(Phase.CONFIGURE_MODULE).add(new RegisteredProcessor(Phase.CONFIGURE_MODULE_SPEC,new ModuleSpecProcessor()));
  deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_REFLECTION_INDEX,new InstallReflectionIndexProcessor()));
  deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_SERVICE_ACTIVATOR,new ServiceActivatorProcessor()));
  final EnumMap<Phase,List<DeploymentUnitProcessor>> finalDeployers=new EnumMap<Phase,List<DeploymentUnitProcessor>>(Phase.class);
  for (  Map.Entry<Phase,SortedSet<RegisteredProcessor>> entry : deployers.entrySet()) {
    final SortedSet<RegisteredProcessor> processorSet=entry.getValue();
    final List<DeploymentUnitProcessor> list=new ArrayList<DeploymentUnitProcessor>(processorSet.size());
    for (    RegisteredProcessor processor : processorSet) {
      list.add(processor.getProcessor());
    }
    finalDeployers.put(entry.getKey(),list);
  }
  DeployerChainsService.addService(serviceTarget,finalDeployers);
  this.serverController=serverController;
  bootServices=serviceTarget.getSet();
}
