{
  final ServiceContainer container=context.getController().getServiceContainer();
  final ServiceTarget serviceTarget=context.getChildTarget();
  final Bootstrap.Configuration configuration=this.configuration;
  final ServerEnvironment serverEnvironment=configuration.getServerEnvironment();
  final ExtensibleConfigurationPersister persister=configuration.getConfigurationPersister();
  final ThreadGroup threadGroup=new ThreadGroup("ServerController-threads");
  final ThreadFactory threadFactory=new JBossThreadFactory(threadGroup,Boolean.FALSE,null,"%G - %t",null,null,AccessController.getContext());
  final ExecutorService executorService=Executors.newScheduledThreadPool(DEFAULT_POOL_SIZE,threadFactory);
  final ServerControllerImpl serverController=new ServerControllerImpl(container,serviceTarget,serverEnvironment,persister,injectedContentRepository.getValue(),executorService);
  serverController.init();
  serviceTarget.addListener(serverController.getServerStateMonitorListener());
  final List<ModelNode> updates;
  try {
    updates=persister.load();
  }
 catch (  Exception e) {
    throw new StartException(e);
  }
  log.info("Activating core services");
  final AtomicInteger count=new AtomicInteger(1);
  final ResultHandler resultHandler=new ResultHandler(){
    @Override public void handleResultFragment(    final String[] location,    final ModelNode result){
    }
    @Override public void handleResultComplete(){
      if (count.decrementAndGet() == 0) {
      }
    }
    @Override public void handleFailed(    final ModelNode failureDescription){
      log.errorf("Boot update failed: %s",failureDescription);
      if (count.decrementAndGet() == 0) {
      }
    }
    @Override public void handleCancellation(){
      if (count.decrementAndGet() == 0) {
      }
    }
  }
;
  for (  ModelNode update : updates) {
    count.incrementAndGet();
    update.get(OPERATION_HEADERS,ROLLBACK_ON_RUNTIME_FAILURE).set(false);
    serverController.execute(OperationBuilder.Factory.create(update).build(),resultHandler);
  }
  if (count.decrementAndGet() == 0) {
  }
  final EnumMap<Phase,SortedSet<RegisteredProcessor>> deployers=serverController.finishBoot();
  final File[] extDirs=serverEnvironment.getJavaExtDirs();
  final File[] newExtDirs=Arrays.copyOf(extDirs,extDirs.length + 1);
  newExtDirs[extDirs.length]=new File(serverEnvironment.getServerBaseDir(),"lib/ext");
  serviceTarget.addService(org.jboss.as.server.deployment.Services.JBOSS_DEPLOYMENT_EXTENSION_INDEX,new ExtensionIndexService(newExtDirs)).setInitialMode(ServiceController.Mode.ON_DEMAND).install();
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SERVICE_MODULE_LOADER,new DeploymentUnitProcessor(){
    @Override public void deploy(    DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
      phaseContext.getDeploymentUnit().putAttachment(Attachments.SERVICE_MODULE_LOADER,injectedModuleLoader.getValue());
      phaseContext.getDeploymentUnit().putAttachment(Attachments.EXTERNAL_MODULE_SERVICE,injectedExternalModuleService.getValue());
    }
    @Override public void undeploy(    DeploymentUnit context){
      context.removeAttachment(Attachments.SERVICE_MODULE_LOADER);
    }
  }
));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MOUNT,new DeploymentRootMountProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MANIFEST,new ManifestAttachmentProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_ADDITIONAL_MANIFEST,new ManifestAttachmentProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SUB_DEPLOYMENT,new SubDeploymentProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MODULE_IDENTIFIERS,new ModuleIdentifierProcessor()));
  deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_ANNOTATION_INDEX,new AnnotationIndexProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_STRUCTURE_DESCRIPTOR,new DeploymentStructureDescriptorParser()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_COMPOSITE_ANNOTATION_INDEX,new CompositeIndexProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_ADDITIONAL_MODULES,new AdditionalModuleProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_CLASS_PATH,new ManifestClassPathProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_LIST,new ManifestExtensionListProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_NAME,new ManifestExtensionNameProcessor()));
  deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_SERVICE_LOADER_DEPLOYMENT,new ServiceLoaderProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_MODULE,new ModuleDependencyProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SAR_MODULE,new ServiceActivatorDependencyProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_CLASS_PATH,new ModuleClassPathProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_EXTENSION_LIST,new ModuleExtensionListProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SUB_DEPLOYMENTS,new SubDeploymentDependencyProcessor()));
  deployers.get(Phase.CONFIGURE_MODULE).add(new RegisteredProcessor(Phase.CONFIGURE_MODULE_SPEC,new ModuleSpecProcessor()));
  deployers.get(Phase.POST_MODULE).add(new RegisteredProcessor(Phase.POST_MODULE_INSTALL_EXTENSION,new ModuleExtensionNameProcessor()));
  deployers.get(Phase.POST_MODULE).add(new RegisteredProcessor(Phase.POST_MODULE_REFLECTION_INDEX,new InstallReflectionIndexProcessor()));
  deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_SERVICE_ACTIVATOR,new ServiceActivatorProcessor()));
  deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SEAM,new SeamProcessor()));
  final EnumMap<Phase,List<DeploymentUnitProcessor>> finalDeployers=new EnumMap<Phase,List<DeploymentUnitProcessor>>(Phase.class);
  for (  Map.Entry<Phase,SortedSet<RegisteredProcessor>> entry : deployers.entrySet()) {
    final SortedSet<RegisteredProcessor> processorSet=entry.getValue();
    final List<DeploymentUnitProcessor> list=new ArrayList<DeploymentUnitProcessor>(processorSet.size());
    for (    RegisteredProcessor processor : processorSet) {
      list.add(processor.getProcessor());
    }
    finalDeployers.put(entry.getKey(),list);
  }
  DeployerChainsService.addService(serviceTarget,finalDeployers);
  this.serverController=serverController;
}
