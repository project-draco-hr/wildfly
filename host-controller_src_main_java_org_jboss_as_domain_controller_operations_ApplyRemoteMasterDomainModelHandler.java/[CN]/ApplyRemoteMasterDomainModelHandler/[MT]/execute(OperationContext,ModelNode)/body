{
  final ModelNode domainModel=operation.get(DOMAIN_MODEL);
  final ModelNode startRoot=Resource.Tools.readModel(context.getRootResource());
  final Set<String> ourServerGroups=getOurServerGroups(context);
  final Map<String,Set<byte[]>> deploymentHashes=new HashMap<String,Set<byte[]>>();
  final Set<String> relevantDeployments=new HashSet<String>();
  final Set<byte[]> requiredContent=new HashSet<byte[]>();
  final Resource rootResource=context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);
  clearDomain(rootResource);
  for (  final ModelNode resourceDescription : domainModel.asList()) {
    final PathAddress resourceAddress=PathAddress.pathAddress(resourceDescription.require("domain-resource-address"));
    final Resource resource=getResource(resourceAddress,rootResource,context);
    if (resourceAddress.size() == 1 && resourceAddress.getElement(0).getKey().equals(EXTENSION)) {
      final String module=resourceAddress.getElement(0).getValue();
      if (!appliedExensions.contains(module)) {
        appliedExensions.add(module);
        initializeExtension(module);
      }
    }
    resource.writeModel(resourceDescription.get("domain-resource-model"));
    if (resourceAddress.size() == 1) {
      PathElement pe=resourceAddress.getElement(0);
      String peKey=pe.getKey();
      if (peKey.equals(DEPLOYMENT)) {
        ModelNode model=resource.getModel();
        String id=resourceAddress.getElement(0).getValue();
        if (model.hasDefined(CONTENT)) {
          for (          ModelNode contentItem : model.get(CONTENT).asList()) {
            if (contentItem.hasDefined(HASH)) {
              Set<byte[]> hashes=deploymentHashes.get(id);
              if (hashes == null) {
                hashes=new HashSet<byte[]>();
                deploymentHashes.put(id,hashes);
              }
              hashes.add(contentItem.get(HASH).asBytes());
            }
          }
        }
      }
 else       if (peKey.equals(MANAGEMENT_CLIENT_CONTENT)) {
        ModelNode model=resource.getModel();
        if (model.hasDefined(HASH)) {
          requiredContent.add(model.get(HASH).asBytes());
        }
      }
    }
 else     if (resourceAddress.size() == 2 && resourceAddress.getElement(0).getKey().equals(SERVER_GROUP) && ourServerGroups.contains(resourceAddress.getElement(0).getValue()) && resourceAddress.getElement(1).getKey().equals(DEPLOYMENT)) {
      relevantDeployments.add(resourceAddress.getElement(1).getValue());
    }
  }
  for (  String id : relevantDeployments) {
    Set<byte[]> hashes=deploymentHashes.remove(id);
    if (hashes != null) {
      requiredContent.addAll(hashes);
    }
  }
  for (  byte[] hash : requiredContent) {
    fileRepository.getDeploymentFiles(hash);
  }
  if (!context.isBooting()) {
    final ModelNode endRoot=Resource.Tools.readModel(context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS));
    final Set<ServerIdentity> affectedServers=new HashSet<ServerIdentity>();
    final ModelNode hostModel=endRoot.require(HOST).asPropertyList().iterator().next().getValue();
    final ModelNode existingHostModel=startRoot.require(HOST).asPropertyList().iterator().next().getValue();
    final Map<String,ProxyController> serverProxies=getServerProxies(context);
    final ModelNode startExtensions=startRoot.get(EXTENSION);
    final ModelNode finishExtensions=endRoot.get(EXTENSION);
    if (!startExtensions.equals(finishExtensions)) {
      affectedServers.addAll(DomainServerUtils.getAllRunningServers(hostModel,localHostInfo.getLocalHostName(),serverProxies));
    }
    final ModelNode startPaths=startRoot.get(PATH);
    final ModelNode endPaths=endRoot.get(PATH);
    final Map<String,ModelNode> existingPaths=new HashMap<String,ModelNode>();
    if (startPaths.isDefined())     for (    Property property : startPaths.asPropertyList()) {
      existingPaths.put(property.getName(),property.getValue());
    }
    if (endPaths.isDefined())     for (    Property path : endPaths.asPropertyList()) {
      final String pathName=path.getName();
      if (existingPaths.containsKey(pathName)) {
        if (!path.getValue().equals(existingPaths.get(pathName))) {
          affectedServers.addAll(getServersAffectedByPath(pathName,hostModel,true));
        }
        existingPaths.remove(pathName);
      }
 else {
        affectedServers.addAll(getServersAffectedByPath(pathName,hostModel,true));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingPaths.entrySet()) {
      affectedServers.addAll(getServersAffectedByPath(entry.getKey(),existingHostModel,true));
    }
    final ModelNode startSysProps=startRoot.get(SYSTEM_PROPERTY);
    final ModelNode endSysProps=endRoot.get(SYSTEM_PROPERTY);
    final Map<String,ModelNode> existingProps=new HashMap<String,ModelNode>();
    if (startSysProps.isDefined())     for (    Property property : startSysProps.asPropertyList()) {
      existingProps.put(property.getName(),property.getValue());
    }
    if (endSysProps.isDefined())     for (    Property property : endSysProps.asPropertyList()) {
      if (existingProps.containsKey(property.getName())) {
        if (!property.getValue().equals(existingProps.get(property.getName()))) {
          affectedServers.addAll(getServerAffectedBySystemProperty(property.getName(),true,endRoot,null,hostModel));
        }
        existingProps.remove(property.getName());
      }
 else {
        affectedServers.addAll(getServerAffectedBySystemProperty(property.getName(),true,endRoot,null,hostModel));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingProps.entrySet()) {
      affectedServers.addAll(getServerAffectedBySystemProperty(entry.getKey(),true,startRoot,null,existingHostModel));
    }
    final ModelNode startProfiles=startRoot.get(PROFILE);
    final ModelNode endProfiles=endRoot.get(PROFILE);
    final Map<String,ModelNode> existingProfiles=new HashMap<String,ModelNode>();
    if (startProfiles.isDefined())     for (    Property profile : startProfiles.asPropertyList()) {
      existingProfiles.put(profile.getName(),profile.getValue());
    }
    if (endProfiles.isDefined())     for (    Property profile : endProfiles.asPropertyList()) {
      if (existingProfiles.containsKey(profile.getName())) {
        if (!profile.getValue().equals(existingProfiles.get(profile.getName()))) {
          affectedServers.addAll(getServerAffectedByProfile(profile.getName(),endRoot,hostModel,serverProxies));
        }
        existingProfiles.remove(profile.getName());
      }
 else {
        affectedServers.addAll(getServerAffectedByProfile(profile.getName(),endRoot,hostModel,serverProxies));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingProfiles.entrySet()) {
      affectedServers.addAll(getServerAffectedByProfile(entry.getKey(),startRoot,existingHostModel,serverProxies));
    }
    final ModelNode startInterfaces=startRoot.get(INTERFACE);
    final ModelNode endInterfaces=endRoot.get(INTERFACE);
    final Map<String,ModelNode> existingInterfaces=new HashMap<String,ModelNode>();
    if (startInterfaces.isDefined())     for (    Property interfaceProp : startInterfaces.asPropertyList()) {
      existingInterfaces.put(interfaceProp.getName(),interfaceProp.getValue());
    }
    if (endInterfaces.isDefined())     for (    Property interfaceProp : endInterfaces.asPropertyList()) {
      if (existingInterfaces.containsKey(interfaceProp.getName())) {
        if (!interfaceProp.getValue().equals(existingInterfaces.get(interfaceProp.getName()))) {
          affectedServers.addAll(getServersAffectedByInterface(interfaceProp.getName(),hostModel,true));
        }
        existingInterfaces.remove(interfaceProp.getName());
      }
 else {
        affectedServers.addAll(getServersAffectedByInterface(interfaceProp.getName(),hostModel,true));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingInterfaces.entrySet()) {
      affectedServers.addAll(getServersAffectedByInterface(entry.getKey(),existingHostModel,true));
    }
    final ModelNode startBindingGroups=startRoot.get(SOCKET_BINDING_GROUP);
    final ModelNode endBindingGroups=endRoot.get(SOCKET_BINDING_GROUP);
    final Map<String,ModelNode> existingBindingGroups=new HashMap<String,ModelNode>();
    if (startBindingGroups.isDefined())     for (    Property bindingGroup : startBindingGroups.asPropertyList()) {
      existingBindingGroups.put(bindingGroup.getName(),bindingGroup.getValue());
    }
    if (endBindingGroups.isDefined())     for (    Property bindingGroup : endBindingGroups.asPropertyList()) {
      if (existingBindingGroups.containsKey(bindingGroup.getName())) {
        if (!bindingGroup.getValue().equals(existingBindingGroups.get(bindingGroup.getName()))) {
          affectedServers.addAll(getServersAffectedBySocketBindingGroup(bindingGroup.getName(),endRoot,hostModel,serverProxies));
        }
        existingBindingGroups.remove(bindingGroup.getName());
      }
 else {
        affectedServers.addAll(getServersAffectedBySocketBindingGroup(bindingGroup.getName(),endRoot,hostModel,serverProxies));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingBindingGroups.entrySet()) {
      affectedServers.addAll(getServersAffectedBySocketBindingGroup(entry.getKey(),startRoot,existingHostModel,serverProxies));
    }
    final ModelNode startServerGroups=startRoot.get(SERVER_GROUP);
    final ModelNode endServerGroups=endRoot.get(SERVER_GROUP);
    final Map<String,ModelNode> existingServerGroups=new HashMap<String,ModelNode>();
    if (startServerGroups.isDefined())     for (    Property serverGroup : startServerGroups.asPropertyList()) {
      existingServerGroups.put(serverGroup.getName(),serverGroup.getValue());
    }
    if (endServerGroups.isDefined())     for (    Property serverGroup : endServerGroups.asPropertyList()) {
      if (existingServerGroups.containsKey(serverGroup.getName())) {
        if (!serverGroup.getValue().equals(existingServerGroups.get(serverGroup.getName()))) {
          affectedServers.addAll(getServersForGroup(serverGroup.getName(),hostModel,localHostInfo.getLocalHostName(),serverProxies));
        }
        existingServerGroups.remove(serverGroup.getName());
      }
 else {
        affectedServers.addAll(getServersForGroup(serverGroup.getName(),hostModel,localHostInfo.getLocalHostName(),serverProxies));
      }
    }
    for (    Map.Entry<String,ModelNode> entry : existingServerGroups.entrySet()) {
      affectedServers.addAll(getServersForGroup(entry.getKey(),hostModel,localHostInfo.getLocalHostName(),serverProxies));
    }
    if (!affectedServers.isEmpty()) {
      ROOT_LOGGER.domainModelChangedOnReConnect(affectedServers);
      final Set<ServerIdentity> runningServers=DomainServerUtils.getAllRunningServers(hostModel,localHostInfo.getLocalHostName(),serverProxies);
      for (      ServerIdentity serverIdentity : affectedServers) {
        if (!runningServers.contains(serverIdentity)) {
          continue;
        }
        final PathAddress serverAddress=PathAddress.pathAddress(PathElement.pathElement(HOST,serverIdentity.getHostName()),PathElement.pathElement(SERVER,serverIdentity.getServerName()));
        final OperationStepHandler handler=context.getResourceRegistration().getOperationHandler(serverAddress,ServerRestartRequiredHandler.OPERATION_NAME);
        final ModelNode op=new ModelNode();
        op.get(OP).set(ServerRestartRequiredHandler.OPERATION_NAME);
        op.get(OP_ADDR).set(serverAddress.toModelNode());
        context.addStep(op,handler,OperationContext.Stage.IMMEDIATE);
      }
    }
  }
  context.completeStep();
}
