{
  DistributionContentItem itemPath=oldStructure.getContentItem(file,parent);
  DistributionContentItem.Type type=itemPath.getType();
  boolean recurse=type.getHasRelevantChildren();
  if (!oldVisited.contains(itemPath)) {
switch (type) {
case BUNDLE_PARENT:
      break;
case BUNDLE_ROOT:
    recordBundleRemove(itemPath);
  recurse=false;
break;
case BUNDLE_CONTENT:
DistributionContentItem newItemPath=newStructure.getCurrentVersionPath(itemPath,oldStructure);
recordBundleUpdate(newItemPath);
recurse=false;
break;
case MODULE_PARENT:
break;
case MODULE_ROOT:
recordModuleRemove(itemPath);
recurse=false;
break;
case MODULE_CONTENT:
recordModuleUpdateViaContentRemove(itemPath);
recurse=false;
break;
case MISC:
recordMiscFileRemove(itemPath,patchConfig,getHash(file));
break;
case IGNORED:
break;
case DISTRIBUTION_ROOT:
default :
throw new IllegalStateException();
}
}
if (recurse && file.isDirectory()) {
File[] children=file.listFiles();
if (children != null) {
for (File child : children) {
processOldVersionFile(child,itemPath,patchConfig,oldVisited);
}
}
}
}
