{
  try {
    PatchConfig patchConfig=parsePatchConfig();
    this.oldStructure=patchConfig.getOriginalDistributionStructure();
    this.newStructure=patchConfig.getUpdatedDistributionStructure();
    Set<String> required=new TreeSet<String>();
    if (newRoot == null) {
      newRoot=findDefaultNewRoot();
      if (newRoot == null) {
        required.add("--updated-dist");
      }
    }
    if (oldRoot == null) {
      oldRoot=findDefaultOldRoot(patchConfig);
      if (oldRoot == null) {
        required.add("--applies-to-dist");
      }
    }
    if (patchFile == null) {
      if (newRoot != null) {
        patchFile=new File(newRoot,"patch-" + System.currentTimeMillis() + ".par");
      }
 else {
        required.add("--output-file");
      }
    }
    if (!required.isEmpty()) {
      System.err.printf(PatchMessages.MESSAGES.missingRequiredArgs(required));
      usage();
      return;
    }
    createTempStructure("test");
    final Distribution base=Distribution.create(oldRoot);
    final Distribution updated=Distribution.create(newRoot);
    final PatchBuilderWrapper wrapper=new PatchBuilderWrapper(){
      @Override PatchElementBuilder modifyLayer(      String name,      boolean addOn){
        return addElement(randomUUID().toString(),name,addOn);
      }
    }
;
    wrapper.setPatchId(randomUUID().toString());
    wrapper.setDescription("Test patch");
    wrapper.cumulativePatchIdentity(Version.AS_RELEASE_CODENAME,Version.AS_VERSION);
    final Patch patch=wrapper.compare(base,updated);
    PatchContentWriter.process(tmp,newRoot,patch);
    ZipUtils.zip(tmp,patchFile);
  }
  finally {
    IoUtils.recursiveDelete(tmp);
  }
}
