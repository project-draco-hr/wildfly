{
  ClassLoader origTCCL=SecurityActions.getContextClassLoader();
  JournalType jtype=configuration.getJournalType();
  if (jtype == JournalType.ASYNCIO) {
    boolean supportsAIO=AIOSequentialFileFactory.isSupported();
    if (supportsAIO == false) {
      ROOT_LOGGER.aioWarning();
      configuration.setJournalType(JournalType.NIO);
    }
  }
  configuration.setFileDeploymentEnabled(false);
  PathManager pathManager=this.pathManager.getValue();
  configuration.setBindingsDirectory(pathConfig.resolveBindingsPath(pathManager));
  configuration.setLargeMessagesDirectory(pathConfig.resolveLargeMessagePath(pathManager));
  configuration.setJournalDirectory(pathConfig.resolveJournalPath(pathManager));
  configuration.setPagingDirectory(pathConfig.resolvePagingPath(pathManager));
  try {
    Collection<TransportConfiguration> acceptors=configuration.getAcceptorConfigurations();
    Collection<TransportConfiguration> connectors=configuration.getConnectorConfigurations().values();
    Collection<BroadcastGroupConfiguration> broadcastGroups=configuration.getBroadcastGroupConfigurations();
    Map<String,DiscoveryGroupConfiguration> discoveryGroups=configuration.getDiscoveryGroupConfigurations();
    if (connectors != null) {
      for (      TransportConfiguration tc : connectors) {
        Object socketRef=tc.getParams().remove(SOCKET_REF);
        if (socketRef != null) {
          String name=socketRef.toString();
          String host;
          int port;
          OutboundSocketBinding binding=outboundSocketBindings.get(name);
          if (binding == null) {
            final SocketBinding socketBinding=socketBindings.get(name);
            if (socketBinding == null) {
              throw MESSAGES.failedToFindConnectorSocketBinding(tc.getName());
            }
            InetSocketAddress sa=socketBinding.getSocketAddress();
            port=sa.getPort();
            if (sa.getAddress().isLoopbackAddress()) {
              host=sa.getAddress().getHostName();
            }
 else {
              host=sa.getAddress().getHostAddress();
            }
          }
 else {
            port=binding.getDestinationPort();
            if (binding.getDestinationAddress().isLoopbackAddress()) {
              host=binding.getDestinationAddress().getHostName();
            }
 else {
              host=binding.getDestinationAddress().getHostAddress();
            }
          }
          tc.getParams().put(HOST,host);
          tc.getParams().put(PORT,String.valueOf(port));
        }
      }
    }
    if (acceptors != null) {
      for (      TransportConfiguration tc : acceptors) {
        Object socketRef=tc.getParams().remove(SOCKET_REF);
        if (socketRef != null) {
          String name=socketRef.toString();
          SocketBinding binding=socketBindings.get(name);
          if (binding == null) {
            throw MESSAGES.failedToFindConnectorSocketBinding(tc.getName());
          }
          InetSocketAddress socketAddress=binding.getSocketAddress();
          tc.getParams().put(HOST,socketAddress.getAddress().getHostAddress());
          tc.getParams().put(PORT,"" + socketAddress.getPort());
        }
      }
    }
    final Map<String,JChannel> channels=new HashMap<String,JChannel>();
    if (broadcastGroups != null) {
      final List<BroadcastGroupConfiguration> newConfigs=new ArrayList<BroadcastGroupConfiguration>();
      for (      final BroadcastGroupConfiguration config : broadcastGroups) {
        final String name=config.getName();
        final String key="broadcast" + name;
        if (jgroupFactories.containsKey(key)) {
          ChannelFactory channelFactory=jgroupFactories.get(key);
          String channelName=jgroupsChannels.get(key);
          JChannel channel=(JChannel)channelFactory.createChannel(channelName);
          channels.put(channelName,channel);
          newConfigs.add(BroadcastGroupAdd.createBroadcastGroupConfiguration(name,config,channel,channelName));
        }
 else {
          final SocketBinding binding=groupBindings.get(key);
          if (binding == null) {
            throw MESSAGES.failedToFindBroadcastSocketBinding(name);
          }
          newConfigs.add(BroadcastGroupAdd.createBroadcastGroupConfiguration(name,config,binding));
        }
      }
      configuration.getBroadcastGroupConfigurations().clear();
      configuration.getBroadcastGroupConfigurations().addAll(newConfigs);
    }
    if (discoveryGroups != null) {
      configuration.setDiscoveryGroupConfigurations(new HashMap<String,DiscoveryGroupConfiguration>());
      for (      final Map.Entry<String,DiscoveryGroupConfiguration> entry : discoveryGroups.entrySet()) {
        final String name=entry.getKey();
        final String key="discovery" + name;
        DiscoveryGroupConfiguration config=null;
        if (jgroupFactories.containsKey(key)) {
          ChannelFactory channelFactory=jgroupFactories.get(key);
          String channelName=jgroupsChannels.get(key);
          JChannel channel=channels.get(channelName);
          if (channel == null) {
            channel=(JChannel)channelFactory.createChannel(key);
            channels.put(channelName,channel);
          }
          config=DiscoveryGroupAdd.createDiscoveryGroupConfiguration(name,entry.getValue(),channel,channelName);
        }
 else {
          final SocketBinding binding=groupBindings.get(key);
          if (binding == null) {
            throw MESSAGES.failedToFindDiscoverySocketBinding(name);
          }
          config=DiscoveryGroupAdd.createDiscoveryGroupConfiguration(name,entry.getValue(),binding);
        }
        configuration.getDiscoveryGroupConfigurations().put(name,config);
      }
    }
    HornetQSecurityManagerAS7 hornetQSecurityManagerAS7=new HornetQSecurityManagerAS7(securityDomainContextValue.getValue());
    server=new HornetQServerImpl(configuration,mbeanServer.getOptionalValue(),hornetQSecurityManagerAS7);
    if (HornetQDefaultConfiguration.DEFAULT_CLUSTER_PASSWORD.equals(server.getConfiguration().getClusterPassword())) {
      server.getConfiguration().setClusterPassword(java.util.UUID.randomUUID().toString());
    }
  }
 catch (  Exception e) {
    throw MESSAGES.failedToStartService(e);
  }
 finally {
    SecurityActions.setContextClassLoader(origTCCL);
  }
}
