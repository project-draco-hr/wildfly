{
  final InvocationContext invocationContext=context.getInvocationContext();
  LockableComponent lockableComponent=this.getLockableComponent();
  Method invokedMethod=invocationContext.getMethod();
  if (invokedMethod == null) {
    throw new IllegalArgumentException("Invocation context: " + invocationContext + " cannot be processed because it's not applicable for a method invocation");
  }
  Lock lock=getLock(lockableComponent,invokedMethod);
  AccessTimeoutDetails defaultAccessTimeout=lockableComponent.getDefaultAccessTimeout();
  long time=defaultAccessTimeout.getValue();
  TimeUnit unit=defaultAccessTimeout.getTimeUnit();
  AccessTimeoutDetails accessTimeoutOnMethod=lockableComponent.getAccessTimeout(invokedMethod);
  if (accessTimeoutOnMethod != null) {
    if (accessTimeoutOnMethod.getValue() < 0) {
      logger.debug("Ignoring a negative @AccessTimeout value: " + accessTimeoutOnMethod.getValue() + " and timeout unit: "+ accessTimeoutOnMethod.getTimeUnit().name()+ ". Will default to timeout value: "+ defaultAccessTimeout.getValue()+ " and timeout unit: "+ defaultAccessTimeout.getTimeUnit().name());
    }
 else {
      time=accessTimeoutOnMethod.getValue();
      unit=accessTimeoutOnMethod.getTimeUnit();
    }
  }
  boolean success=lock.tryLock(time,unit);
  if (!success) {
    throw new ConcurrentAccessTimeoutException("EJB 3.1 PFD2 4.8.5.5.1 concurrent access timeout on " + invocationContext + " - could not obtain lock within "+ time+ unit.name());
  }
  try {
    return invocationContext.proceed();
  }
  finally {
    lock.unlock();
  }
}
