{
  final ParsedRelationship metaData=new ParsedRelationship();
  for (  Element element : children(reader)) {
switch (element) {
case EJB_RELATION_NAME:
{
        metaData.relationName=getElementText(reader);
        break;
      }
case READ_ONLY:
{
      metaData.readOnly=Boolean.parseBoolean(getElementText(reader));
      break;
    }
case READ_TIMEOUT:
{
    metaData.readTimeOut=Integer.parseInt(getElementText(reader));
    break;
  }
case FOREIGN_KEY_MAPPING:
{
  metaData.mappingStyle=JDBCRelationMetaData.MappingStyle.FOREIGN_KEY;
  getElementText(reader);
  break;
}
case RELATION_TABLE_MAPPING:
{
metaData.mappingStyle=JDBCRelationMetaData.MappingStyle.TABLE;
for (Element tableElement : children(reader)) {
switch (tableElement) {
case TABLE_NAME:
{
      metaData.tableName=getElementText(reader);
      break;
    }
case DATASOURCE:
{
    metaData.dataSourceName=getElementText(reader);
    break;
  }
case DATASOURCE_MAPPING:
{
  metaData.datasourceMapping=getElementText(reader);
  break;
}
case CREATE_TABLE:
{
metaData.createTable=Boolean.parseBoolean(getElementText(reader));
break;
}
case REMOVE_TABLE:
{
metaData.removeTable=Boolean.parseBoolean(getElementText(reader));
break;
}
case ALTER_TABLE:
{
metaData.alterTable=Boolean.parseBoolean(getElementText(reader));
break;
}
case POST_TABLE_CREATE:
{
for (String cmd : parsePostTableCreate(reader)) {
metaData.tablePostCreateCmd.add(cmd);
}
break;
}
case ROW_LOCKING:
{
metaData.rowLocking=Boolean.parseBoolean(getElementText(reader));
break;
}
case PK_CONSTRAINT:
{
metaData.primaryKeyConstraint=Boolean.parseBoolean(getElementText(reader));
break;
}
default :
{
throw unexpectedElement(reader);
}
}
}
break;
}
case EJB_RELATIONSHIP_ROLE:
{
metaData.roles.add(parseEjbRelationshipRole(reader));
break;
}
default :
{
throw unexpectedElement(reader);
}
}
}
return metaData;
}
