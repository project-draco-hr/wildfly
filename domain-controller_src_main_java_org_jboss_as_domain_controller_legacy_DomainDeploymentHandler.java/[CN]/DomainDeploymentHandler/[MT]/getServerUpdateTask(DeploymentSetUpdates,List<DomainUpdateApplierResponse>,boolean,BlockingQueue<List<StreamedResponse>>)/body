{
  logger.debugf("Creating server tasks for %s domain responses",rsps.size());
  Map<String,SortedSet<ServerIdentity>> serversByGroup=new HashMap<String,SortedSet<ServerIdentity>>();
  for (  DomainUpdateApplierResponse duar : rsps) {
    for (    ServerIdentity serverId : duar.getServers()) {
      String serverGroupName=serverId.getServerGroupName();
      SortedSet<ServerIdentity> set=serversByGroup.get(serverGroupName);
      if (set == null) {
        logger.debugf("Found affected servers in server group %s",serverGroupName);
        set=new TreeSet<ServerIdentity>(ServerIdentityComparator.INSTANCE);
        serversByGroup.put(serverGroupName,set);
      }
      set.add(serverId);
    }
  }
  boolean shutdown=updateSet.setPlan.isShutdown();
  long gracefulTimeout=updateSet.setPlan.getGracefulShutdownTimeout();
  List<Runnable> masterList=new ArrayList<Runnable>();
  ConcurrentGroupServerUpdatePolicy predecessor=null;
  for (  Set<ServerGroupDeploymentPlan> groupPlans : updateSet.setPlan.getServerGroupDeploymentPlans()) {
    Set<String> groupNames=new HashSet<String>(groupPlans.size());
    for (    ServerGroupDeploymentPlan groupPlan : groupPlans) {
      groupNames.add(groupPlan.getServerGroupName());
    }
    List<Runnable> concurrentGroupsList=new ArrayList<Runnable>(groupPlans.size());
    ConcurrentGroupServerUpdatePolicy parent=new ConcurrentGroupServerUpdatePolicy(predecessor,groupNames);
    predecessor=parent;
    for (    ServerGroupDeploymentPlan groupPlan : groupPlans) {
      String serverGroupName=groupPlan.getServerGroupName();
      SortedSet<ServerIdentity> servers=serversByGroup.get(serverGroupName);
      if (servers == null) {
        servers=new TreeSet<ServerIdentity>();
      }
      ServerUpdatePolicy policy=null;
      if (forRollbacks) {
        policy=new ServerUpdatePolicy(parent,serverGroupName,servers);
        updateSet.rollbackPolicies.put(serverGroupName,policy);
      }
 else {
        int maxFailures;
        if (groupPlan.getMaxServerFailurePercentage() > 0) {
          maxFailures=((servers.size() * groupPlan.getMaxServerFailurePercentage()) / 100);
        }
 else {
          maxFailures=groupPlan.getMaxServerFailures();
        }
        policy=new ServerUpdatePolicy(parent,serverGroupName,servers,maxFailures);
        updateSet.updatePolicies.put(serverGroupName,policy);
      }
      List<Runnable> groupTasks=new ArrayList<Runnable>(servers.size());
      if (shutdown) {
        for (        ServerIdentity server : servers) {
          groupTasks.add(new ServerRestartTask(server,updateSet,forRollbacks,policy,responseQueue,gracefulTimeout));
        }
      }
 else       if (forRollbacks) {
        for (        ServerIdentity server : servers) {
          List<AbstractServerModelUpdate<?>> serverRollbacks=null;
          List<UpdateResultHandlerResponse<?>> origResults=updateSet.serverResults.get(server);
          if (origResults == null) {
            serverRollbacks=updateSet.getServerRollbacks();
          }
 else {
            serverRollbacks=new ArrayList<AbstractServerModelUpdate<?>>();
            boolean rollingBack=false;
            for (int i=origResults.size() - 1; i >= 0; i--) {
              UpdateResultHandlerResponse<?> origResult=origResults.get(i);
              if (!rollingBack) {
                rollingBack=!origResult.isCancelled() && !origResult.isRolledBack();
              }
              if (rollingBack) {
                serverRollbacks.add(updateSet.getRollbackUpdateForServerUpdate(i));
              }
            }
          }
          if (serverRollbacks.size() > 0) {
            groupTasks.add(new RunningServerUpdateTask(server,updateSet,serverRollbacks,policy,responseQueue));
          }
        }
      }
 else {
        for (        ServerIdentity server : servers) {
          groupTasks.add(new RunningServerUpdateTask(server,updateSet,policy,responseQueue,groupPlan.isRollback()));
        }
      }
      if (groupPlan.isRollingToServers()) {
        concurrentGroupsList.add(new RollingUpdateTask(groupTasks));
      }
 else {
        concurrentGroupsList.add(new ConcurrentUpdateTask(groupTasks,getDeploymentExecutor()));
      }
    }
    masterList.add(new ConcurrentUpdateTask(concurrentGroupsList,getDeploymentExecutor()));
  }
  return new RollingUpdateTask(masterList);
}
