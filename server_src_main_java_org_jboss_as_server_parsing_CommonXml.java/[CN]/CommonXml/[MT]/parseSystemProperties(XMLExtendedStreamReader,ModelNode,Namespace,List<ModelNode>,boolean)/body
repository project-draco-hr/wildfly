{
  while (reader.nextTag() != END_ELEMENT) {
    requireNamespace(reader,expectedNs);
    final Element element=Element.forName(reader.getLocalName());
    if (element != Element.PROPERTY) {
      throw unexpectedElement(reader);
    }
    String name=null;
    ModelNode value=null;
    Boolean boottime=null;
    final int count=reader.getAttributeCount();
    for (int i=0; i < count; i++) {
      final String val=reader.getAttributeValue(i);
      if (!isNoNamespaceAttribute(reader,i)) {
        throw unexpectedAttribute(reader,i);
      }
 else {
        final Attribute attribute=Attribute.forName(reader.getAttributeLocalName(i));
switch (attribute) {
case NAME:
{
            if (name != null) {
              throw ParseUtils.duplicateAttribute(reader,NAME);
            }
            name=val;
            break;
          }
case VALUE:
{
          if (value != null) {
            throw ParseUtils.duplicateAttribute(reader,VALUE);
          }
          value=ParseUtils.parsePossibleExpression(val);
          break;
        }
case BOOT_TIME:
{
        if (standalone) {
          throw unexpectedAttribute(reader,i);
        }
        boottime=Boolean.valueOf(val);
        break;
      }
default :
{
      throw unexpectedAttribute(reader,i);
    }
}
}
}
requireNoContent(reader);
ModelNode propAddr=new ModelNode().set(address).add(SYSTEM_PROPERTY,name);
ModelNode op=Util.getEmptyOperation(SystemPropertyAddHandler.OPERATION_NAME,propAddr);
op.get(VALUE).set(value);
if (boottime != null) {
op.get(BOOT_TIME).set(boottime.booleanValue());
}
updates.add(op);
}
}
