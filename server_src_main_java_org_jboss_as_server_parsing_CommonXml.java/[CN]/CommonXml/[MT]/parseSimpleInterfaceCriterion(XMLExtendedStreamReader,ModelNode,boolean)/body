{
  final Element element=Element.forName(reader.getLocalName());
  final String localName=element.getLocalName();
switch (element) {
case INET_ADDRESS:
{
      requireSingleAttribute(reader,Attribute.VALUE.getLocalName());
      final String value=reader.getAttributeValue(0);
      ModelNode valueNode=parsePossibleExpression(value);
      requireNoContent(reader);
      if (nested) {
        subModel.get(localName).add(valueNode);
      }
 else {
        subModel.get(localName).set(valueNode);
      }
      break;
    }
case LOOPBACK_ADDRESS:
{
    requireSingleAttribute(reader,Attribute.VALUE.getLocalName());
    final String value=reader.getAttributeValue(0);
    ModelNode valueNode=parsePossibleExpression(value);
    requireNoContent(reader);
    subModel.get(localName).set(valueNode);
    break;
  }
case LINK_LOCAL_ADDRESS:
case LOOPBACK:
case MULTICAST:
case POINT_TO_POINT:
case PUBLIC_ADDRESS:
case SITE_LOCAL_ADDRESS:
case UP:
case VIRTUAL:
{
  requireNoAttributes(reader);
  requireNoContent(reader);
  subModel.get(localName).set(true);
  break;
}
case NIC:
{
requireSingleAttribute(reader,Attribute.NAME.getLocalName());
final String value=reader.getAttributeValue(0);
requireNoContent(reader);
if (nested) {
  subModel.get(localName).add(value);
}
 else {
  subModel.get(localName).set(value);
}
break;
}
case NIC_MATCH:
{
requireSingleAttribute(reader,Attribute.PATTERN.getLocalName());
final String value=reader.getAttributeValue(0);
requireNoContent(reader);
if (nested) {
subModel.get(localName).add(value);
}
 else {
subModel.get(localName).set(value);
}
break;
}
case SUBNET_MATCH:
{
requireSingleAttribute(reader,Attribute.VALUE.getLocalName());
final String value=reader.getAttributeValue(0);
requireNoContent(reader);
if (nested) {
subModel.get(localName).add(value);
}
 else {
subModel.get(localName).set(value);
}
break;
}
default :
throw unexpectedElement(reader);
}
}
