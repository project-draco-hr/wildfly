{
  if (!(context.getRuntimeContext() != null)) {
    return super.execute(context,operation,resultHandler);
  }
  try {
    final List<ModelNode> steps=operation.require(STEPS).asList();
    final ModelNode testResults=new ModelNode();
    final ModelNode testFailure=new ModelNode();
    validateAgainstModel(context,operation,testResults,testFailure);
    if (testFailure.isDefined()) {
      for (int i=0; i < steps.size(); i++) {
        if (testResults.has(i) && testResults.get(i).has(RESULT)) {
          testResults.get(i).remove(RESULT);
        }
      }
      resultHandler.handleResultFragment(EMPTY,testResults);
      throw new OperationFailedException(testFailure);
    }
 else {
      final ModelNode rorf=operation.get(ROLLBACK_ON_RUNTIME_FAILURE);
      final boolean rollback=!rorf.isDefined() || rorf.asBoolean();
      final RuntimeCompositeOperationContext compositeContext=new RuntimeCompositeOperationContext((ServerOperationContext)context,resultHandler,rollback);
      executeSteps(compositeContext,steps);
    }
  }
 catch (  final Exception e) {
    throw new OperationFailedException(new ModelNode().set(e.toString()));
  }
  return new BasicOperationResult();
}
