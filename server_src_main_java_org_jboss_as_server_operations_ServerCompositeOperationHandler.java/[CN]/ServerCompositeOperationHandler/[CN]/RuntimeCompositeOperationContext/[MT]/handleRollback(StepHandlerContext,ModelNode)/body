{
  final CountDownLatch handlerLatch=new CountDownLatch(results.asInt());
  for (int i=results.asInt() - 1; i >= 0; i--) {
    final ModelNode result=results.get(i);
    if (!result.has(CANCELLED) || !result.get(CANCELLED).asBoolean()) {
      final ModelNode compStep=stepHandlerContext.getCompensatingOperation(Integer.valueOf(i));
      if (compStep == null) {
        continue;
      }
      final PathAddress address=PathAddress.pathAddress(compStep.require(OP_ADDR));
      final String operationName=compStep.require(OP).asString();
      final OperationHandler stepHandler=getRegistry().getOperationHandler(address,operationName);
      final boolean stepModelOnly=modelOnlyStates.get(i);
      final OperationContext stepRollbackContext;
      if (stepModelOnly) {
        stepRollbackContext=super.getStepOperationContext(Integer.valueOf(i),address,stepHandler);
      }
 else {
        if (this.modelOnly) {
          overallRuntimeContext.revertRestartRequired();
        }
        if (stepHandler instanceof RuntimeOperationContext) {
          final ModelNode stepModel=getStepSubModel(address,stepHandler);
          stepRollbackContext=getRuntimeOperationContext(stepModel);
        }
 else {
          stepRollbackContext=super.getStepOperationContext(Integer.valueOf(i),address,stepHandler);
        }
      }
      final ResultHandler stepRollbackHandler=new ResultHandler(){
        @Override public void handleResultFragment(        final String[] location,        final ModelNode result){
        }
        @Override public void handleResultComplete(        final ModelNode compensatingOperation){
          result.get(ROLLED_BACK).set(true);
          handlerLatch.countDown();
        }
        @Override public void handleFailed(        final ModelNode failureDescription){
          result.get(ROLLBACK_FAILURE).set(failureDescription);
          handlerLatch.countDown();
        }
        @Override public void handleCancellation(){
          handleFailed(new ModelNode().set("Rollback cancelled"));
        }
      }
;
      stepHandler.execute(stepRollbackContext,compStep,stepRollbackHandler);
    }
 else {
      handlerLatch.countDown();
    }
  }
  try {
    handlerLatch.await();
  }
 catch (  final InterruptedException e) {
    for (    final ModelNode result : results.asList()) {
      if ((!result.has(CANCELLED) || !result.get(CANCELLED).asBoolean()) && !result.has(ROLLED_BACK) && !result.has(ROLLBACK_FAILURE)) {
        result.get(ROLLBACK_FAILURE).set("Interrrupted while awaiting completion of rollback");
      }
    }
    Thread.currentThread().interrupt();
  }
}
