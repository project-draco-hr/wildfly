{
  final ModelNode composite=new ModelNode();
  composite.get(Util.OPERATION).set(Util.COMPOSITE);
  composite.get(Util.ADDRESS).setEmptyList();
  final ModelNode steps=composite.get(Util.STEPS);
  final ParsedCommandLine args=ctx.getParsedCommandLine();
  final String name=this.name.getValue(args);
  final boolean keepContent=this.keepContent.isPresent(args);
  final boolean allRelevantServerGroups=this.allRelevantServerGroups.isPresent(args);
  final String serverGroupsStr=this.serverGroups.getValue(args);
  final String path=this.path.getValue(args);
  final File f;
  if (path != null) {
    f=new File(path);
    if (!f.exists()) {
      throw new OperationFormatException("Path '" + f.getAbsolutePath() + "' doesn't exist.");
    }
    if (!isCliArchive(f)) {
      throw new OperationFormatException("File '" + f.getAbsolutePath() + "' is not a valid CLI archive. CLI archives should have a '.cli' extension.");
    }
  }
 else {
    f=null;
  }
  if (isCliArchive(f)) {
    if (name != null) {
      throw new OperationFormatException(this.name.getFullName() + " can't be used in combination with a CLI archive.");
    }
    if (serverGroupsStr != null || allRelevantServerGroups) {
      throw new OperationFormatException(this.serverGroups.getFullName() + " and " + this.allRelevantServerGroups.getFullName()+ " can't be used in combination with a CLI archive.");
    }
    if (keepContent) {
      throw new OperationFormatException(this.keepContent.getFullName() + " can't be used in combination with a CLI archive.");
    }
    TempFileProvider tempFileProvider;
    MountHandle root;
    try {
      tempFileProvider=TempFileProvider.create("cli",Executors.newSingleThreadScheduledExecutor());
      root=extractArchive(f,tempFileProvider);
    }
 catch (    IOException e) {
      throw new OperationFormatException("Unable to extract archive '" + f.getAbsolutePath() + "' to temporary location");
    }
    final File currentDir=ctx.getCurrentDir();
    ctx.setCurrentDir(root.getMountSource());
    String holdbackBatch=activateNewBatch(ctx);
    try {
      String script=this.script.getValue(args);
      if (script == null) {
        script="undeploy.scr";
      }
      File scriptFile=new File(ctx.getCurrentDir(),script);
      if (!scriptFile.exists()) {
        throw new CommandFormatException("ERROR: script '" + script + "' not found in archive '"+ f.getAbsolutePath()+ "'.");
      }
      BufferedReader reader=null;
      try {
        reader=new BufferedReader(new FileReader(scriptFile));
        String line=reader.readLine();
        while (!ctx.isTerminated() && line != null) {
          ctx.handle(line);
          line=reader.readLine();
        }
      }
 catch (      FileNotFoundException e) {
        throw new CommandFormatException("ERROR: script '" + script + "' not found in archive '"+ f.getAbsolutePath()+ "'.");
      }
catch (      IOException e) {
        throw new CommandFormatException("Failed to read the next command from " + scriptFile.getName() + ": "+ e.getMessage(),e);
      }
catch (      CommandLineException e) {
        throw new CommandFormatException(e.getMessage(),e);
      }
 finally {
        if (reader != null) {
          try {
            reader.close();
          }
 catch (          IOException e) {
          }
        }
      }
      return ctx.getBatchManager().getActiveBatch().toRequest();
    }
  finally {
      ctx.setCurrentDir(currentDir);
      discardBatch(ctx,holdbackBatch);
      VFSUtils.safeClose(root,tempFileProvider);
    }
  }
  if (name == null) {
    throw new OperationFormatException("Deployment name is missing.");
  }
  final ModelControllerClient client=ctx.getModelControllerClient();
  DefaultOperationRequestBuilder builder;
  final List<String> deploymentNames;
  if (name.indexOf('*') < 0) {
    deploymentNames=Collections.singletonList(name);
  }
 else {
    deploymentNames=Util.getMatchingDeployments(client,name,null);
    if (deploymentNames.isEmpty()) {
      throw new CommandFormatException("No deployment matched wildcard expression " + name);
    }
  }
  for (  String deploymentName : deploymentNames) {
    final List<String> serverGroups;
    if (ctx.isDomainMode()) {
      if (allRelevantServerGroups) {
        if (keepContent) {
          serverGroups=Util.getAllEnabledServerGroups(deploymentName,client);
        }
 else {
          try {
            serverGroups=Util.getServerGroupsReferencingDeployment(deploymentName,client);
          }
 catch (          CommandLineException e) {
            throw new CommandFormatException("Failed to retrieve all referencing server groups",e);
          }
        }
      }
 else {
        if (serverGroupsStr == null) {
          serverGroups=Collections.emptyList();
        }
 else {
          serverGroups=Arrays.asList(serverGroupsStr.split(","));
        }
      }
      if (serverGroups.isEmpty()) {
        if (keepContent) {
          throw new OperationFormatException("None of the server groups is specified or references specified deployment.");
        }
      }
 else {
        for (        String group : serverGroups) {
          ModelNode groupStep=Util.configureDeploymentOperation(Util.UNDEPLOY,deploymentName,group);
          steps.add(groupStep);
          groupStep=Util.configureDeploymentOperation(Util.REMOVE,deploymentName,group);
          steps.add(groupStep);
        }
      }
    }
 else {
      if (Util.isDeployedAndEnabledInStandalone(deploymentName,client)) {
        builder=new DefaultOperationRequestBuilder();
        builder.setOperationName(Util.UNDEPLOY);
        builder.addNode(Util.DEPLOYMENT,deploymentName);
        steps.add(builder.buildRequest());
      }
    }
  }
  if (!keepContent) {
    for (    String deploymentName : deploymentNames) {
      builder=new DefaultOperationRequestBuilder();
      builder.setOperationName(Util.REMOVE);
      builder.addNode(Util.DEPLOYMENT,deploymentName);
      steps.add(builder.buildRequest());
    }
  }
  return composite;
}
