{
  super.doAnalyze();
  if (cls == String.class)   throw new IllegalArgumentException("Cannot analyze java.lang.String here: It is a " + "special case.");
  if (cls == Class.class)   throw new IllegalArgumentException("Cannot analyze java.lang.Class here: It is a " + "special case.");
  if (Remote.class.isAssignableFrom(cls))   throw new RMIIIOPViolationException("Value type " + cls.getName() + " cannot implement java.rmi.Remote.","1.2.4");
  if (cls.getName().indexOf('$') != -1)   throw new RMIIIOPNotImplementedException("Class " + cls.getName() + " has a '$', like "+ "proxies or inner classes.");
  externalizable=Externalizable.class.isAssignableFrom(cls);
  if (!externalizable) {
    Field spf=null;
    try {
      spf=cls.getField("serialPersistentFields");
    }
 catch (    NoSuchFieldException ex) {
    }
    if (spf != null) {
      int mods=spf.getModifiers();
      if (!Modifier.isFinal(mods) || !Modifier.isStatic(mods) || !Modifier.isPrivate(mods))       spf=null;
    }
    if (spf != null) {
      Class type=spf.getType();
      if (type.isArray()) {
        type=type.getComponentType();
        if (type != ObjectStreamField.class)         spf=null;
      }
 else       spf=null;
    }
    if (spf != null) {
      try {
        serialPersistentFields=(ObjectStreamField[])spf.get(null);
      }
 catch (      IllegalAccessException ex) {
        throw new RuntimeException("Unexpected IllegalException: " + ex.toString());
      }
      for (int i=0; i < fields.length; ++i) {
        if (fields[i] == spf) {
          f_flags[i]|=F_SPFFIELD;
          break;
        }
      }
    }
    Method wo=null;
    try {
      wo=cls.getMethod("writeObject",new Class[]{java.io.OutputStream[].class});
    }
 catch (    NoSuchMethodException ex) {
    }
    if (wo != null) {
      if (wo.getReturnType() != Void.TYPE)       wo=null;
    }
    if (wo != null) {
      int mods=spf.getModifiers();
      if (!Modifier.isPrivate(mods))       wo=null;
    }
    if (wo != null) {
      Class[] paramTypes=wo.getParameterTypes();
      if (paramTypes.length != 1)       wo=null;
 else       if (paramTypes[0] != java.io.OutputStream.class)       wo=null;
    }
    if (wo != null) {
      hasWriteObjectMethod=true;
      for (int i=0; i < methods.length; ++i) {
        if (methods[i] == wo) {
          m_flags[i]|=M_WRITEOBJECT;
          break;
        }
      }
    }
  }
  SortedSet m=new TreeSet(new ValueMemberComparator());
  logger.debug("ValueAnalysis(\"" + cls.getName() + "\"): "+ "fields.length="+ fields.length);
  for (int i=0; i < fields.length; ++i) {
    logger.debug("ValueAnalysis(\"" + cls.getName() + "\"): "+ "Considering field["+ i+ "] \""+ fields[i].getName()+ "\""+ " f_flags="+ f_flags[i]);
    if (f_flags[i] != 0)     continue;
    int mods=fields[i].getModifiers();
    logger.debug("ValueAnalysis(\"" + cls.getName() + "\"): mods="+ mods);
    if (Modifier.isStatic(mods) || Modifier.isTransient(mods))     continue;
    ValueMemberAnalysis vma;
    vma=new ValueMemberAnalysis(fields[i].getName(),fields[i].getType(),Modifier.isPublic(mods));
    m.add(vma);
  }
  members=new ValueMemberAnalysis[m.size()];
  members=(ValueMemberAnalysis[])m.toArray(members);
  logger.debug("ValueAnalysis(\"" + cls.getName() + "\") value member count: "+ members.length);
  Class superClass=cls.getSuperclass();
  if (superClass == java.lang.Object.class)   superClass=null;
  if (superClass == null)   superAnalysis=null;
 else {
    logger.debug("ValueAnalysis(\"" + cls.getName() + "\"): superclass: "+ superClass.getName());
    superAnalysis=getValueAnalysis(superClass);
  }
  if (!Serializable.class.isAssignableFrom(cls))   abstractValue=true;
  fixupCaseNames();
  logger.debug("ValueAnalysis(\"" + cls.getName() + "\") done.");
}
