{
  PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  String name=address.getLastElement().getValue();
  protocolStackSanityCheck(name,model);
  List<Property> orderedProtocols=getOrderedProtocolPropertyList(model);
  ModelNode transport=model.get(TransportResourceDefinition.PATH.getKeyValuePair());
  String type=ProtocolResourceDefinition.TYPE.resolveModelAttribute(context,transport).asString();
  ModuleIdentifier module=ModelNodes.asModuleIdentifier(ProtocolResourceDefinition.MODULE.resolveModelAttribute(context,transport));
  boolean shared=TransportResourceDefinition.SHARED.resolveModelAttribute(context,transport).asBoolean();
  Transport transportConfig=new Transport(type,module,shared);
  String machine=ModelNodes.asString(TransportResourceDefinition.MACHINE.resolveModelAttribute(context,transport));
  String rack=ModelNodes.asString(TransportResourceDefinition.RACK.resolveModelAttribute(context,transport));
  String site=ModelNodes.asString(TransportResourceDefinition.SITE.resolveModelAttribute(context,transport));
  transportConfig.setTopology(site,rack,machine);
  initProtocolProperties(context,transport,transportConfig);
  Relay relayConfig=null;
  List<Map.Entry<String,Injector<Channel>>> channels=new LinkedList<>();
  if (model.hasDefined(RelayResourceDefinition.PATH.getKey())) {
    ModelNode relay=model.get(RelayResourceDefinition.PATH.getKeyValuePair());
    String siteName=RelayResourceDefinition.SITE.resolveModelAttribute(context,relay).asString();
    relayConfig=new Relay(siteName);
    initProtocolProperties(context,relay,relayConfig);
    if (relay.hasDefined(RemoteSiteResourceDefinition.WILDCARD_PATH.getKey())) {
      List<RemoteSiteConfiguration> remoteSites=relayConfig.getRemoteSites();
      for (      Property remoteSiteProperty : relay.get(RemoteSiteResourceDefinition.WILDCARD_PATH.getKey()).asPropertyList()) {
        String remoteSiteName=remoteSiteProperty.getName();
        String channelName=RemoteSiteResourceDefinition.CHANNEL.resolveModelAttribute(context,remoteSiteProperty.getValue()).asString();
        RemoteSite remoteSite=new RemoteSite(remoteSiteName,channelName);
        remoteSites.add(remoteSite);
        channels.add(new AbstractMap.SimpleImmutableEntry<>(channelName,remoteSite.getChannelInjector()));
      }
    }
  }
  ProtocolStack stackConfig=new ProtocolStack(name,transportConfig,relayConfig);
  List<Map.Entry<Protocol,String>> protocolSocketBindings=new ArrayList<>(orderedProtocols.size());
  for (  Property protocolProperty : orderedProtocols) {
    ModelNode protocol=protocolProperty.getValue();
    type=ProtocolResourceDefinition.TYPE.resolveModelAttribute(context,protocol).asString();
    module=ModelNodes.asModuleIdentifier(ProtocolResourceDefinition.MODULE.resolveModelAttribute(context,protocol));
    Protocol protocolConfig=new Protocol(type,module);
    initProtocolProperties(context,protocol,protocolConfig);
    stackConfig.getProtocols().add(protocolConfig);
    String protocolSocketBinding=ModelNodes.asString(ProtocolResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,protocol));
    protocolSocketBindings.add(new AbstractMap.SimpleImmutableEntry<>(protocolConfig,protocolSocketBinding));
  }
  String timerExecutor=ModelNodes.asString(TransportResourceDefinition.TIMER_EXECUTOR.resolveModelAttribute(context,transport));
  String threadFactory=ModelNodes.asString(TransportResourceDefinition.THREAD_FACTORY.resolveModelAttribute(context,transport));
  String diagnosticsSocketBinding=ModelNodes.asString(TransportResourceDefinition.DIAGNOSTICS_SOCKET_BINDING.resolveModelAttribute(context,transport));
  String defaultExecutor=ModelNodes.asString(TransportResourceDefinition.DEFAULT_EXECUTOR.resolveModelAttribute(context,transport));
  String oobExecutor=ModelNodes.asString(TransportResourceDefinition.OOB_EXECUTOR.resolveModelAttribute(context,transport));
  String transportSocketBinding=ModelNodes.asString(ProtocolResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,transport));
  ServiceTarget target=context.getServiceTarget();
  ServiceBuilder<ChannelFactory> builder=target.addService(ChannelFactoryService.getServiceName(name),new ChannelFactoryService(stackConfig)).addDependency(ProtocolDefaultsService.SERVICE_NAME,ProtocolDefaults.class,stackConfig.getDefaultsInjector()).addDependency(ServerEnvironmentService.SERVICE_NAME,ServerEnvironment.class,stackConfig.getEnvironmentInjector()).addDependency(Services.JBOSS_SERVICE_MODULE_LOADER,ModuleLoader.class,stackConfig.getModuleLoaderInjector());
  addSocketBindingDependency(builder,transportSocketBinding,transportConfig.getSocketBindingInjector());
  for (  Map.Entry<Protocol,String> entry : protocolSocketBindings) {
    addSocketBindingDependency(builder,entry.getValue(),entry.getKey().getSocketBindingInjector());
  }
  addSocketBindingDependency(builder,diagnosticsSocketBinding,transportConfig.getDiagnosticsSocketBindingInjector());
  addExecutorDependency(builder,defaultExecutor,transportConfig.getDefaultExecutorInjector());
  addExecutorDependency(builder,oobExecutor,transportConfig.getOOBExecutorInjector());
  if (timerExecutor != null) {
    builder.addDependency(ThreadsServices.executorName(timerExecutor),ScheduledExecutorService.class,transportConfig.getTimerExecutorInjector());
  }
  if (threadFactory != null) {
    builder.addDependency(ThreadsServices.threadFactoryName(threadFactory),ThreadFactory.class,transportConfig.getThreadFactoryInjector());
  }
  for (  Map.Entry<String,Injector<Channel>> entry : channels) {
    builder.addDependency(ChannelService.getServiceName(entry.getKey()),Channel.class,entry.getValue());
  }
  builder.setInitialMode(ServiceController.Mode.ON_DEMAND).install();
  new BinderServiceBuilder(target).build(ChannelFactoryService.createChannelFactoryBinding(name),ChannelFactoryService.getServiceName(name),ChannelFactory.class).install();
}
