{
  final String patchId=PatchResourceDefinition.PATCH_ID.resolveModelAttribute(context,operation).asString();
  final boolean rollbackTo=PatchResourceDefinition.ROLLBACK_TO.resolveModelAttribute(context,operation).asBoolean();
  final boolean restoreConfiguration=PatchResourceDefinition.RESTORE_CONFIGURATION.resolveModelAttribute(context,operation).asBoolean();
  context.acquireControllerLock();
  final InstallationManager installationManager=(InstallationManager)context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME).getValue();
  final PatchTool runner=PatchTool.Factory.create(installationManager);
  final ContentVerificationPolicy policy=PatchTool.Factory.create(operation);
  try {
    final PatchingResult result=runner.rollback(patchId,policy,rollbackTo,restoreConfiguration);
    context.restartRequired();
    context.completeStep(new OperationContext.ResultHandler(){
      @Override public void handleResult(      OperationContext.ResultAction resultAction,      OperationContext context,      ModelNode operation){
        if (resultAction == OperationContext.ResultAction.KEEP) {
          result.commit();
        }
 else {
          context.revertRestartRequired();
          result.rollback();
        }
      }
    }
);
  }
 catch (  PatchingException e) {
    if (e.hasConflicts()) {
      final ModelNode failureDescription=context.getFailureDescription();
      for (      final ContentItem item : e.getConflicts()) {
        final ContentType type=item.getContentType();
switch (type) {
case BUNDLE:
          failureDescription.get(Constants.BUNDLES).add(item.getRelativePath());
        break;
case MODULE:
      failureDescription.get(Constants.MODULES).add(item.getRelativePath());
    break;
case MISC:
  failureDescription.get(Constants.MISC).add(item.getRelativePath());
break;
}
}
context.stepCompleted();
}
 else {
throw new OperationFailedException(e.getMessage(),e);
}
}
 finally {
}
}
