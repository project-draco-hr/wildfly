{
  Flag flag=Flag.FORCE_SYNCHRONOUS;
  Throwable expectedException=new TimeoutException();
  Object expected=new Object();
  Configuration config=new ConfigurationBuilder().transaction().transactionMode(TransactionMode.TRANSACTIONAL).build();
  when(this.cache.getAdvancedCache()).thenReturn(this.cache);
  when(this.cache.getCacheConfiguration()).thenReturn(config);
  when(this.cache.getTransactionManager()).thenReturn(this.tm);
  when(this.tm.getStatus()).thenReturn(status);
  when(this.invoker.invoke(this.cache,this.operation,flag)).thenThrow(expectedException).thenReturn(expected);
  try {
    Object result=this.subject.invoke(this.cache,this.operation,flag);
    if (allowsRetry) {
      assertSame(expected,result);
    }
 else {
      fail("Retry should not have been allowed for tx status: " + status);
    }
  }
 catch (  RuntimeException e) {
    if (!allowsRetry) {
      assertSame(expectedException,e);
    }
 else {
      fail("Retry should have been allowed for tx status: " + status);
    }
  }
}
