{
  long start=0;
  long settleTime=100;
  while (outstanding > 0 || (settleTime > 0 && !problem.isEmpty())) {
    try {
      long wait=outstanding > 0 ? 0 : settleTime;
      wait(wait);
      if (outstanding == 0) {
        if (start == 0) {
          start=System.currentTimeMillis();
        }
 else {
          settleTime-=System.currentTimeMillis() - start;
        }
      }
 else {
        start=0;
        settleTime=100;
      }
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      context.getFailureDescription().set(MESSAGES.operationCancelled());
      context.completeStep();
      return;
    }
  }
  if (!failed.isEmpty() || !problem.isEmpty()) {
    final ModelNode failureDescription=context.getFailureDescription();
    ModelNode failedList=null;
    for (    ServiceController<?> controller : failed) {
      if (failedList == null) {
        failedList=failureDescription.get(MESSAGES.failedServices());
      }
      failedList.get(controller.getName().getCanonicalName()).set(getServiceFailureDescription(controller.getStartException()));
    }
    ModelNode problemList=null;
    for (    ServiceController<?> controller : problem) {
      if (problemList == null) {
        problemList=failureDescription.get(MESSAGES.servicesMissingDependencies());
      }
      final StringBuilder problem=new StringBuilder();
      problem.append(controller.getName().getCanonicalName());
      final StringBuilder missing=new StringBuilder();
      Set<ServiceName> immediatelyUnavailable=controller.getImmediateUnavailableDependencies();
      if (!immediatelyUnavailable.isEmpty()) {
        for (Iterator<ServiceName> i=immediatelyUnavailable.iterator(); i.hasNext(); ) {
          ServiceName missingSvc=i.next();
          missing.append(missingSvc.getCanonicalName());
          if (i.hasNext()) {
            missing.append(", ");
          }
        }
      }
 else {
        missing.append(MESSAGES.transitiveDependencies());
      }
      problem.append(" ").append(MESSAGES.servicesMissing(missing));
      problemList.add(problem.toString());
    }
    if (context.isRollbackOnRuntimeFailure()) {
      context.setRollbackOnly();
    }
  }
  for (  ServiceController<?> controller : set) {
    controller.removeListener(this);
  }
  context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
