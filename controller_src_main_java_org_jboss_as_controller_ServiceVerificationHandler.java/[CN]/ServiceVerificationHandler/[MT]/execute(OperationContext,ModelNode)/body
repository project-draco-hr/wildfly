{
  final Set<ServiceController<?>> failed=new HashSet<ServiceController<?>>();
  final Set<ServiceController<?>> problems=new HashSet<ServiceController<?>>();
  try {
    monitor.awaitStability(failed,problems);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    context.getFailureDescription().set(ControllerLogger.ROOT_LOGGER.operationCancelled());
    context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
    return;
  }
 finally {
    monitor.clear();
  }
  if (!failed.isEmpty() || !problems.isEmpty()) {
    Set<ServiceController<?>> missingTransitive=null;
    Set<ServiceName> trackedServices=new HashSet<ServiceName>();
    final ModelNode failureDescription=context.getFailureDescription();
    ModelNode failedList=null;
    for (    ServiceController<?> controller : failed) {
      if (failedList == null) {
        failedList=failureDescription.get(ControllerLogger.ROOT_LOGGER.failedServices());
      }
      ServiceName serviceName=controller.getName();
      trackedServices.add(serviceName);
      failedList.get(serviceName.getCanonicalName()).set(getServiceFailureDescription(controller.getStartException()));
    }
    ModelNode problemList=null;
    for (    ServiceController<?> controller : problems) {
      Set<ServiceName> immediatelyUnavailable=controller.getImmediateUnavailableDependencies();
      if (!immediatelyUnavailable.isEmpty()) {
        if (problemList == null) {
          problemList=failureDescription.get(ControllerLogger.ROOT_LOGGER.servicesMissingDependencies());
        }
        StringBuilder missing=new StringBuilder();
        for (Iterator<ServiceName> i=immediatelyUnavailable.iterator(); i.hasNext(); ) {
          ServiceName missingSvc=i.next();
          trackedServices.add(missingSvc);
          missing.append(missingSvc.getCanonicalName());
          if (i.hasNext()) {
            missing.append(", ");
          }
        }
        final StringBuilder problem=new StringBuilder();
        problem.append(controller.getName().getCanonicalName());
        problem.append(" ").append(ControllerLogger.ROOT_LOGGER.servicesMissing(missing));
        problemList.add(problem.toString());
      }
 else {
        if (missingTransitive == null) {
          missingTransitive=new HashSet<ServiceController<?>>();
        }
        missingTransitive.add(controller);
      }
    }
    if (missingTransitive != null) {
      SortedSet<ServiceName> allMissing=findAllMissingServices(missingTransitive,trackedServices);
      if (!allMissing.isEmpty()) {
        ModelNode missingTransitiveDesc=failureDescription.get(ControllerLogger.ROOT_LOGGER.missingTransitiveDependencyProblem());
        ModelNode missingTransitiveDeps=missingTransitiveDesc.get(ControllerLogger.ROOT_LOGGER.missingTransitiveDependents());
        Set<ServiceName> sortedNames=new TreeSet<ServiceName>();
        for (        ServiceController<?> serviceController : missingTransitive) {
          sortedNames.add(serviceController.getName());
        }
        for (        ServiceName serviceName : sortedNames) {
          missingTransitiveDeps.add(serviceName.getCanonicalName());
        }
        ModelNode allMissingList=missingTransitiveDesc.get(ControllerLogger.ROOT_LOGGER.missingTransitiveDependencies());
        for (        ServiceName serviceName : allMissing) {
          allMissingList.add(serviceName.getCanonicalName());
        }
      }
    }
    if (context.isRollbackOnRuntimeFailure()) {
      context.setRollbackOnly();
    }
  }
  context.stepCompleted();
}
