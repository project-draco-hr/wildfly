{
  final Resource resource=context.createResource(PathAddress.EMPTY_ADDRESS);
  populateModel(context,operation,resource);
  final ModelNode model=resource.getModel();
  boolean stepCompleted=false;
  if (context.isNormalServer()) {
    final Boolean enabled=SCAN_ENABLED.resolveModelAttribute(context,operation).asBoolean();
    final boolean bootTimeScan=context.isBooting() && (enabled == null || enabled == true);
    final String path=DeploymentScannerDefinition.PATH.resolveModelAttribute(context,operation).asString();
    final ModelNode relativeToNode=RELATIVE_TO.resolveModelAttribute(context,operation);
    final String relativeTo=relativeToNode.isDefined() ? relativeToNode.asString() : null;
    final Boolean autoDeployZip=AUTO_DEPLOY_ZIPPED.resolveModelAttribute(context,operation).asBoolean();
    final Boolean autoDeployExp=AUTO_DEPLOY_EXPLODED.resolveModelAttribute(context,operation).asBoolean();
    final Boolean autoDeployXml=AUTO_DEPLOY_XML.resolveModelAttribute(context,operation).asBoolean();
    final Long deploymentTimeout=DEPLOYMENT_TIMEOUT.resolveModelAttribute(context,operation).asLong();
    final Integer scanInterval=SCAN_INTERVAL.resolveModelAttribute(context,operation).asInt();
    final ThreadFactory threadFactory=new JBossThreadFactory(new ThreadGroup("DeploymentScanner-threads"),Boolean.FALSE,null,"%G - %t",null,null,AccessController.getContext());
    final ScheduledExecutorService scheduledExecutorService=Executors.newScheduledThreadPool(2,threadFactory);
    final FileSystemDeploymentService bootTimeScanner;
    if (bootTimeScan) {
      final String pathName=pathManager.resolveRelativePathEntry(path,relativeTo);
      File relativePath=null;
      if (relativeTo != null) {
        relativePath=new File(pathManager.getPathEntry(relativeTo).resolvePath());
      }
      bootTimeScanner=new FileSystemDeploymentService(relativeTo,new File(pathName),relativePath,null,scheduledExecutorService);
      bootTimeScanner.setAutoDeployExplodedContent(autoDeployExp);
      bootTimeScanner.setAutoDeployZippedContent(autoDeployZip);
      bootTimeScanner.setAutoDeployXMLContent(autoDeployXml);
      if (deploymentTimeout != null) {
        bootTimeScanner.setDeploymentTimeout(deploymentTimeout);
      }
      if (scanInterval != null) {
        bootTimeScanner.setScanInterval(scanInterval);
      }
    }
 else {
      bootTimeScanner=null;
    }
    context.addStep(new OperationStepHandler(){
      public void execute(      final OperationContext context,      final ModelNode operation) throws OperationFailedException {
        final List<ServiceController<?>> controllers=new ArrayList<ServiceController<?>>();
        final ServiceVerificationHandler verificationHandler=new ServiceVerificationHandler();
        performRuntime(context,operation,model,verificationHandler,controllers,scheduledExecutorService,bootTimeScanner);
        context.addStep(verificationHandler,OperationContext.Stage.VERIFY);
        context.completeStep(new OperationContext.RollbackHandler(){
          @Override public void handleRollback(          OperationContext context,          ModelNode operation){
            rollbackRuntime(context,operation,model,controllers);
          }
        }
);
      }
    }
,OperationContext.Stage.RUNTIME);
    if (bootTimeScan) {
      final AtomicReference<ModelNode> deploymentOperation=new AtomicReference<ModelNode>();
      final AtomicReference<ModelNode> deploymentResults=new AtomicReference<ModelNode>();
      final CountDownLatch scanDoneLatch=new CountDownLatch(1);
      final CountDownLatch deploymentDoneLatch=new CountDownLatch(1);
      final DeploymentOperations deploymentOps=new BootTimeScannerDeployment(deploymentOperation,deploymentDoneLatch,deploymentResults,scanDoneLatch);
      scheduledExecutorService.submit(new Runnable(){
        @Override public void run(){
          try {
            bootTimeScanner.oneOffScan(deploymentOps);
          }
 catch (          Throwable t) {
            DeploymentScannerLogger.ROOT_LOGGER.initialScanFailed(t);
          }
 finally {
            scanDoneLatch.countDown();
          }
        }
      }
);
      boolean interrupted=false;
      try {
        scanDoneLatch.await();
        final ModelNode op=deploymentOperation.get();
        if (op != null) {
          final ModelNode result=new ModelNode();
          final PathAddress opPath=PathAddress.pathAddress(op.get(OP_ADDR));
          final OperationStepHandler handler=context.getRootResourceRegistration().getOperationHandler(opPath,op.get(OP).asString());
          context.addStep(result,op,handler,OperationContext.Stage.MODEL);
          try {
            stepCompleted=true;
            context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
          }
  finally {
            deploymentResults.set(result);
            deploymentDoneLatch.countDown();
          }
        }
 else {
          stepCompleted=true;
          context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
        }
      }
 catch (      InterruptedException e) {
        interrupted=true;
        throw new RuntimeException(e);
      }
 finally {
        deploymentDoneLatch.countDown();
        if (interrupted) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
  if (!stepCompleted) {
    context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
  }
}
