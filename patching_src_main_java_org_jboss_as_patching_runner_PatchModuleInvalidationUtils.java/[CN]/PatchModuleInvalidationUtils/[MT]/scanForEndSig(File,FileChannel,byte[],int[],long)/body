{
  ByteBuffer bb=getByteBuffer(CHUNK_SIZE);
  long start=channel.size();
  long end=Math.max(0,start - MAX_REVERSE_SCAN);
  long channelPos=Math.max(0,start - CHUNK_SIZE);
  long lastChannelPos=channelPos;
  while (lastChannelPos >= end) {
    read(bb,channel,channelPos);
    int actualRead=bb.limit();
    int bufferPos=actualRead - 1;
    while (bufferPos >= SIG_PATTERN_LENGTH) {
      int patternPos;
      for (patternPos=SIG_PATTERN_LENGTH - 1; patternPos >= 0 && pattern[patternPos] == bb.get(bufferPos - patternPos); --patternPos) {
      }
switch (patternPos) {
case -1:
{
          long startEndRecord=channelPos + bufferPos - SIG_PATTERN_LENGTH + 1;
          if (validateEndRecord(file,channel,startEndRecord,endSig)) {
            return startEndRecord;
          }
          bufferPos-=4;
          break;
        }
case 3:
{
        int idx=bb.get(bufferPos - patternPos) - Byte.MIN_VALUE;
        bufferPos-=byteSkip[idx];
        break;
      }
default :
    bufferPos-=4;
}
}
if (channelPos <= bufferPos) {
break;
}
lastChannelPos=channelPos;
channelPos-=Math.min(channelPos - bufferPos,CHUNK_SIZE - bufferPos);
}
return -1;
}
