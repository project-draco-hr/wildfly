{
  validator.validate(operation);
  final String opName=operation.require(OP).asString();
  final ModelNode opAddr=operation.get(OP_ADDR);
  final PathAddress address=PathAddress.pathAddress(opAddr);
  final int recursiveDepth=operation.get(ModelDescriptionConstants.RECURSIVE_DEPTH).asInt(0);
  final boolean recursive=recursiveDepth > 0 ? true : operation.get(ModelDescriptionConstants.RECURSIVE).asBoolean(false);
  final boolean queryRuntime=operation.get(ModelDescriptionConstants.INCLUDE_RUNTIME).asBoolean(false);
  final boolean proxies=operation.get(ModelDescriptionConstants.PROXIES).asBoolean(false);
  final boolean aliases=operation.get(ModelDescriptionConstants.INCLUDE_ALIASES).asBoolean(false);
  final boolean defaults=operation.get(ModelDescriptionConstants.INCLUDE_DEFAULTS).asBoolean(true);
  final boolean attributesOnly=operation.get(ModelDescriptionConstants.ATTRIBUTES_ONLY).asBoolean(false);
  final Map<String,ModelNode> directAttributes=new HashMap<String,ModelNode>();
  final Map<String,ModelNode> directChildren=new HashMap<String,ModelNode>();
  final Map<String,ModelNode> metrics=queryRuntime ? new HashMap<String,ModelNode>() : Collections.<String,ModelNode>emptyMap();
  final Map<String,ModelNode> otherAttributes=new HashMap<String,ModelNode>();
  final Map<PathElement,ModelNode> childResources=recursive ? new LinkedHashMap<PathElement,ModelNode>() : Collections.<PathElement,ModelNode>emptyMap();
  final ReadResourceAssemblyHandler assemblyHandler=new ReadResourceAssemblyHandler(directAttributes,metrics,otherAttributes,directChildren,childResources);
  context.addStep(assemblyHandler,queryRuntime ? OperationContext.Stage.VERIFY : OperationContext.Stage.MODEL,true);
  final ImmutableManagementResourceRegistration registry=context.getResourceRegistration();
  final Resource resource=nullSafeReadResource(context,registry);
  final Map<String,Set<String>> childrenByType=registry != null ? GlobalOperationHandlers.getChildAddresses(context,address,registry,resource,null) : Collections.<String,Set<String>>emptyMap();
  final ModelNode model=resource.getModel();
  if (model.isDefined()) {
    for (    String key : model.keys()) {
      if (!childrenByType.containsKey(key)) {
        directAttributes.put(key,model.get(key));
      }
    }
  }
  if (defaults) {
    final DescriptionProvider descriptionProvider=registry.getModelDescription(PathAddress.EMPTY_ADDRESS);
    final Locale locale=GlobalOperationHandlers.getLocale(context,operation);
    final ModelNode nodeDescription=descriptionProvider.getModelDescription(locale);
    if (nodeDescription.isDefined() && nodeDescription.hasDefined(ATTRIBUTES)) {
      for (      String key : nodeDescription.get(ATTRIBUTES).keys()) {
        if ((!childrenByType.containsKey(key)) && (!directAttributes.containsKey(key) || !directAttributes.get(key).isDefined()) && nodeDescription.get(ATTRIBUTES).hasDefined(key)&& nodeDescription.get(ATTRIBUTES,key).hasDefined(DEFAULT)) {
          directAttributes.put(key,nodeDescription.get(ATTRIBUTES,key,DEFAULT));
        }
      }
    }
  }
  if (!attributesOnly) {
    for (    Map.Entry<String,Set<String>> entry : childrenByType.entrySet()) {
      String childType=entry.getKey();
      Set<String> children=entry.getValue();
      if (children.isEmpty()) {
        directAttributes.put(childType,new ModelNode());
      }
 else {
        for (        String child : children) {
          if (recursive) {
            PathElement childPE=PathElement.pathElement(childType,child);
            PathAddress relativeAddr=PathAddress.pathAddress(childPE);
            ImmutableManagementResourceRegistration childReg=registry.getSubModel(relativeAddr);
            if (childReg == null) {
              throw new OperationFailedException(new ModelNode().set(MESSAGES.noChildRegistry(childType,child)));
            }
            boolean proxy=childReg.isRemote();
            boolean runtimeResource=childReg.isRuntimeOnly();
            boolean getChild=!runtimeResource || (queryRuntime && !proxy) || (proxies && proxy);
            if (!aliases && childReg.isAlias()) {
              getChild=false;
            }
            if (getChild) {
              final int newDepth=recursiveDepth > 0 ? recursiveDepth - 1 : 0;
              ModelNode rrOp=new ModelNode();
              rrOp.get(OP).set(opName);
              rrOp.get(OP_ADDR).set(PathAddress.pathAddress(address,childPE).toModelNode());
              rrOp.get(ModelDescriptionConstants.RECURSIVE).set(operation.get(ModelDescriptionConstants.RECURSIVE));
              rrOp.get(ModelDescriptionConstants.RECURSIVE_DEPTH).set(newDepth);
              rrOp.get(ModelDescriptionConstants.PROXIES).set(proxies);
              rrOp.get(ModelDescriptionConstants.INCLUDE_RUNTIME).set(queryRuntime);
              rrOp.get(ModelDescriptionConstants.INCLUDE_ALIASES).set(aliases);
              rrOp.get(ModelDescriptionConstants.INCLUDE_DEFAULTS).set(defaults);
              ModelNode rrRsp=new ModelNode();
              childResources.put(childPE,rrRsp);
              OperationStepHandler rrHandler=childReg.getOperationHandler(PathAddress.EMPTY_ADDRESS,opName);
              context.addStep(rrRsp,rrOp,rrHandler,OperationContext.Stage.MODEL,true);
            }
          }
 else {
            ModelNode childMap=directChildren.get(childType);
            if (childMap == null) {
              childMap=new ModelNode();
              childMap.setEmptyObject();
              directChildren.put(childType,childMap);
            }
            childMap.get(child);
          }
        }
      }
    }
  }
  final Set<String> attributeNames=registry != null ? registry.getAttributeNames(PathAddress.EMPTY_ADDRESS) : Collections.<String>emptySet();
  for (  final String attributeName : attributeNames) {
    final AttributeAccess access=registry.getAttributeAccess(PathAddress.EMPTY_ADDRESS,attributeName);
    if (access == null || access.getFlags().contains(AttributeAccess.Flag.ALIAS) && !aliases) {
      continue;
    }
 else {
      final AttributeAccess.Storage storage=access.getStorageType();
      if (!queryRuntime && storage != AttributeAccess.Storage.CONFIGURATION) {
        continue;
      }
      final AttributeAccess.AccessType type=access.getAccessType();
      final OperationStepHandler handler=access.getReadHandler();
      if (handler != null) {
        directAttributes.remove(attributeName);
        final ModelNode attributeOperation=new ModelNode();
        attributeOperation.get(OP_ADDR).set(opAddr);
        attributeOperation.get(OP).set(READ_ATTRIBUTE_OPERATION);
        attributeOperation.get(GlobalOperationHandlers.NAME.getName()).set(attributeName);
        final ModelNode attrResponse=new ModelNode();
        if (type == AttributeAccess.AccessType.METRIC) {
          metrics.put(attributeName,attrResponse);
        }
 else {
          otherAttributes.put(attributeName,attrResponse);
        }
        context.addStep(attrResponse,attributeOperation,handler,OperationContext.Stage.MODEL,true);
      }
    }
  }
  context.stepCompleted();
}
