{
  final EJBLocator locator=invocation.getLocator();
  final EjbDeploymentInformation ejb=findBean(locator.getAppName(),locator.getModuleName(),locator.getDistinctName(),locator.getBeanName());
  final EJBComponent ejbComponent=ejb.getEjbComponent();
  final Class<?> viewClass=invocation.getViewClass();
  final ComponentView view=ejb.getView(viewClass.getName());
  if (view == null) {
    throw MESSAGES.viewNotFound(viewClass.getName(),ejb.getEjbName());
  }
  if (!ejb.isRemoteView(viewClass.getName())) {
    throw MESSAGES.viewNotFound(viewClass.getName(),ejb.getEjbName());
  }
  final ClonerConfiguration paramConfig=new ClonerConfiguration();
  paramConfig.setClassCloner(new ClassLoaderClassCloner(ejb.getDeploymentClassLoader()));
  final ObjectCloner parameterCloner=ObjectCloners.getSerializingObjectClonerFactory().createCloner(paramConfig);
  final Method method=view.getMethod(invocation.getInvokedMethod().getName(),DescriptorUtils.methodDescriptor(invocation.getInvokedMethod()));
  final boolean async=view.isAsynchronous(method);
  final Object[] parameters;
  if (invocation.getParameters() == null) {
    parameters=EMPTY_OBJECT_ARRAY;
  }
 else {
    parameters=new Object[invocation.getParameters().length];
    for (int i=0; i < parameters.length; ++i) {
      parameters[i]=clone(method.getParameterTypes()[i],parameterCloner,invocation.getParameters()[i],allowPassByReference);
    }
  }
  final InterceptorContext interceptorContext=new InterceptorContext();
  interceptorContext.setParameters(parameters);
  interceptorContext.setMethod(method);
  interceptorContext.setTarget(invocation.getInvokedProxy());
  final Map<Object,Object> privateAttachments=invocation.getAttachments();
  final Map<String,Object> invocationContextData=invocation.getContextData();
  if (invocationContextData == null && privateAttachments.isEmpty()) {
    interceptorContext.setContextData(new HashMap<String,Object>());
  }
 else {
    final Map<String,Object> data=new HashMap<String,Object>();
    interceptorContext.setContextData(data);
    for (    Map.Entry<String,Object> entry : invocationContextData.entrySet()) {
      data.put(entry.getKey(),entry.getValue());
    }
    if (!privateAttachments.isEmpty()) {
      data.put(EJBClientInvocationContext.PRIVATE_ATTACHMENTS_KEY,privateAttachments);
    }
    final boolean txIdAttachmentPresent=privateAttachments.containsKey(AttachmentKeys.TRANSACTION_ID_KEY);
    if (txIdAttachmentPresent) {
      data.put(TransactionID.PRIVATE_DATA_KEY,privateAttachments.get(AttachmentKeys.TRANSACTION_ID_KEY));
    }
  }
  interceptorContext.putPrivateData(Component.class,ejbComponent);
  interceptorContext.putPrivateData(ComponentView.class,view);
  if (locator instanceof StatefulEJBLocator) {
    final SessionID sessionID=((StatefulEJBLocator)locator).getSessionId();
    interceptorContext.putPrivateData(SessionID.class,sessionID);
  }
 else   if (locator instanceof EntityEJBLocator) {
    final Object primaryKey=((EntityEJBLocator)locator).getPrimaryKey();
    interceptorContext.putPrivateData(EntityBeanComponent.PRIMARY_KEY_CONTEXT_KEY,primaryKey);
  }
  final ClonerConfiguration config=new ClonerConfiguration();
  config.setClassCloner(new LocalInvocationClassCloner(invocation.getInvokedProxy().getClass().getClassLoader()));
  final ObjectCloner resultCloner=ObjectCloners.getSerializingObjectClonerFactory().createCloner(config);
  if (async) {
    if (ejbComponent instanceof SessionBeanComponent) {
      final SessionBeanComponent component=(SessionBeanComponent)ejbComponent;
      final CancellationFlag flag=new CancellationFlag();
      final SecurityContext securityContext=SecurityContextAssociation.getSecurityContext();
      final AsyncInvocationTask task=new AsyncInvocationTask(flag){
        @Override protected Object runInvocation() throws Exception {
          setSecurityContextOnAssociation(securityContext);
          try {
            return view.invoke(interceptorContext);
          }
  finally {
            clearSecurityContextOnAssociation();
          }
        }
      }
;
      interceptorContext.putPrivateData(CancellationFlag.class,flag);
      component.getAsynchronousExecutor().submit(task);
      receiverContext.resultReady(new ImmediateResultProducer(task));
    }
 else {
      throw MESSAGES.asyncInvocationOnlyApplicableForSessionBeans();
    }
  }
 else {
    final Object result;
    try {
      result=view.invoke(interceptorContext);
    }
 catch (    Exception e) {
      throw (Exception)clone(resultCloner,e);
    }
    final Object clonedResult=clone(invocation.getInvokedMethod().getReturnType(),resultCloner,result,allowPassByReference);
    receiverContext.resultReady(new ImmediateResultProducer(clonedResult));
  }
}
