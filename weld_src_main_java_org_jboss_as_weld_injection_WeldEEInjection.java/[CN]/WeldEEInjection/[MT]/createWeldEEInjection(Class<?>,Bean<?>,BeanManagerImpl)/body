{
  final AnnotatedType<?> type=beanManager.getServices().get(ClassTransformer.class).loadClass(componentClass);
  List<InjectableField> injectableFields=new ArrayList<InjectableField>();
  List<InjectableMethod> injectableMethods=new ArrayList<InjectableMethod>();
  AnnotatedConstructor<?> injectConstructor=null;
  for (  AnnotatedConstructor<?> constructor : type.getConstructors()) {
    if (constructor.isAnnotationPresent(Inject.class)) {
      if (injectConstructor != null) {
        throw new RuntimeException("Class " + componentClass + " has more that one constructor annotated with @Inject");
      }
      injectConstructor=constructor;
    }
  }
  InjectableConstructor constructor=null;
  if (injectConstructor != null) {
    constructor=new InjectableConstructor(injectConstructor,beanManager,bean);
  }
  final InjectionTarget injectionTarget;
  if (bean instanceof AbstractClassBean) {
    injectionTarget=((AbstractClassBean)bean).getInjectionTarget();
  }
 else {
    injectionTarget=null;
    for (    AnnotatedField<?> field : type.getFields()) {
      if (field.isAnnotationPresent(Inject.class)) {
        if (InjectionPoint.class.isAssignableFrom(field.getJavaMember().getType())) {
          throw new RuntimeException("Component " + componentClass + " is attempting to inject the InjectionPoint into a field: "+ field.getJavaMember());
        }
        final Set<Annotation> qualifiers=new HashSet<Annotation>();
        for (        Annotation annotation : field.getAnnotations()) {
          if (beanManager.isQualifier(annotation.annotationType())) {
            qualifiers.add(annotation);
          }
        }
        FieldInjectionPoint ip=new FieldInjectionPoint(field,qualifiers,bean);
        Set<Bean<?>> beans=beanManager.getBeans(ip);
        Bean<?> ipBean=beanManager.resolve(beans);
        if (ipBean == null) {
          throw new RuntimeException("Could not resolve CDI bean for injection point " + field.getJavaMember() + " with qualifiers "+ qualifiers);
        }
        injectableFields.add(new InjectableField(field.getJavaMember(),ipBean,ip));
      }
    }
    for (    AnnotatedMethod<?> method : type.getMethods()) {
      if (method.isAnnotationPresent(Inject.class)) {
        final List<Bean<?>> parameterBeans=new ArrayList<Bean<?>>();
        final List<InjectionPoint> ips=new ArrayList<InjectionPoint>();
        for (        AnnotatedParameter<?> param : method.getParameters()) {
          final Set<Annotation> qualifiers=new HashSet<Annotation>();
          for (          Annotation annotation : param.getAnnotations()) {
            if (beanManager.isQualifier(annotation.annotationType())) {
              qualifiers.add(annotation);
            }
          }
          final Class<?> parameterType=method.getJavaMember().getParameterTypes()[param.getPosition()];
          if (InjectionPoint.class.isAssignableFrom(parameterType)) {
            throw new RuntimeException("Component " + componentClass + " is attempting to inject the InjectionPoint into a method on a component that is not a CDI bean "+ method.getJavaMember());
          }
          ParameterInjectionPoint ip=new ParameterInjectionPoint(param,qualifiers,bean);
          Set<Bean<?>> beans=beanManager.getBeans(ip);
          Bean<?> ipBean=beanManager.resolve(beans);
          if (ipBean == null) {
            throw new RuntimeException("Could not resolve CDI bean for injection point " + param + " with qualifiers "+ qualifiers);
          }
          parameterBeans.add(ipBean);
          ips.add(ip);
        }
        injectableMethods.add(new InjectableMethod(method.getJavaMember(),parameterBeans,ips));
      }
    }
  }
  return new WeldEEInjection(componentClass,beanManager,injectableFields,injectableMethods,constructor,injectionTarget);
}
