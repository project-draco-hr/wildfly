{
  SubsystemState stateService=new SubsystemState();
  List<OperationStepHandler> addedSteps=new ArrayList<OperationStepHandler>();
  OperationContext context=mockOperationContext(stateService,addedSteps,OperationContext.ResultAction.KEEP);
  ModelNode address=new ModelNode();
  address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM,OSGiExtension.SUBSYSTEM_NAME));
  address.add(new ModelNode().set(CommonAttributes.CONFIGURATION,"org.acme.pid1"));
  ModelNode data=new ModelNode();
  ModelNode entries=new ModelNode();
  entries.get("mykey").set("myval");
  data.get(CommonAttributes.ENTRIES).set(entries);
  ModelNode op=OSGiCasConfigAdd.getAddOperation(address,data);
  Assert.assertEquals("Precondition",0,addedSteps.size());
  OSGiCasConfigAdd.INSTANCE.execute(context,op);
  Assert.assertEquals(1,addedSteps.size());
  Assert.assertEquals("Precondition",0,stateService.getConfigurations().size());
  addedSteps.get(0).execute(context,op);
  Assert.assertEquals(1,stateService.getConfigurations().size());
  Dictionary<String,String> config=stateService.getConfiguration("org.acme.pid1");
  Assert.assertEquals(1,config.size());
  Assert.assertEquals("myval",config.get("mykey"));
  OSGiCasConfigRemove.INSTANCE.execute(context,op);
  Assert.assertEquals("Actual remove added as async step",2,addedSteps.size());
  Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);
  addedSteps.get(1).execute(context,op);
  Assert.assertEquals("Configuration should have been kept as the operation was rolled back",1,stateService.getConfiguration("org.acme.pid1").size());
  Assert.assertEquals("Configuration should have been kept as the operation was rolled back","myval",stateService.getConfiguration("org.acme.pid1").get("mykey"));
  Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);
  addedSteps.get(1).execute(context,op);
  Assert.assertNull("Configuration should have been removed",stateService.getConfiguration("org.acme.pid1"));
}
