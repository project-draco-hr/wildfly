{
  SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(ModelController.ACCESS_PERMISSION);
  }
  return new ModelControllerClient(){
    @Override public void close() throws IOException {
    }
    @Override public ModelNode execute(    ModelNode operation) throws IOException {
      return execute(operation,null);
    }
    @Override public ModelNode execute(    Operation operation) throws IOException {
      return execute(operation,null);
    }
    @Override public ModelNode execute(    final ModelNode operation,    final OperationMessageHandler messageHandler){
      return ModelControllerImpl.this.execute(operation,messageHandler,OperationTransactionControl.COMMIT,null);
    }
    @Override public ModelNode execute(    Operation operation,    OperationMessageHandler messageHandler) throws IOException {
      return ModelControllerImpl.this.execute(operation.getOperation(),messageHandler,OperationTransactionControl.COMMIT,operation);
    }
    @Override public AsyncFuture<ModelNode> executeAsync(    ModelNode operation,    OperationMessageHandler messageHandler){
      return executeAsync(operation,messageHandler,null);
    }
    @Override public AsyncFuture<ModelNode> executeAsync(    final Operation operation,    final OperationMessageHandler messageHandler){
      return executeAsync(operation.getOperation(),messageHandler,operation);
    }
    private AsyncFuture<ModelNode> executeAsync(    final ModelNode operation,    final OperationMessageHandler messageHandler,    final OperationAttachments attachments){
      if (executor == null) {
        throw MESSAGES.nullAsynchronousExecutor();
      }
      final AtomicReference<Thread> opThread=new AtomicReference<Thread>();
class OpTask extends AsyncFutureTask<ModelNode> {
        OpTask(){
          super(executor);
        }
        public void asyncCancel(        final boolean interruptionDesired){
          Thread thread=opThread.getAndSet(Thread.currentThread());
          if (thread == null) {
            setCancelled();
          }
 else {
            thread.interrupt();
            boolean interrupted=false;
synchronized (opThread) {
              while (opThread.get() != null) {
                try {
                  opThread.wait();
                }
 catch (                InterruptedException ie) {
                  interrupted=true;
                }
              }
            }
            setCancelled();
            if (interrupted) {
              Thread.currentThread().interrupt();
            }
          }
        }
        void handleResult(        final ModelNode result){
          if (result != null && result.hasDefined(OUTCOME) && CANCELLED.equals(result.get(OUTCOME).asString())) {
            setCancelled();
          }
 else {
            setResult(result);
          }
        }
      }
      final OpTask opTask=new OpTask();
      executor.execute(new Runnable(){
        public void run(){
          try {
            if (opThread.compareAndSet(null,Thread.currentThread())) {
              ModelNode response=ModelControllerImpl.this.execute(operation,messageHandler,OperationTransactionControl.COMMIT,attachments);
              opTask.handleResult(response);
            }
          }
  finally {
synchronized (opThread) {
              opThread.set(null);
              opThread.notifyAll();
            }
          }
        }
      }
);
      return opTask;
    }
  }
;
}
