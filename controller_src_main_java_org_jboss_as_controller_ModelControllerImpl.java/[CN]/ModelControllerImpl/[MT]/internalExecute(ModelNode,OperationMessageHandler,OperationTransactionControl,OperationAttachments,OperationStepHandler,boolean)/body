{
  SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(ModelController.ACCESS_PERMISSION);
  }
  final ModelNode headers=operation.has(OPERATION_HEADERS) ? operation.get(OPERATION_HEADERS) : null;
  final boolean rollbackOnFailure=headers == null || !headers.hasDefined(ROLLBACK_ON_RUNTIME_FAILURE) || headers.get(ROLLBACK_ON_RUNTIME_FAILURE).asBoolean();
  final EnumSet<OperationContextImpl.ContextFlag> contextFlags=rollbackOnFailure ? EnumSet.of(OperationContextImpl.ContextFlag.ROLLBACK_ON_FAIL) : EnumSet.noneOf(OperationContextImpl.ContextFlag.class);
  final boolean restartResourceServices=headers != null && headers.hasDefined(ALLOW_RESOURCE_SERVICE_RESTART) && headers.get(ALLOW_RESOURCE_SERVICE_RESTART).asBoolean();
  if (restartResourceServices) {
    contextFlags.add(OperationContextImpl.ContextFlag.ALLOW_RESOURCE_SERVICE_RESTART);
  }
  final ModelNode blockingTimeoutConfig=headers != null && headers.hasDefined(BLOCKING_TIMEOUT) ? headers.get(BLOCKING_TIMEOUT) : null;
  final ModelNode response=new ModelNode();
  final OperationTransactionControl originalResultTxControl=control == null ? null : new OperationTransactionControl(){
    @Override public void operationPrepared(    OperationTransaction transaction,    ModelNode result){
      control.operationPrepared(transaction,response);
    }
  }
;
  AccessMechanism accessMechanism=null;
  AccessAuditContext accessContext=SecurityActions.currentAccessAuditContext();
  if (accessContext != null) {
    if (operation.hasDefined(OPERATION_HEADERS)) {
      ModelNode operationHeaders=operation.get(OPERATION_HEADERS);
      if (operationHeaders.hasDefined(DOMAIN_UUID)) {
        accessContext.setDomainUuid(operationHeaders.get(DOMAIN_UUID).asString());
      }
      if (operationHeaders.hasDefined(ACCESS_MECHANISM)) {
        accessContext.setAccessMechanism(AccessMechanism.valueOf(operationHeaders.get(ACCESS_MECHANISM).asString()));
      }
    }
    accessMechanism=accessContext.getAccessMechanism();
  }
  for (; ; ) {
    final Integer operationID=new Random(new SecureRandom().nextLong()).nextInt();
    final OperationContextImpl context=new OperationContextImpl(operationID,operation.get(OP).asString(),operation.get(OP_ADDR),this,processType,runningModeControl.getRunningMode(),contextFlags,handler,attachments,model,originalResultTxControl,processState,auditLogger,bootingFlag.get(),hostServerGroupTracker,blockingTimeoutConfig,accessMechanism);
    if (activeOperations.putIfAbsent(operationID,context) == null) {
      CurrentOperationIdHolder.setCurrentOperationID(operationID);
      boolean shouldUnlock=false;
      try {
        if (attemptLock) {
          if (!controllerLock.detectDeadlockAndGetLock(operationID)) {
            response.get(OUTCOME).set(FAILED);
            response.get(FAILURE_DESCRIPTION).set(ControllerLogger.ROOT_LOGGER.cannotGetControllerLock());
            return response;
          }
          shouldUnlock=true;
        }
        context.addStep(response,operation,prepareStep,OperationContext.Stage.MODEL);
        context.executeOperation();
      }
  finally {
        if (!response.hasDefined(RESPONSE_HEADERS) || !response.get(RESPONSE_HEADERS).hasDefined(PROCESS_STATE)) {
          ControlledProcessState.State state=processState.getState();
switch (state) {
case RELOAD_REQUIRED:
case RESTART_REQUIRED:
            response.get(RESPONSE_HEADERS,PROCESS_STATE).set(state.toString());
          break;
default :
        break;
    }
  }
  if (shouldUnlock) {
    controllerLock.unlock(operationID);
  }
  activeOperations.remove(operationID);
  CurrentOperationIdHolder.setCurrentOperationID(null);
}
break;
}
}
return response;
}
