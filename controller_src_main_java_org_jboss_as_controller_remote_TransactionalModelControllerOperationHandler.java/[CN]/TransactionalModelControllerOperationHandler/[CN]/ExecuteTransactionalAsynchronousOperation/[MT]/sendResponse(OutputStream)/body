{
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final IOExceptionHolder exceptionHolder=new IOExceptionHolder();
  final FailureHolder failureHolder=new FailureHolder();
  final AtomicInteger status=new AtomicInteger(0);
  ControllerTransactionContext tx=getTransaction();
  Operation operation=builder.build();
  OperationResult result=transactionalModelController.execute(operation,new ResultHandler(){
    @Override public void handleResultFragment(    String[] location,    ModelNode fragment){
      try {
synchronized (outputStream) {
          outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT);
          outputStream.write(ModelControllerClientProtocol.PARAM_LOCATION);
          StreamUtils.writeInt(outputStream,location.length);
          for (          String loc : location) {
            StreamUtils.writeUTFZBytes(outputStream,loc);
          }
          outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);
          fragment.writeExternal(outputStream);
          outputStream.flush();
        }
      }
 catch (      IOException e) {
        clearAsynchronousOperation(asynchronousRequestId);
        exceptionHolder.setException(e);
        completeLatch.countDown();
      }
    }
    @Override public void handleResultComplete(){
      clearAsynchronousOperation(asynchronousRequestId);
      if (!status.compareAndSet(0,1)) {
        throw new RuntimeException("Result already set");
      }
      completeLatch.countDown();
    }
    @Override public void handleFailed(    final ModelNode failureDescription){
      clearAsynchronousOperation(asynchronousRequestId);
      if (!status.compareAndSet(0,2)) {
        throw new RuntimeException("Result already set");
      }
      failureHolder.setFailure(failureDescription);
      completeLatch.countDown();
    }
    @Override public void handleCancellation(){
      clearAsynchronousOperation(asynchronousRequestId);
      if (!status.compareAndSet(0,3)) {
        throw new RuntimeException("Result already set");
      }
      completeLatch.countDown();
    }
  }
,tx);
synchronized (outputStream) {
    outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);
    ModelNode compensating=result.getCompensatingOperation() != null ? result.getCompensatingOperation() : new ModelNode();
    compensating.writeExternal(outputStream);
    outputStream.flush();
  }
  if (completeLatch.getCount() == 0) {
  }
 else {
    addAsynchronousOperation(asynchronousRequestId,result.getCancellable());
synchronized (outputStream) {
      outputStream.write(ModelControllerClientProtocol.PARAM_REQUEST_ID);
      StreamUtils.writeInt(outputStream,asynchronousRequestId);
      outputStream.flush();
    }
    while (true) {
      try {
        completeLatch.await();
        break;
      }
 catch (      InterruptedException e) {
      }
    }
  }
  if (exceptionHolder.getException() != null) {
    throw exceptionHolder.getException();
  }
switch (status.get()) {
case 1:
{
synchronized (outputStream) {
        outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE);
        outputStream.flush();
      }
      break;
    }
case 2:
{
synchronized (outputStream) {
      outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FAILED);
      failureHolder.getFailure().writeExternal(outputStream);
      outputStream.flush();
    }
    break;
  }
case 3:
{
synchronized (outputStream) {
    outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION);
    outputStream.flush();
  }
  break;
}
default :
{
throw new IOException("Unknown status type " + status.get());
}
}
}
