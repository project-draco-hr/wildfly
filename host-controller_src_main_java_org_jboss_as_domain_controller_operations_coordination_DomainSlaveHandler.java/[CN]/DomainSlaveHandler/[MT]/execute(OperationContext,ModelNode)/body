{
  if (context.hasFailureDescription()) {
    context.setRollbackOnly();
    context.completeStep();
    return;
  }
  final Set<String> outstanding=new HashSet<String>(hostProxies.keySet());
  final List<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>> results=new ArrayList<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>>();
  final Map<String,HostControllerUpdateTask.ExecutedHostRequest> finalResults=new HashMap<String,HostControllerUpdateTask.ExecutedHostRequest>();
  final HostControllerUpdateTask.ProxyOperationListener listener=new HostControllerUpdateTask.ProxyOperationListener();
  for (  Map.Entry<String,ProxyController> entry : hostProxies.entrySet()) {
    final String host=entry.getKey();
    final TransformingProxyController proxyController=(TransformingProxyController)entry.getValue();
    List<DomainOperationTransformer> transformers=context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS);
    ModelNode op=operation;
    if (transformers != null) {
      for (      final DomainOperationTransformer transformer : transformers) {
        op=transformer.transform(context,op);
      }
    }
    final HostControllerUpdateTask task=new HostControllerUpdateTask(host,op.clone(),context,proxyController);
    final HostControllerUpdateTask.ExecutedHostRequest finalResult=task.execute(listener);
    finalResults.put(host,finalResult);
  }
  boolean interrupted=false;
  try {
    try {
      while (outstanding.size() > 0) {
        final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared=listener.retrievePreparedOperation();
        final String hostName=prepared.getOperation().getName();
        if (!outstanding.remove(hostName)) {
          continue;
        }
        final ModelNode preparedResult=prepared.getPreparedResult();
        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
          HOST_CONTROLLER_LOGGER.tracef("Preliminary result for remote host %s is %s",hostName,preparedResult);
        }
        final HostControllerUpdateTask.ExecutedHostRequest request=finalResults.get(hostName);
        boolean reject=prepared.isFailed() ? false : request.rejectOperation(preparedResult);
        if (reject) {
          if (HOST_CONTROLLER_LOGGER.isDebugEnabled()) {
            HOST_CONTROLLER_LOGGER.debugf("Rejecting result for remote host %s is %s",hostName,preparedResult);
          }
          final ModelNode failedResult=new ModelNode();
          failedResult.get(OUTCOME).set(FAILED);
          failedResult.get(FAILURE_DESCRIPTION).set(request.getFailureDescription());
          domainOperationContext.addHostControllerResult(hostName,failedResult);
          results.add(prepared);
        }
 else {
          domainOperationContext.addHostControllerResult(hostName,preparedResult);
          results.add(prepared);
        }
      }
    }
 catch (    InterruptedException ie) {
      interrupted=true;
      domainOperationContext.setFailureReported(true);
      for (      final HostControllerUpdateTask.ExecutedHostRequest finalResult : finalResults.values()) {
        finalResult.asyncCancel();
      }
      for (      final Map.Entry<String,HostControllerUpdateTask.ExecutedHostRequest> entry : finalResults.entrySet()) {
        final String hostName=entry.getKey();
        try {
          final HostControllerUpdateTask.ExecutedHostRequest request=entry.getValue();
          final ModelNode result=request.getFinalResult().get();
          final ModelNode transformedResult=request.transformResult(result);
          domainOperationContext.addHostControllerResult(hostName,transformedResult);
        }
 catch (        Exception e) {
          final ModelNode result=new ModelNode();
          result.get(OUTCOME).set(FAILED);
          if (e instanceof InterruptedException) {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromHost(entry.getKey()));
            interrupted=true;
          }
 else {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromHost(entry.getKey(),e.getMessage()));
          }
          domainOperationContext.addHostControllerResult(hostName,result);
        }
      }
    }
    context.completeStep();
  }
  finally {
    try {
      boolean rollback=domainOperationContext.isCompleteRollback();
      for (      final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {
        if (prepared.isDone()) {
          continue;
        }
        if (!rollback) {
          prepared.commit();
        }
 else {
          prepared.rollback();
        }
      }
      for (      final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {
        final String hostName=prepared.getOperation().getName();
        try {
          final ModelNode finalResult=prepared.getFinalResult().get();
          domainOperationContext.addHostControllerResult(hostName,finalResult);
          if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
            HOST_CONTROLLER_LOGGER.tracef("Final result for remote host %s is %s",hostName,finalResult);
          }
        }
 catch (        InterruptedException e) {
          interrupted=true;
          CONTROLLER_LOGGER.interruptedAwaitingFinalResponse(hostName);
        }
catch (        ExecutionException e) {
          CONTROLLER_LOGGER.caughtExceptionAwaitingFinalResponse(e.getCause(),hostName);
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
