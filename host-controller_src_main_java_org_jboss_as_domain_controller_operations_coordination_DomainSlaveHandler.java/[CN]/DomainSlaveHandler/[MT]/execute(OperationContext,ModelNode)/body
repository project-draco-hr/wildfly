{
  if (context.hasFailureDescription()) {
    context.setRollbackOnly();
    context.completeStep();
    return;
  }
  final Map<String,ProxyTask> tasks=new HashMap<String,ProxyTask>();
  final Map<String,Future<ModelNode>> futures=new HashMap<String,Future<ModelNode>>();
  for (  Map.Entry<String,ProxyController> entry : hostProxies.entrySet()) {
    String host=entry.getKey();
    ProxyTask task=new ProxyTask(host,operation.clone(),context,entry.getValue());
    tasks.put(host,task);
    futures.put(host,executorService.submit(task));
  }
  boolean interrupted=false;
  try {
    for (    Map.Entry<String,ProxyTask> entry : tasks.entrySet()) {
      ProxyTask task=entry.getValue();
      ModelNode result;
      try {
        result=entry.getValue().getUncommittedResult();
      }
 catch (      Exception e) {
        result=new ModelNode();
        result.get(OUTCOME).set(FAILED);
        if (e instanceof InterruptedException) {
          result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromHost(entry.getKey()));
          interrupted=true;
        }
 else {
          result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromHost(entry.getKey(),e.getMessage()));
        }
        task.cancel();
        futures.get(entry.getKey()).cancel(true);
      }
      if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
        HOST_CONTROLLER_LOGGER.tracef("Preliminary result for remote host %s is %s",entry.getKey(),result);
      }
      domainOperationContext.addHostControllerResult(entry.getKey(),result);
    }
    context.completeStep();
  }
  finally {
    try {
      boolean rollback=domainOperationContext.isCompleteRollback();
      for (      ProxyTask task : tasks.values()) {
        task.finalizeTransaction(!rollback);
      }
      for (      Map.Entry<String,Future<ModelNode>> entry : futures.entrySet()) {
        Future<ModelNode> future=entry.getValue();
        try {
          ModelNode finalResult=future.isCancelled() ? getCancelledResult() : future.get();
          domainOperationContext.addHostControllerResult(entry.getKey(),finalResult);
          if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
            HOST_CONTROLLER_LOGGER.tracef("Final result for remote host %s is %s",entry.getKey(),finalResult);
          }
        }
 catch (        InterruptedException e) {
          interrupted=true;
          CONTROLLER_LOGGER.interruptedAwaitingFinalResponse(entry.getKey());
        }
catch (        ExecutionException e) {
          CONTROLLER_LOGGER.caughtExceptionAwaitingFinalResponse(e.getCause(),entry.getKey());
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
