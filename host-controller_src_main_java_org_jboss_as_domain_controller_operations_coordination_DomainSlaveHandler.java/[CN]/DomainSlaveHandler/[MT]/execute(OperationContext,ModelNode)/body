{
  if (context.hasFailureDescription()) {
    context.setRollbackOnly();
    context.stepCompleted();
    return;
  }
  context.attachIfAbsent(CompositeOperationHandler.DOMAIN_EXECUTION_KEY,Boolean.TRUE);
  final Set<String> outstanding=new HashSet<String>(hostProxies.keySet());
  final List<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>> results=new ArrayList<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>>();
  final Map<String,HostControllerUpdateTask.ExecutedHostRequest> finalResults=new HashMap<String,HostControllerUpdateTask.ExecutedHostRequest>();
  final HostControllerUpdateTask.ProxyOperationListener listener=new HostControllerUpdateTask.ProxyOperationListener();
  for (  Map.Entry<String,ProxyController> entry : hostProxies.entrySet()) {
    final String host=entry.getKey();
    final TransformingProxyController proxyController=(TransformingProxyController)entry.getValue();
    List<DomainOperationTransformer> transformers=context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS);
    ModelNode op=operation;
    if (transformers != null) {
      for (      final DomainOperationTransformer transformer : transformers) {
        op=transformer.transform(context,op);
      }
    }
    ModelNode clonedOp=runtimeIgnoreTransformationRegistry.piggyBackMissingInformationOnHeader(context,proxyController,entry.getKey(),op.clone());
    clonedOp.get(DomainControllerLockIdUtils.DOMAIN_CONTROLLER_LOCK_ID).set(CurrentOperationIdHolder.getCurrentOperationID());
    final HostControllerUpdateTask task=new HostControllerUpdateTask(host,clonedOp,context,proxyController);
    final HostControllerUpdateTask.ExecutedHostRequest finalResult=task.execute(listener);
    domainOperationContext.recordHostRequest(host,finalResult);
    finalResults.put(host,finalResult);
  }
  boolean interrupted=false;
  boolean completeStepCalled=false;
  try {
    try {
      while (outstanding.size() > 0) {
        final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared=listener.retrievePreparedOperation();
        final String hostName=prepared.getOperation().getName();
        if (!outstanding.remove(hostName)) {
          continue;
        }
        final ModelNode preparedResult=prepared.getPreparedResult();
        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
          HOST_CONTROLLER_LOGGER.tracef("Preliminary result for remote host %s is %s",hostName,preparedResult);
        }
        final HostControllerUpdateTask.ExecutedHostRequest request=finalResults.get(hostName);
        boolean reject=request.rejectOperation(preparedResult);
        if (reject) {
          if (HOST_CONTROLLER_LOGGER.isDebugEnabled()) {
            HOST_CONTROLLER_LOGGER.debugf("Rejecting result for remote host %s is %s",hostName,preparedResult);
          }
          final ModelNode failedResult=new ModelNode();
          failedResult.get(OUTCOME).set(FAILED);
          failedResult.get(FAILURE_DESCRIPTION).set(request.getFailureDescription());
          domainOperationContext.addHostControllerResult(hostName,failedResult);
        }
 else {
          domainOperationContext.addHostControllerResult(hostName,preparedResult);
        }
        results.add(prepared);
      }
    }
 catch (    InterruptedException ie) {
      interrupted=true;
      domainOperationContext.setFailureReported(true);
      for (      final HostControllerUpdateTask.ExecutedHostRequest finalResult : finalResults.values()) {
        finalResult.asyncCancel();
      }
      for (      final Map.Entry<String,HostControllerUpdateTask.ExecutedHostRequest> entry : finalResults.entrySet()) {
        final String hostName=entry.getKey();
        try {
          final HostControllerUpdateTask.ExecutedHostRequest request=entry.getValue();
          final ModelNode result=request.getFinalResult().get();
          final ModelNode transformedResult=request.transformResult(result);
          domainOperationContext.addHostControllerResult(hostName,transformedResult);
        }
 catch (        Exception e) {
          final ModelNode result=new ModelNode();
          result.get(OUTCOME).set(FAILED);
          if (e instanceof InterruptedException) {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromHost(entry.getKey()));
            interrupted=true;
          }
 else {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromHost(entry.getKey(),e.getMessage()));
          }
          domainOperationContext.addHostControllerResult(hostName,result);
        }
      }
    }
    final boolean interruptThread=interrupted;
    context.completeStep(new OperationContext.ResultHandler(){
      @Override public void handleResult(      OperationContext.ResultAction resultAction,      OperationContext context,      ModelNode operation){
        finalizeOp(results,finalResults,interruptThread,context);
      }
    }
);
    completeStepCalled=true;
  }
  finally {
    if (!completeStepCalled) {
      finalizeOp(results,finalResults,interrupted,context);
    }
  }
}
