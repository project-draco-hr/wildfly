{
  final Map<String,ModelNode> hostResults=new HashMap<String,ModelNode>();
  final Map<String,Future<ModelNode>> futures=new HashMap<String,Future<ModelNode>>();
  ModelNode wrapper=new ModelNode();
  wrapper.get(OP).set(HostControllerClient.EXECUTE_ON_DOMAIN);
  wrapper.get(HostControllerClient.DOMAIN_OP).set(executionContext.getOperation());
  ExecutionContext wrapperContext=executionContext.clone(wrapper);
  final Set<String> targets=routing.getHosts();
  if (targets.remove(localHostName)) {
    if (targets.size() > 0) {
      wrapperContext=wrapperContext.clone(wrapper.clone());
    }
    pushToHost(wrapperContext,transaction,localHostName,futures);
    processHostFuture(localHostName,futures.remove(localHostName),hostResults);
    ModelNode hostResult=hostResults.get(localHostName);
    if (!transaction.isRollbackOnly()) {
      if (hostResult.hasDefined(OUTCOME) && FAILED.equals(hostResult.get(OUTCOME).asString())) {
        transaction.setRollbackOnly();
      }
    }
  }
  if (!transaction.isRollbackOnly()) {
    for (    final String host : targets) {
      pushToHost(wrapperContext,transaction,host,futures);
    }
    log.debugf("Domain updates pushed to %s host controller(s)",futures.size());
    for (    final Map.Entry<String,Future<ModelNode>> entry : futures.entrySet()) {
      String host=entry.getKey();
      Future<ModelNode> future=entry.getValue();
      processHostFuture(host,future,hostResults);
    }
  }
  return hostResults;
}
