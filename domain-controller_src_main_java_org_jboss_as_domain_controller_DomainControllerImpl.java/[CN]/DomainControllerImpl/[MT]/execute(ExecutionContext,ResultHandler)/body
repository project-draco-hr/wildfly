{
  ModelNode operation=executionContext.getOperation();
  if (operation.get(OP).asString().equals(HostControllerClient.EXECUTE_ON_DOMAIN)) {
    return localDomainModel.execute(executionContext.clone(operation.require(HostControllerClient.DOMAIN_OP)),handler);
  }
  OperationRouting routing=determineRouting(operation);
  if (routing.isRouteToMaster()) {
    return masterDomainControllerClient.execute(executionContext,handler);
  }
 else   if (routing.isLocalOnly()) {
    return localDomainModel.execute(executionContext,handler);
  }
  ModelNode rolloutPlan=operation.has(ROLLOUT_PLAN) ? operation.remove(ROLLOUT_PLAN) : null;
  ControllerTransaction transaction=new ControllerTransaction();
  Map<String,ModelNode> hostResults=pushToHosts(executionContext,routing,transaction);
  ModelNode masterFailureResult=null;
  ModelNode hostFailureResults=null;
  ModelNode masterResult=hostResults.get(localHostName);
  if (masterResult != null && masterResult.hasDefined(OUTCOME) && FAILED.equals(masterResult.get(OUTCOME).asString())) {
    transaction.setRollbackOnly();
    masterFailureResult=masterResult.hasDefined(FAILURE_DESCRIPTION) ? masterResult.get(FAILURE_DESCRIPTION) : new ModelNode().set("Unexplained failure");
  }
 else {
    for (    Map.Entry<String,ModelNode> entry : hostResults.entrySet()) {
      ModelNode hostResult=entry.getValue();
      if (hostResult.hasDefined(OUTCOME) && FAILED.equals(hostResult.get(OUTCOME).asString())) {
        if (hostFailureResults == null) {
          transaction.setRollbackOnly();
          hostFailureResults=new ModelNode();
        }
        ModelNode desc=hostResult.hasDefined(FAILURE_DESCRIPTION) ? hostResult.get(FAILURE_DESCRIPTION) : new ModelNode().set("Unexplained failure");
        hostFailureResults.add(entry.getKey(),desc);
      }
    }
  }
  if (transaction.isRollbackOnly()) {
    transaction.commit();
    if (masterFailureResult != null) {
      handler.handleResultFragment(new String[]{DOMAIN_FAILURE_DESCRIPTION},masterFailureResult);
    }
 else     if (hostFailureResults != null) {
      handler.handleResultFragment(new String[]{HOST_FAILURE_DESCRIPTIONS},hostFailureResults);
    }
    handler.handleFailed(null);
    return new BasicOperationResult();
  }
 else {
    Map<String,Map<ServerIdentity,ModelNode>> opsByGroup=getOpsByGroup(hostResults);
    try {
      rolloutPlan=getRolloutPlan(rolloutPlan,opsByGroup);
    }
 catch (    OperationFailedException ofe) {
      transaction.setRollbackOnly();
      handler.handleResultFragment(new String[]{DOMAIN_FAILURE_DESCRIPTION},ofe.getFailureDescription());
      handler.handleFailed(null);
      return new BasicOperationResult();
    }
 finally {
      transaction.commit();
    }
    ModelNode compensatingOperation=getCompensatingOperation(operation,hostResults);
    if (opsByGroup.size() == 0) {
      handler.handleResultComplete();
      return new BasicOperationResult(compensatingOperation);
    }
    RolloutPlanController controller=new RolloutPlanController(opsByGroup,rolloutPlan,handler,immutableHosts,scheduledExecutorService,false);
    RolloutPlanController.Result controllerResult=controller.execute();
switch (controllerResult) {
case FAILED:
{
        controller.rollback();
        handler.handleFailed(new ModelNode().set("Operation was not applied successfully to any servers"));
        return new BasicOperationResult(compensatingOperation);
      }
case PARTIAL:
{
      controller.rollback();
    }
case SUCCESS:
{
    handler.handleResultComplete();
    return new BasicOperationResult(compensatingOperation);
  }
default :
throw new IllegalStateException("Unknown result " + controllerResult);
}
}
}
