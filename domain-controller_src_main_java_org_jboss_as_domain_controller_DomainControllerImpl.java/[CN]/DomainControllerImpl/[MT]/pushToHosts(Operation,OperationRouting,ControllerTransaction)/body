{
  final Map<String,ModelNode> hostResults=new HashMap<String,ModelNode>();
  final Map<String,Future<ModelNode>> futures=new HashMap<String,Future<ModelNode>>();
  final Set<String> targets=routing.getHosts();
  if (targets.remove(localHostName)) {
    Operation localOperation=operation;
    if (targets.size() > 0) {
      localOperation=localOperation.clone(localOperation.getOperation().clone());
    }
    pushToHost(localOperation,transaction,localHostName,futures);
    processHostFuture(localHostName,futures.remove(localHostName),hostResults);
    ModelNode hostResult=hostResults.get(localHostName);
    if (!transaction.isRollbackOnly()) {
      if (hostResult.hasDefined(OUTCOME) && FAILED.equals(hostResult.get(OUTCOME).asString())) {
        transaction.setRollbackOnly();
      }
    }
  }
  if (!transaction.isRollbackOnly()) {
    for (    final String host : targets) {
      pushToHost(operation,transaction,host,futures);
    }
    log.debugf("Domain updates pushed to %s host controller(s)",futures.size());
    for (    final Map.Entry<String,Future<ModelNode>> entry : futures.entrySet()) {
      String host=entry.getKey();
      Future<ModelNode> future=entry.getValue();
      processHostFuture(host,future,hostResults);
    }
  }
  return hostResults;
}
