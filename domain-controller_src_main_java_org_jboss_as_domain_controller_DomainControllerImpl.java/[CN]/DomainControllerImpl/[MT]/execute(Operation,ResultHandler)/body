{
  ModelNode operation=operationContext.getOperation();
  OperationRouting routing=determineRouting(operation);
  if (!routing.isLocalOnly() && masterDomainControllerClient != null) {
    PathAddress addr=PathAddress.pathAddress(operation.get(OP_ADDR));
    handler.handleFailed(new ModelNode().set("Operations for address " + addr + " can only handled by the master Domain Controller; this host is not the master Domain Controller"));
    return new BasicOperationResult();
  }
 else   if (!routing.isTwoStep()) {
    String host=routing.getSingleHost();
    DomainControllerSlaveClient hostClient=hosts.get(host);
    return hostClient.execute(operationContext,handler);
  }
  ModelNode rolloutPlan=operation.has(ROLLOUT_PLAN) ? operation.remove(ROLLOUT_PLAN) : null;
  ControllerTransaction transaction=new ControllerTransaction();
  Map<String,ModelNode> hostResults=pushToHosts(operationContext,routing,transaction);
  System.out.println("---- Pushed to hosts");
  ModelNode masterFailureResult=null;
  ModelNode hostFailureResults=null;
  ModelNode masterResult=hostResults.get(localHostName);
  System.out.println("-----Checking host results");
  if (masterResult != null && masterResult.hasDefined(OUTCOME) && FAILED.equals(masterResult.get(OUTCOME).asString())) {
    transaction.setRollbackOnly();
    masterFailureResult=masterResult.hasDefined(FAILURE_DESCRIPTION) ? masterResult.get(FAILURE_DESCRIPTION) : new ModelNode().set("Unexplained failure");
  }
 else {
    for (    Map.Entry<String,ModelNode> entry : hostResults.entrySet()) {
      ModelNode hostResult=entry.getValue();
      if (hostResult.hasDefined(OUTCOME) && FAILED.equals(hostResult.get(OUTCOME).asString())) {
        if (hostFailureResults == null) {
          transaction.setRollbackOnly();
          hostFailureResults=new ModelNode();
        }
        ModelNode desc=hostResult.hasDefined(FAILURE_DESCRIPTION) ? hostResult.get(FAILURE_DESCRIPTION) : new ModelNode().set("Unexplained failure");
        hostFailureResults.add(entry.getKey(),desc);
      }
    }
  }
  if (transaction.isRollbackOnly()) {
    transaction.commit();
    if (masterFailureResult != null) {
      handler.handleResultFragment(new String[]{DOMAIN_FAILURE_DESCRIPTION},masterFailureResult);
    }
 else     if (hostFailureResults != null) {
      handler.handleResultFragment(new String[]{HOST_FAILURE_DESCRIPTIONS},hostFailureResults);
    }
    handler.handleFailed(null);
    return new BasicOperationResult();
  }
 else {
    Map<String,Map<ServerIdentity,ModelNode>> opsByGroup=getOpsByGroup(hostResults);
    try {
      rolloutPlan=getRolloutPlan(rolloutPlan,opsByGroup);
    }
 catch (    OperationFailedException ofe) {
      transaction.setRollbackOnly();
      handler.handleResultFragment(new String[]{DOMAIN_FAILURE_DESCRIPTION},ofe.getFailureDescription());
      handler.handleFailed(null);
      return new BasicOperationResult();
    }
 finally {
      transaction.commit();
    }
    ModelNode compensatingOperation=getCompensatingOperation(operation,hostResults);
    if (opsByGroup.size() == 0) {
      handler.handleResultComplete();
      return new BasicOperationResult(compensatingOperation);
    }
    RolloutPlanController controller=new RolloutPlanController(opsByGroup,rolloutPlan,handler,immutableHosts,scheduledExecutorService,false);
    RolloutPlanController.Result controllerResult=controller.execute();
switch (controllerResult) {
case FAILED:
{
        controller.rollback();
        handler.handleFailed(new ModelNode().set("Operation was not applied successfully to any servers"));
        return new BasicOperationResult(compensatingOperation);
      }
case PARTIAL:
{
      controller.rollback();
    }
case SUCCESS:
{
    handler.handleResultComplete();
    return new BasicOperationResult(compensatingOperation);
  }
default :
throw new IllegalStateException("Unknown result " + controllerResult);
}
}
}
