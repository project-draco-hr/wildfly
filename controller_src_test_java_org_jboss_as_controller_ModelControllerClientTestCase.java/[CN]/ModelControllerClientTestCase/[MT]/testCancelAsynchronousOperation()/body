{
  final CountDownLatch executeLatch=new CountDownLatch(1);
  final CountDownLatch interrupted=new CountDownLatch(1);
  MockModelController controller=new MockModelController(){
    @Override public ModelNode execute(    ModelNode operation,    OperationMessageHandler handler,    OperationTransactionControl control,    OperationAttachments attachments){
      this.operation=operation;
      executeLatch.countDown();
      try {
        log.debug("Waiting for interrupt");
        Thread.sleep(10000000);
        ModelNode result=new ModelNode();
        result.get("testing").set(operation.get("test"));
        return result;
      }
 catch (      InterruptedException e) {
        interrupted.countDown();
        throw new RuntimeException(e);
      }
    }
  }
;
  final ModelControllerClient client=setupTestClient(controller);
  try {
    ModelNode operation=new ModelNode();
    operation.get("test").set("123");
    final BlockingQueue<String> messages=new LinkedBlockingQueue<String>();
    AsyncFuture<ModelNode> resultFuture=client.executeAsync(operation,new OperationMessageHandler(){
      @Override public void handleReport(      MessageSeverity severity,      String message){
        if (severity == MessageSeverity.INFO && message.startsWith("Test")) {
          messages.add(message);
        }
      }
    }
);
    executeLatch.await();
    resultFuture.cancel(false);
    interrupted.await();
  }
  finally {
    IoUtils.safeClose(client);
  }
}
