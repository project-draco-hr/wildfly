{
  final SocketBinding binding=this.binding.getValue();
  final InetSocketAddress address=binding.getSocketAddress();
  final Executor executor=this.executor.getOptionalValue();
  try {
    final Connector connector=new Connector(protocol);
    connector.setPort(address.getPort());
    connector.setScheme(scheme);
    if (enableLookups != null)     connector.setEnableLookups(enableLookups);
    if (maxPostSize != null)     connector.setMaxPostSize(maxPostSize);
    if (maxSavePostSize != null)     connector.setMaxSavePostSize(maxSavePostSize);
    if (proxyName != null)     connector.setProxyName(proxyName);
    if (proxyPort != null)     connector.setProxyPort(proxyPort);
    if (redirectPort != null)     connector.setRedirectPort(redirectPort);
    if (secure != null)     connector.setSecure(secure);
    boolean nativeProtocolHandler=false;
    if (connector.getProtocolHandler() instanceof Http11AprProtocol || connector.getProtocolHandler() instanceof AjpAprProtocol) {
      nativeProtocolHandler=true;
    }
    if (executor != null) {
      Method m=connector.getProtocolHandler().getClass().getMethod("setExecutor",Executor.class);
      m.invoke(connector.getProtocolHandler(),executor);
    }
    if (address != null && address.getAddress() != null) {
      Method m=connector.getProtocolHandler().getClass().getMethod("setAddress",InetAddress.class);
      m.invoke(connector.getProtocolHandler(),address.getAddress());
    }
    if (maxConnections != null) {
      try {
        Method m=connector.getProtocolHandler().getClass().getMethod("setPollerSize",Integer.TYPE);
        m.invoke(connector.getProtocolHandler(),maxConnections);
      }
 catch (      NoSuchMethodException e) {
      }
      if (nativeProtocolHandler) {
        try {
          Method m=connector.getProtocolHandler().getClass().getMethod("setSendfileSize",Integer.TYPE);
          m.invoke(connector.getProtocolHandler(),maxConnections);
        }
 catch (        NoSuchMethodException e) {
        }
      }
 else {
        Method m=connector.getProtocolHandler().getClass().getMethod("setMaxThreads",Integer.TYPE);
        m.invoke(connector.getProtocolHandler(),maxConnections);
      }
    }
    if (virtualServers != null) {
      HashSet<String> virtualServersList=new HashSet<String>();
      for (      final ModelNode virtualServer : virtualServers.asList()) {
        virtualServersList.add(virtualServer.asString());
      }
      connector.setAllowedHosts(virtualServersList);
    }
    if (ssl != null) {
      boolean nativeSSL=false;
      if (connector.getProtocolHandler() instanceof Http11AprProtocol) {
        nativeSSL=true;
      }
 else       if (!(connector.getProtocolHandler() instanceof Http11Protocol)) {
        throw new StartException(MESSAGES.noSSLWithNonHTTPConnectors());
      }
      try {
        Method m=connector.getProtocolHandler().getClass().getMethod("setSSLEnabled",Boolean.TYPE);
        m.invoke(connector.getProtocolHandler(),true);
      }
 catch (      NoSuchMethodException e) {
        throw new StartException(MESSAGES.failedSSLConfiguration(),e);
      }
      if (nativeSSL) {
        try {
          if (ssl.hasDefined(Constants.PASSWORD)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLPassword",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.PASSWORD).asString());
          }
          if (ssl.hasDefined(Constants.CERTIFICATE_KEY_FILE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLCertificateKeyFile",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CERTIFICATE_KEY_FILE).asString());
          }
          if (ssl.hasDefined(Constants.CIPHER_SUITE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLCipherSuite",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CIPHER_SUITE).asString());
          }
          if (ssl.hasDefined(Constants.PROTOCOL)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLProtocol",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.PROTOCOL).asString());
          }
          if (ssl.hasDefined(Constants.VERIFY_CLIENT)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLVerifyClient",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.VERIFY_CLIENT).asString());
          }
          if (ssl.hasDefined(Constants.VERIFY_DEPTH)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLVerifyDepth",Integer.TYPE);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.VERIFY_DEPTH).asInt());
          }
          if (ssl.hasDefined(Constants.CERTIFICATE_FILE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLCertificateFile",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CERTIFICATE_FILE).asString());
          }
          if (ssl.hasDefined(Constants.CA_CERTIFICATE_FILE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLCACertificateFile",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CA_CERTIFICATE_FILE).asString());
          }
          if (ssl.hasDefined(Constants.CA_REVOCATION_URL)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setSSLCARevocationFile",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CA_REVOCATION_URL).asString());
          }
        }
 catch (        NoSuchMethodException e) {
          throw new StartException(MESSAGES.failedSSLConfiguration(),e);
        }
      }
 else {
        try {
          if (ssl.hasDefined(Constants.KEY_ALIAS)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setKeyAlias",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.KEY_ALIAS).asString());
          }
          if (ssl.hasDefined(Constants.PASSWORD)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setKeypass",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.PASSWORD).asString());
          }
          if (ssl.hasDefined(Constants.CERTIFICATE_KEY_FILE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setKeystore",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CERTIFICATE_KEY_FILE).asString());
          }
          if (ssl.hasDefined(Constants.CIPHER_SUITE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setCiphers",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.CIPHER_SUITE).asString());
          }
          if (ssl.hasDefined(Constants.PROTOCOL)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setProtocols",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.PROTOCOL).asString());
          }
          if (ssl.hasDefined(Constants.VERIFY_CLIENT)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setClientauth",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.VERIFY_CLIENT).asString());
          }
          if (ssl.hasDefined(Constants.SESSION_CACHE_SIZE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"sessionCacheSize",ssl.get(Constants.SESSION_CACHE_SIZE).asString());
          }
          if (ssl.hasDefined(Constants.SESSION_TIMEOUT)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"sessionCacheTimeout",ssl.get(Constants.SESSION_TIMEOUT).asString());
          }
          if (ssl.hasDefined(Constants.CA_CERTIFICATE_FILE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"truststoreFile",ssl.get(Constants.CA_CERTIFICATE_FILE).asString());
          }
          if (ssl.hasDefined(Constants.CA_CERTIFICATE_PASSWORD)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"truststorePass",ssl.get(Constants.CA_CERTIFICATE_PASSWORD).asString());
          }
          if (ssl.hasDefined(Constants.TRUSTSTORE_TYPE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"truststoreType",ssl.get(Constants.TRUSTSTORE_TYPE).asString());
          }
          if (ssl.hasDefined(Constants.KEYSTORE_TYPE)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setKeytype",String.class);
            m.invoke(connector.getProtocolHandler(),ssl.get(Constants.KEYSTORE_TYPE).asString());
          }
          if (ssl.hasDefined(Constants.CA_REVOCATION_URL)) {
            Method m=connector.getProtocolHandler().getClass().getMethod("setAttribute",String.class,Object.class);
            m.invoke(connector.getProtocolHandler(),"crlFile",ssl.get(Constants.CA_REVOCATION_URL).asString());
          }
        }
 catch (        NoSuchMethodException e) {
          throw new StartException(MESSAGES.failedSSLConfiguration(),e);
        }
      }
    }
    getWebServer().addConnector(connector);
    connector.init();
    connector.start();
    this.connector=connector;
  }
 catch (  Exception e) {
    throw new StartException(MESSAGES.connectorStartError(),e);
  }
  binding.getSocketBindings().getNamedRegistry().registerBinding(new ConnectorBinding(binding));
}
