{
  PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  String name=address.getLastElement().getValue();
  if (context.getProcessType().isServer() && !context.isBooting() && name.equals("ejb")) {
    Resource rootResource=context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS);
    PathElement ejbPath=PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM,"ejb3");
    if (rootResource.hasChild(ejbPath) && rootResource.getChild(ejbPath).hasChild(PathElement.pathElement("service","remote"))) {
      context.addStep(new OperationStepHandler(){
        @Override public void execute(        final OperationContext context,        final ModelNode operation) throws OperationFailedException {
          context.reloadRequired();
          context.completeStep(OperationContext.RollbackHandler.REVERT_RELOAD_REQUIRED_ROLLBACK_HANDLER);
        }
      }
,OperationContext.Stage.RUNTIME);
      return;
    }
  }
  ServiceTarget target=context.getServiceTarget();
  String defaultCache=ModelNodes.asString(CacheContainerResourceDefinition.DEFAULT_CACHE.resolveModelAttribute(context,model));
  String jndiName=ModelNodes.asString(CacheContainerResourceDefinition.JNDI_NAME.resolveModelAttribute(context,model));
  String listenerExecutor=ModelNodes.asString(CacheContainerResourceDefinition.LISTENER_EXECUTOR.resolveModelAttribute(context,model));
  String evictionExecutor=ModelNodes.asString(CacheContainerResourceDefinition.EVICTION_EXECUTOR.resolveModelAttribute(context,model));
  String replicationQueueExecutor=ModelNodes.asString(CacheContainerResourceDefinition.REPLICATION_QUEUE_EXECUTOR.resolveModelAttribute(context,model));
  ServiceController.Mode initialMode=StartMode.valueOf(CacheContainerResourceDefinition.START.resolveModelAttribute(context,model).asString()).getMode();
  boolean statistics=CacheContainerResourceDefinition.STATISTICS_ENABLED.resolveModelAttribute(context,model).asBoolean();
  ServiceName[] aliases=null;
  if (model.hasDefined(CacheContainerResourceDefinition.ALIASES.getName())) {
    List<ModelNode> list=operation.get(CacheContainerResourceDefinition.ALIASES.getName()).asList();
    aliases=new ServiceName[list.size()];
    for (int i=0; i < list.size(); i++) {
      aliases[i]=EmbeddedCacheManagerService.getServiceName(list.get(i).asString());
    }
  }
  final ModuleIdentifier module=ModelNodes.asModuleIdentifier(CacheContainerResourceDefinition.MODULE.resolveModelAttribute(context,model));
  Transport transportConfig=null;
  String transportExecutor=null;
  InjectedValueServiceBuilder builder=new InjectedValueServiceBuilder(target);
  if (model.hasDefined(TransportResourceDefinition.PATH.getKey())) {
    ModelNode transport=model.get(TransportResourceDefinition.PATH.getKeyValuePair());
    if (transport.isDefined()) {
      transportConfig=new Transport(TransportResourceDefinition.LOCK_TIMEOUT.resolveModelAttribute(context,transport).asLong());
      String channel=ModelNodes.asString(TransportResourceDefinition.CHANNEL.resolveModelAttribute(context,transport));
      transportExecutor=ModelNodes.asString(TransportResourceDefinition.EXECUTOR.resolveModelAttribute(context,transport));
      if (!name.equals(channel)) {
        new BinderServiceBuilder(target).build(ChannelService.createChannelBinding(name),ChannelService.getServiceName(name),Channel.class).install();
        ChannelService.build(target,name).setInitialMode(ON_DEMAND).install();
        if (channel == null) {
          PathAddress jgroupsAddress=address.subAddress(0,address.size() - 2).append(JGroupsSubsystemResourceDefinition.PATH);
          ModelNode jgroupsModel=context.readResourceFromRoot(jgroupsAddress).getModel();
          channel=ModelNodes.asString(JGroupsSubsystemResourceDefinition.DEFAULT_CHANNEL.resolveModelAttribute(context,jgroupsModel));
        }
        new InjectedValueServiceBuilder(target).build(ChannelService.getFactoryServiceName(name),ChannelFactoryService.getServiceName(channel),ChannelFactory.class).install();
        for (        GroupServiceInstaller installer : ServiceLoader.load(ClusteredGroupServiceInstaller.class,ClusteredGroupServiceInstaller.class.getClassLoader())) {
          log.debugf("Installing %s for cache container %s",installer.getClass().getSimpleName(),name);
          Iterator<ServiceName> serviceNames=installer.getServiceNames(channel).iterator();
          for (          ServiceName serviceName : installer.getServiceNames(name)) {
            builder.build(serviceName,serviceNames.next(),Object.class).install();
          }
        }
      }
    }
  }
  if (transportConfig == null) {
    for (    GroupServiceInstaller installer : ServiceLoader.load(LocalGroupServiceInstaller.class,LocalGroupServiceInstaller.class.getClassLoader())) {
      log.debugf("Installing %s for cache container %s",installer.getClass().getSimpleName(),name);
      installer.install(target,name,module);
    }
  }
  ServiceName configServiceName=EmbeddedCacheManagerConfigurationService.getServiceName(name);
  EmbeddedCacheManagerDependencies dependencies=new EmbeddedCacheManagerDependencies(transportConfig);
  ServiceBuilder<EmbeddedCacheManagerConfiguration> configBuilder=target.addService(configServiceName,new EmbeddedCacheManagerConfigurationService(name,defaultCache,statistics,module,dependencies)).addDependency(Services.JBOSS_SERVICE_MODULE_LOADER,ModuleLoader.class,dependencies.getModuleLoaderInjector()).addDependency(MBeanServerService.SERVICE_NAME,MBeanServer.class,dependencies.getMBeanServerInjector());
  if (transportConfig != null) {
    if (transportExecutor != null) {
      addExecutorDependency(configBuilder,transportExecutor,transportConfig.getExecutorInjector());
    }
    configBuilder.addDependency(ChannelService.getServiceName(name),Channel.class,transportConfig.getChannelInjector());
    configBuilder.addDependency(ChannelService.getFactoryServiceName(name),ChannelFactory.class,transportConfig.getChannelFactoryInjector());
  }
  addExecutorDependency(configBuilder,listenerExecutor,dependencies.getListenerExecutorInjector());
  addScheduledExecutorDependency(configBuilder,evictionExecutor,dependencies.getEvictionExecutorInjector());
  addScheduledExecutorDependency(configBuilder,replicationQueueExecutor,dependencies.getReplicationQueueExecutorInjector());
  configBuilder.setInitialMode(ServiceController.Mode.ON_DEMAND).install();
  ServiceBuilder<EmbeddedCacheManager> managerBuilder=EmbeddedCacheManagerService.build(target,name).addAliases(aliases);
  if (transportConfig != null) {
    managerBuilder.addDependency(ChannelService.getServiceName(name));
  }
  managerBuilder.setInitialMode(initialMode).install();
  ServiceName serviceName=EmbeddedCacheManagerService.getServiceName(name);
  ContextNames.BindInfo binding=createCacheContainerBinding(jndiName,name);
  new BinderServiceBuilder(target).build(binding,serviceName,CacheContainer.class).install();
  KeyAffinityServiceFactoryService.build(target,name,10).setInitialMode(ServiceController.Mode.ON_DEMAND).install();
  if ((defaultCache != null) && !defaultCache.equals(CacheContainer.DEFAULT_CACHE_ALIAS)) {
    Class<? extends CacheServiceInstaller> installerClass=(transportConfig != null) ? ClusteredCacheServiceInstaller.class : LocalCacheServiceInstaller.class;
    for (    CacheServiceInstaller installer : ServiceLoader.load(installerClass,installerClass.getClassLoader())) {
      installer.install(target,name,CacheContainer.DEFAULT_CACHE_ALIAS);
    }
  }
}
