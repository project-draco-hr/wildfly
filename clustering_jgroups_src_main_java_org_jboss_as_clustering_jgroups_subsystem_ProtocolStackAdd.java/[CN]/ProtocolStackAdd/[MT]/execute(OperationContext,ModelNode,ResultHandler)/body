{
  ModelNode opAddr=operation.require(ModelDescriptionConstants.OP_ADDR);
  final ModelNode removeOperation=Util.getResourceRemoveOperation(opAddr);
  final PathAddress address=PathAddress.pathAddress(opAddr);
  final String name=address.getLastElement().getValue();
  populate(operation,context.getSubModel());
  RuntimeOperationContext runtime=context.getRuntimeContext();
  if (runtime != null) {
    RuntimeTask task=new RuntimeTask(){
      @Override public void execute(      RuntimeTaskContext context) throws OperationFailedException {
        ModelNode transport=operation.get(ModelKeys.TRANSPORT);
        Transport transportConfig=new Transport(transport.require(ModelKeys.TYPE).asString());
        ProtocolStack stackConfig=new ProtocolStack(name,transportConfig);
        ServiceBuilder<ChannelFactory> builder=context.getServiceTarget().addService(ChannelFactoryService.getServiceName(name),new ValueService<ChannelFactory>(new ImmediateValue<ChannelFactory>(new JChannelFactory(stackConfig)))).addDependency(ProtocolDefaultsService.SERVICE_NAME,ProtocolDefaults.class,stackConfig.getDefaultsInjector()).addDependency(DependencyType.OPTIONAL,ServiceName.JBOSS.append("mbean","server"),MBeanServer.class,stackConfig.getMBeanServerInjector());
        this.build(builder,transport,transportConfig);
        this.addSocketBindingDependency(builder,transport,ModelKeys.DIAGNOSTICS_SOCKET_BINDING,transportConfig.getDiagnosticsSocketBindingInjector());
        this.addExecutorDependency(builder,transport,ModelKeys.DEFAULT_EXECUTOR,transportConfig.getDefaultExecutorInjector());
        this.addExecutorDependency(builder,transport,ModelKeys.OOB_EXECUTOR,transportConfig.getOOBExecutorInjector());
        if (transport.hasDefined(ModelKeys.TIMER_EXECUTOR)) {
          builder.addDependency(ThreadsServices.executorName(transport.get(ModelKeys.TIMER_EXECUTOR).asString()),ScheduledExecutorService.class,transportConfig.getTimerExecutorInjector());
        }
        if (transport.hasDefined(ModelKeys.THREAD_FACTORY)) {
          builder.addDependency(ThreadsServices.threadFactoryName(transport.get(ModelKeys.THREAD_FACTORY).asString()),ThreadFactory.class,transportConfig.getThreadFactoryInjector());
        }
        for (        ModelNode protocol : operation.get(ModelKeys.PROTOCOL).asList()) {
          Protocol protocolConfig=new Protocol(protocol.require(ModelKeys.TYPE).asString());
          this.build(builder,protocol,protocolConfig);
          stackConfig.getProtocols().add(protocolConfig);
        }
        builder.setInitialMode(ServiceController.Mode.ON_DEMAND).install();
        resultHandler.handleResultComplete();
      }
      private void build(      ServiceBuilder<ChannelFactory> builder,      ModelNode protocol,      Protocol protocolConfig){
        this.addSocketBindingDependency(builder,protocol,ModelKeys.SOCKET_BINDING,protocolConfig.getSocketBindingInjector());
        Map<String,String> properties=protocolConfig.getProperties();
        if (protocol.hasDefined(ModelKeys.PROPERTY)) {
          for (          Property property : protocol.get(ModelKeys.PROPERTY).asPropertyList()) {
            properties.put(property.getName(),property.getValue().asString());
          }
        }
      }
      private void addSocketBindingDependency(      ServiceBuilder<ChannelFactory> builder,      ModelNode model,      String key,      Injector<SocketBinding> injector){
        if (model.hasDefined(key)) {
          builder.addDependency(SocketBinding.JBOSS_BINDING_NAME.append(model.get(key).asString()),SocketBinding.class,injector);
        }
      }
      private void addExecutorDependency(      ServiceBuilder<ChannelFactory> builder,      ModelNode model,      String key,      Injector<Executor> injector){
        if (model.hasDefined(key)) {
          builder.addDependency(ThreadsServices.executorName(model.get(key).asString()),Executor.class,injector);
        }
      }
    }
;
    runtime.setRuntimeTask(task);
  }
 else {
    resultHandler.handleResultComplete();
  }
  return new BasicOperationResult(removeOperation);
}
