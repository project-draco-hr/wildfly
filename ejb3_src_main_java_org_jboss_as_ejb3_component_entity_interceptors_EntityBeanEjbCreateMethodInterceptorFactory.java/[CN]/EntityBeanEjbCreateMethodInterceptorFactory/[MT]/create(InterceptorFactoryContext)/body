{
  final Object existing=context.getContextData().get(EntityBeanComponent.PRIMARY_KEY_CONTEXT_KEY);
  final AtomicReference<Object> primaryKeyReference=new AtomicReference<Object>();
  context.getContextData().put(EntityBeanComponent.PRIMARY_KEY_CONTEXT_KEY,primaryKeyReference);
  final Method ejbCreate=(Method)context.getContextData().get(EntityBeanHomeCreateInterceptorFactory.EJB_CREATE_METHOD_KEY);
  final Method ejbPostCreate=(Method)context.getContextData().get(EntityBeanHomeCreateInterceptorFactory.EJB_POST_CREATE_METHOD_KEY);
  final Object[] params=(Object[])context.getContextData().get(EntityBeanHomeCreateInterceptorFactory.PARAMETERS_KEY);
  return new Interceptor(){
    @Override public Object processInvocation(    final InterceptorContext context) throws Exception {
      if (existing != null) {
        primaryKeyReference.set(existing);
        return existing;
      }
      final Component component=context.getPrivateData(Component.class);
      if (!(component instanceof EntityBeanComponent)) {
        throw MESSAGES.unexpectedComponent(component,EntityBeanComponent.class);
      }
      final EntityBeanComponent entityBeanComponent=(EntityBeanComponent)component;
      final EntityBeanComponentInstance instance=entityBeanComponent.getPool().get();
      final Object primaryKey=invokeEjbCreate(context,ejbCreate,instance,params);
      instance.associate(primaryKey);
      primaryKeyReference.set(primaryKey);
      boolean synchronizationRegistered=false;
      boolean exception=false;
      entityBeanComponent.getCache().create(instance);
      entityBeanComponent.getCache().reference(instance);
      try {
        invokeEjbPostCreate(context,ejbPostCreate,instance,params);
        final TransactionSynchronizationRegistry transactionSynchronizationRegistry=entityBeanComponent.getTransactionSynchronizationRegistry();
        if (transactionSynchronizationRegistry.getTransactionKey() != null) {
          transactionSynchronizationRegistry.registerInterposedSynchronization(new Synchronization(){
            @Override public void beforeCompletion(){
            }
            @Override public void afterCompletion(            final int status){
              entityBeanComponent.getCache().release(instance,status == Status.STATUS_COMMITTED);
              if (status != Status.STATUS_COMMITTED) {
                entityBeanComponent.getPool().release(instance);
              }
            }
          }
);
          synchronizationRegistered=true;
        }
        return context.proceed();
      }
 catch (      Exception e) {
        entityBeanComponent.getCache().release(instance,false);
        throw e;
      }
 finally {
        if (!synchronizationRegistered && !exception) {
          entityBeanComponent.getCache().release(instance,true);
        }
      }
    }
  }
;
}
