{
  for (  final AnnotationInstance sessionBeanAnnotation : sessionBeanAnnotations) {
    final AnnotationTarget target=sessionBeanAnnotation.target();
    if (!(target instanceof ClassInfo)) {
      logger.warn(sessionBeanAnnotation.name() + " annotation is expected to be only on classes. " + target+ " is not a class");
      continue;
    }
    final ClassInfo sessionBeanClassInfo=(ClassInfo)target;
    final String beanClassName=sessionBeanClassInfo.name().toString();
    final String ejbName=sessionBeanClassInfo.name().local();
    final AnnotationValue nameValue=sessionBeanAnnotation.value("name");
    final String beanName=nameValue == null || nameValue.asString().isEmpty() ? ejbName : nameValue.asString();
    SessionBeanComponentDescription sessionBeanDescription=null;
switch (sessionBeanType) {
case STATELESS:
      sessionBeanDescription=new StatelessComponentDescription(beanName,beanClassName,moduleDescription);
    break;
case STATEFUL:
  sessionBeanDescription=new StatefulComponentDescription(beanName,beanClassName,moduleDescription);
break;
case SINGLETON:
sessionBeanDescription=new SingletonComponentDescription(beanName,beanClassName,moduleDescription);
break;
default :
throw new IllegalArgumentException("Unknown session bean type: " + sessionBeanType);
}
if (moduleDescription.getComponentByName(sessionBeanDescription.getComponentName()) == null) {
moduleDescription.addComponent(sessionBeanDescription);
}
}
}
