{
  final AtomicInteger status=new AtomicInteger();
  final ModelNode finalResult=new ModelNode();
  finalResult.get(RESULT);
  final OperationResult handlerResult=execute(operation,new ResultHandler(){
    @Override public void handleResultFragment(    final String[] location,    final ModelNode fragment){
synchronized (finalResult) {
        if (status.get() == 0) {
          finalResult.get(RESULT).get(location).set(fragment);
        }
      }
    }
    @Override public void handleResultComplete(){
synchronized (finalResult) {
        if (status.compareAndSet(0,1)) {
        }
        finalResult.notify();
      }
    }
    @Override public void handleFailed(    final ModelNode failureDescription){
synchronized (finalResult) {
        if (status.compareAndSet(0,3)) {
          finalResult.remove(RESULT);
          finalResult.get(FAILURE_DESCRIPTION).set(failureDescription);
        }
        finalResult.notify();
      }
    }
    @Override public void handleCancellation(){
synchronized (finalResult) {
        if (status.compareAndSet(0,2)) {
          finalResult.remove(RESULT);
        }
        finalResult.notify();
      }
    }
  }
);
  boolean intr=false;
  try {
synchronized (finalResult) {
      for (; ; ) {
        try {
          final int s=status.get();
switch (s) {
case 1:
            finalResult.get(OUTCOME).set("success");
          if (handlerResult.getCompensatingOperation() != null) {
            finalResult.get(COMPENSATING_OPERATION).set(handlerResult.getCompensatingOperation());
          }
        return finalResult;
case 2:
      finalResult.get(OUTCOME).set("cancelled");
    throw new CancellationException();
case 3:
  finalResult.get(OUTCOME).set("failed");
return finalResult;
}
finalResult.wait();
}
 catch (final InterruptedException e) {
intr=true;
handlerResult.getCancellable().cancel();
}
}
}
}
  finally {
if (intr) {
Thread.currentThread().interrupt();
}
}
}
