{
  try {
    final PathAddress address=PathAddress.pathAddress(operation.require(ModelDescriptionConstants.ADDRESS));
    final String operationName=operation.require(ModelDescriptionConstants.OPERATION_NAME).asString();
    final OperationHandler operationHandler=registry.getOperationHandler(address,operationName);
    final ModelNode subModel;
    if (operationHandler instanceof ModelAddOperationHandler) {
      subModel=new ModelNode();
    }
 else     if (operationHandler instanceof ModelQueryOperationHandler) {
      final ModelNode model=this.model;
synchronized (model) {
        subModel=address.navigate(model,false).clone();
      }
    }
 else {
      subModel=null;
    }
    final NewOperationContext context=getOperationContext(subModel,operation,operationHandler);
    final ResultHandler useHandler=(operationHandler instanceof ModelUpdateOperationHandler) ? new ResultHandler(){
      @Override public void handleResultFragment(      final String[] location,      final ModelNode result){
        handler.handleResultFragment(location,result);
      }
      @Override public void handleResultComplete(      final ModelNode compensatingOperation){
        final ModelNode model=BasicModelController.this.model;
synchronized (model) {
          address.navigate(model,true).set(subModel);
        }
        handler.handleResultComplete(compensatingOperation);
        try {
          configurationPersister.store(model);
        }
 catch (        final ConfigurationPersistenceException e) {
          log.warnf("Failed to persist configuration change: %s",e);
        }
      }
      @Override public void handleFailed(      final ModelNode failureDescription){
        handler.handleFailed(failureDescription);
      }
      @Override public void handleCancellation(){
        handler.handleCancellation();
      }
    }
 : handler;
    return doExecute(context,operation,operationHandler,useHandler);
  }
 catch (  final Throwable t) {
    handler.handleFailed(getFailureResult(t));
    return Cancellable.NULL;
  }
}
