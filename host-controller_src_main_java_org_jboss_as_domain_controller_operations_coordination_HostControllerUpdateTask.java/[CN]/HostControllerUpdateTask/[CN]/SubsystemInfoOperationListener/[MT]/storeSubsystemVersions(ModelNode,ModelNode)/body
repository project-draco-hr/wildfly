{
  PathAddress address=operation.hasDefined(OP_ADDR) ? PathAddress.pathAddress(operation.get(OP_ADDR)) : PathAddress.EMPTY_ADDRESS;
  if (address.size() == 0 && COMPOSITE.equals(operation.get(OP).asString()) && response.hasDefined(RESULT)) {
    List<ModelNode> steps=operation.hasDefined(STEPS) ? operation.get(STEPS).asList() : Collections.<ModelNode>emptyList();
    ModelNode result=response.get(RESULT);
    for (int i=0; i < steps.size(); i++) {
      ModelNode stepOp=steps.get(i);
      String resultID="step-" + (i + 1);
      if (result.hasDefined(resultID)) {
        storeSubsystemVersions(stepOp,result.get(resultID));
      }
    }
  }
 else   if (address.size() == 1 && ADD.equals(operation.get(OP).asString()) && EXTENSION.equals(address.getElement(0).getKey()) && response.hasDefined(RESULT) && response.get(RESULT).hasDefined(DOMAIN_RESULTS)) {
    TransformationTarget target=transformers.getTarget();
    for (    Property p : response.get(RESULT,DOMAIN_RESULTS).asPropertyList()) {
      String[] version=p.getValue().asString().split("\\.");
      int major=Integer.parseInt(version[0]);
      int minor=Integer.parseInt(version[1]);
      target.addSubsystemVersion(p.getName(),major,minor);
      HOST_CONTROLLER_LOGGER.debugf("Registering subsystem %s for host %s with major version [%d] and minor version [%d]",p.getName(),address,major,minor);
    }
    response.get(RESULT).set(new ModelNode());
  }
}
