{
  try {
    boolean trace=HOST_CONTROLLER_LOGGER.isTraceEnabled();
    if (trace) {
      HOST_CONTROLLER_LOGGER.tracef("Sending %s to %s",operation,host);
    }
    OperationMessageHandler messageHandler=new DelegatingMessageHandler(context);
    final AtomicReference<ModelController.OperationTransaction> txRef=new AtomicReference<ModelController.OperationTransaction>();
    final AtomicReference<ModelNode> preparedResultRef=new AtomicReference<ModelNode>();
    final AtomicReference<ModelNode> finalResultRef=new AtomicReference<ModelNode>();
    final ProxyController.ProxyOperationControl proxyControl=new ProxyController.ProxyOperationControl(){
      @Override public void operationPrepared(      ModelController.OperationTransaction transaction,      ModelNode result){
        txRef.set(transaction);
        preparedResultRef.set(result);
      }
      @Override public void operationFailed(      ModelNode response){
        finalResultRef.set(response);
      }
      @Override public void operationCompleted(      ModelNode response){
        finalResultRef.set(response);
      }
    }
;
    proxyController.execute(operation,messageHandler,proxyControl,new DelegatingOperationAttachments(context));
    ModelController.OperationTransaction remoteTransaction=null;
    ModelNode result=finalResultRef.get();
    if (result != null) {
      if (trace) {
        HOST_CONTROLLER_LOGGER.tracef("Received final result %s from %s",result,host);
      }
    }
 else {
      result=preparedResultRef.get();
      if (trace) {
        HOST_CONTROLLER_LOGGER.tracef("Received prepared result %s from %s",result,host);
      }
      remoteTransaction=txRef.get();
    }
synchronized (uncommittedResultRef) {
      uncommittedResultRef.set(result);
      uncommittedResultRef.notifyAll();
    }
    if (remoteTransaction != null) {
      if (cancelRemoteTransaction) {
        remoteTransaction.rollback();
      }
 else {
synchronized (transactionAction) {
          while (transactionAction.get() == null) {
            try {
              transactionAction.wait();
            }
 catch (            InterruptedException ie) {
              transactionAction.set(Boolean.FALSE);
            }
          }
          if (transactionAction.get().booleanValue()) {
            remoteTransaction.commit();
          }
 else {
            remoteTransaction.rollback();
          }
        }
      }
    }
    return finalResultRef.get();
  }
 catch (  Exception e) {
    ModelNode node=new ModelNode();
    node.get(OUTCOME).set(FAILED);
    node.get(FAILURE_DESCRIPTION).set(e.getMessage());
    exception=e;
    uncommittedResultRef.set(node);
synchronized (uncommittedResultRef) {
      uncommittedResultRef.notifyAll();
    }
    throw e;
  }
}
