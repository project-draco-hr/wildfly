{
  final DataInputStream input=new DataInputStream(messageInputStream);
  final short invocationId=input.readShort();
  final String appName=input.readUTF();
  final String moduleName=input.readUTF();
  final String distinctName=input.readUTF();
  final String beanName=input.readUTF();
  final String viewClassName=input.readUTF();
  final EjbDeploymentInformation ejbDeploymentInformation=this.findEJB(appName,moduleName,distinctName,beanName);
  if (ejbDeploymentInformation == null) {
    this.writeNoSuchEJBFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,viewClassName);
    return;
  }
  if (!ejbDeploymentInformation.getViewNames().contains(viewClassName)) {
    this.writeNoSuchEJBFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,viewClassName);
    return;
  }
  final ComponentView componentView=ejbDeploymentInformation.getView(viewClassName);
  final String methodName=input.readUTF();
  String[] methodParamTypes=null;
  final String signature=input.readUTF();
  if (signature.isEmpty()) {
    methodParamTypes=new String[0];
  }
 else {
    methodParamTypes=signature.split(String.valueOf(METHOD_PARAM_TYPE_SEPARATOR));
  }
  final Method invokedMethod=this.findMethod(componentView,methodName,methodParamTypes);
  if (invokedMethod == null) {
    this.writeNoSuchEJBMethodFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,viewClassName,methodName,methodParamTypes);
    return;
  }
  final RemotingAttachments attachments=this.readAttachments(input);
  final Object[] methodParams=new Object[methodParamTypes.length];
  if (methodParamTypes.length > 0) {
    final UnMarshaller unMarshaller=MarshallerFactory.createUnMarshaller(this.marshallingStrategy);
    final ClassLoader beanClassLoader=ejbDeploymentInformation.getDeploymentClassLoader();
    unMarshaller.start(input,beanClassLoader);
    for (int i=0; i < methodParamTypes.length; i++) {
      try {
        methodParams[i]=unMarshaller.readObject();
      }
 catch (      ClassNotFoundException cnfe) {
        return;
      }
    }
    unMarshaller.finish();
  }
  executorService.submit(new Runnable(){
    @Override public void run(){
      if (componentView.isAsynchronous(invokedMethod)) {
        try {
          MethodInvocationMessageHandler.this.writeAsyncMethodNotification(channel,invocationId);
        }
 catch (        Throwable t) {
          logger.warn("Method " + invokedMethod + " was a async method but the client could not be informed about the same. This will mean that the client might block till the method completes",t);
        }
      }
      Object result=null;
      try {
        result=invokeMethod(componentView,invokedMethod,methodParams,attachments);
      }
 catch (      Throwable throwable) {
        try {
          writeMethodInvocationFailure(channel,invocationId,throwable,attachments);
        }
 catch (        IOException ioe) {
          logger.error("Error invoking method " + invokedMethod + " on bean named "+ beanName+ " in app: "+ appName+ " module: "+ moduleName+ " distinctname: "+ distinctName,throwable);
          logger.error("Could not write method invocation failure for method " + invokedMethod + " on bean named "+ beanName+ " in app: "+ appName+ " module: "+ moduleName+ " distinctname: "+ distinctName+ " due to ",ioe);
          return;
        }
      }
      try {
        writeMethodInvocationResponse(channel,invocationId,result,attachments);
      }
 catch (      IOException ioe) {
        logger.error("Could not write method invocation result for method " + invokedMethod + " on bean named "+ beanName+ " in app: "+ appName+ " module: "+ moduleName+ " distinctname: "+ distinctName+ " due to ",ioe);
        return;
      }
    }
  }
);
}
