{
  final DataInputStream input=new DataInputStream(messageInputStream);
  final short invocationId=input.readShort();
  final String methodName=input.readUTF();
  String[] methodParamTypes=null;
  final String signature=input.readUTF();
  if (signature.isEmpty()) {
    methodParamTypes=new String[0];
  }
 else {
    methodParamTypes=signature.split(String.valueOf(METHOD_PARAM_TYPE_SEPARATOR));
  }
  final RemotingAttachments attachments=this.readAttachments(input);
  final UnMarshaller unMarshaller=MarshallerFactory.createUnMarshaller(this.marshallingStrategy);
  final ClassLoaderSwitchingClassLoaderProvider classLoaderProvider=new ClassLoaderSwitchingClassLoaderProvider(Thread.currentThread().getContextClassLoader());
  unMarshaller.start(input,classLoaderProvider);
  final String appName;
  final String moduleName;
  final String distinctName;
  final String beanName;
  try {
    appName=(String)unMarshaller.readObject();
    moduleName=(String)unMarshaller.readObject();
    distinctName=(String)unMarshaller.readObject();
    beanName=(String)unMarshaller.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  final EjbDeploymentInformation ejbDeploymentInformation=this.findEJB(appName,moduleName,distinctName,beanName);
  if (ejbDeploymentInformation == null) {
    this.writeNoSuchEJBFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,null);
    return;
  }
  classLoaderProvider.switchClassLoader(ejbDeploymentInformation.getDeploymentClassLoader());
  final Locator locator;
  try {
    locator=(Locator)unMarshaller.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  final String viewClassName=locator.getInterfaceType().getName();
  if (!ejbDeploymentInformation.getViewNames().contains(viewClassName)) {
    this.writeNoSuchEJBFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,viewClassName);
    return;
  }
  final ComponentView componentView=ejbDeploymentInformation.getView(viewClassName);
  final Method invokedMethod=this.findMethod(componentView,methodName,methodParamTypes);
  if (invokedMethod == null) {
    this.writeNoSuchEJBMethodFailureMessage(channel,invocationId,appName,moduleName,distinctName,beanName,viewClassName,methodName,methodParamTypes);
    return;
  }
  final Object[] methodParams=new Object[methodParamTypes.length];
  if (methodParamTypes.length > 0) {
    for (int i=0; i < methodParamTypes.length; i++) {
      try {
        methodParams[i]=unMarshaller.readObject();
      }
 catch (      ClassNotFoundException cnfe) {
        throw new RuntimeException(cnfe);
      }
    }
  }
  unMarshaller.finish();
  executorService.submit(new Runnable(){
    @Override public void run(){
      if (componentView.isAsynchronous(invokedMethod)) {
        try {
          MethodInvocationMessageHandler.this.writeAsyncMethodNotification(channel,invocationId);
        }
 catch (        Throwable t) {
          logger.warn("Method " + invokedMethod + " was a async method but the client could not be informed about the same. This will mean that the client might block till the method completes",t);
        }
      }
      Object result=null;
      try {
        result=invokeMethod(componentView,invokedMethod,methodParams,locator,attachments);
      }
 catch (      Throwable throwable) {
        try {
          MethodInvocationMessageHandler.this.writeException(channel,invocationId,throwable,attachments);
        }
 catch (        IOException ioe) {
          logger.error("Error invoking method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName,throwable);
          logger.error("Could not write method invocation failure for method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName+ " due to ",ioe);
          IoUtils.safeClose(channel);
          return;
        }
      }
      try {
        writeMethodInvocationResponse(channel,invocationId,result,attachments);
      }
 catch (      IOException ioe) {
        logger.error("Could not write method invocation result for method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName+ " due to ",ioe);
        IoUtils.safeClose(channel);
        return;
      }
    }
  }
);
}
