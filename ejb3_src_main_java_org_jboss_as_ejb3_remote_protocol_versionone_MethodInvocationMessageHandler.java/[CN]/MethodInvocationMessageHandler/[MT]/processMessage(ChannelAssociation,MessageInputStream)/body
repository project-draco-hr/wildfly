{
  final DataInputStream input=new DataInputStream(messageInputStream);
  final short invocationId=input.readShort();
  final String methodName=input.readUTF();
  String[] methodParamTypes=null;
  final String signature=input.readUTF();
  if (signature.isEmpty()) {
    methodParamTypes=new String[0];
  }
 else {
    methodParamTypes=signature.split(String.valueOf(METHOD_PARAM_TYPE_SEPARATOR));
  }
  final ClassLoaderSwitchingClassResolver classResolver=new ClassLoaderSwitchingClassResolver(Thread.currentThread().getContextClassLoader());
  final Unmarshaller unmarshaller=this.prepareForUnMarshalling(this.marshallerFactory,classResolver,input);
  final String appName;
  final String moduleName;
  final String distinctName;
  final String beanName;
  try {
    appName=(String)unmarshaller.readObject();
    moduleName=(String)unmarshaller.readObject();
    distinctName=(String)unmarshaller.readObject();
    beanName=(String)unmarshaller.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  final EjbDeploymentInformation ejbDeploymentInformation=this.findEJB(appName,moduleName,distinctName,beanName);
  if (ejbDeploymentInformation == null) {
    this.writeNoSuchEJBFailureMessage(channelAssociation,invocationId,appName,moduleName,distinctName,beanName,null);
    return;
  }
  final ClassLoader tccl=SecurityActions.getContextClassLoader();
  Runnable runnable=null;
  try {
    SecurityActions.setContextClassLoader(ejbDeploymentInformation.getDeploymentClassLoader());
    classResolver.switchClassLoader(ejbDeploymentInformation.getDeploymentClassLoader());
    final EJBLocator locator;
    try {
      locator=(EJBLocator)unmarshaller.readObject();
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeException(e);
    }
    final String viewClassName=locator.getViewType().getName();
    if (!ejbDeploymentInformation.isRemoteView(viewClassName)) {
      this.writeNoSuchEJBFailureMessage(channelAssociation,invocationId,appName,moduleName,distinctName,beanName,viewClassName);
      return;
    }
    final ComponentView componentView=ejbDeploymentInformation.getView(viewClassName);
    final Method invokedMethod=this.findMethod(componentView,methodName,methodParamTypes);
    if (invokedMethod == null) {
      this.writeNoSuchEJBMethodFailureMessage(channelAssociation,invocationId,appName,moduleName,distinctName,beanName,viewClassName,methodName,methodParamTypes);
      return;
    }
    final Object[] methodParams=new Object[methodParamTypes.length];
    if (methodParamTypes.length > 0) {
      for (int i=0; i < methodParamTypes.length; i++) {
        try {
          methodParams[i]=unmarshaller.readObject();
        }
 catch (        ClassNotFoundException cnfe) {
          MethodInvocationMessageHandler.this.writeException(channelAssociation,MethodInvocationMessageHandler.this.marshallerFactory,invocationId,cnfe,null);
          return;
        }
      }
    }
    final Map<String,Object> attachments;
    try {
      attachments=this.readAttachments(unmarshaller);
    }
 catch (    ClassNotFoundException cnfe) {
      MethodInvocationMessageHandler.this.writeException(channelAssociation,MethodInvocationMessageHandler.this.marshallerFactory,invocationId,cnfe,null);
      return;
    }
    unmarshaller.finish();
    runnable=new Runnable(){
      @Override public void run(){
        if (componentView.isAsynchronous(invokedMethod)) {
          try {
            MethodInvocationMessageHandler.this.writeAsyncMethodNotification(channelAssociation,invocationId);
          }
 catch (          Throwable t) {
            logger.warn("Method " + invokedMethod + " was a async method but the client could not be informed about the same. This will mean that the client might block till the method completes",t);
          }
        }
        Object result=null;
        RemotingContext.setConnection(channelAssociation.getChannel().getConnection());
        try {
          result=invokeMethod(componentView,invokedMethod,methodParams,locator,attachments);
        }
 catch (        Throwable throwable) {
          try {
            MethodInvocationMessageHandler.this.writeException(channelAssociation,MethodInvocationMessageHandler.this.marshallerFactory,invocationId,throwable,attachments);
          }
 catch (          IOException ioe) {
            logger.error("Error invoking method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName,throwable);
            logger.error("Could not write method invocation failure for method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName+ " due to ",ioe);
            IoUtils.safeClose(channelAssociation.getChannel());
            return;
          }
        }
 finally {
          RemotingContext.clear();
        }
        try {
          if (locator instanceof StatefulEJBLocator && componentView.getComponent() instanceof StatefulSessionComponent) {
            final StatefulSessionComponent statefulSessionComponent=(StatefulSessionComponent)componentView.getComponent();
            final Affinity weakAffinity=MethodInvocationMessageHandler.this.getWeakAffinity(statefulSessionComponent,(StatefulEJBLocator)locator);
            if (weakAffinity != null) {
              attachments.put(Affinity.WEAK_AFFINITY_CONTEXT_KEY,weakAffinity);
            }
          }
          writeMethodInvocationResponse(channelAssociation,invocationId,result,attachments);
        }
 catch (        IOException ioe) {
          logger.error("Could not write method invocation result for method " + invokedMethod + " on bean named "+ beanName+ " for appname "+ appName+ " modulename "+ moduleName+ " distinctname "+ distinctName+ " due to ",ioe);
          IoUtils.safeClose(channelAssociation.getChannel());
          return;
        }
      }
    }
;
  }
  finally {
    SecurityActions.setContextClassLoader(tccl);
  }
  executorService.submit(runnable);
}
