{
  final Lock lock=getLock(timerEntity.getTimedObjectId());
  try {
    final int status=transactionManager.getValue().getStatus();
    if (status == Status.STATUS_MARKED_ROLLBACK || status == Status.STATUS_ROLLEDBACK || status == Status.STATUS_ROLLING_BACK) {
      return;
    }
    lock.lock();
    if (status == Status.STATUS_NO_TRANSACTION || status == Status.STATUS_UNKNOWN || isBeforeCompletion() || status == Status.STATUS_COMMITTED) {
      Map<String,TimerEntity> map=getTimers(timerEntity.getTimedObjectId());
      if (timerEntity.getTimerState() == TimerState.CANCELED || timerEntity.getTimerState() == TimerState.EXPIRED) {
        map.remove(timerEntity.getId());
        writeFile(timerEntity);
      }
 else       if (newTimer || map.containsKey(timerEntity.getId())) {
        map.put(timerEntity.getId(),timerEntity);
        writeFile(timerEntity);
      }
    }
 else {
      final String key=timerTransactionKey(timerEntity);
      Object existing=transactionSynchronizationRegistry.getValue().getResource(key);
      if (existing == null) {
        transactionSynchronizationRegistry.getValue().registerInterposedSynchronization(new PersistTransactionSynchronization(lock,key,newTimer));
      }
      transactionSynchronizationRegistry.getValue().putResource(key,timerEntity);
    }
  }
 catch (  SystemException e) {
    throw new RuntimeException(e);
  }
 finally {
    lock.unlock();
  }
}
