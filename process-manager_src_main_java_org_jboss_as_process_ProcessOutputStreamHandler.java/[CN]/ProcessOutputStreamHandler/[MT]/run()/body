{
  final StringBuilder b=new StringBuilder();
  final String processName=managed.getProcessName();
  try {
    for (; ; ) {
      Status status=StreamUtils.readWord(inputStream,b);
      if (status == Status.END_OF_STREAM) {
        log.info("Received end of stream, shutting down " + processName);
        managed.closeCommandStream();
        return;
      }
      try {
        final Command command=Command.valueOf(b.toString());
        OUT: switch (command) {
case ADD:
{
            if (status != Status.MORE) {
              break;
            }
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String name=b.toString();
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String workingDirectory=b.toString();
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String sizeString=b.toString();
            final int size;
            try {
              size=Integer.parseInt(sizeString,10);
            }
 catch (            NumberFormatException e) {
              e.printStackTrace(System.err);
              break;
            }
            final List<String> execCmd=new ArrayList<String>();
            for (int i=0; i < size; i++) {
              status=StreamUtils.readWord(inputStream,b);
              if (status != Status.MORE) {
                break OUT;
              }
              execCmd.add(b.toString());
            }
            status=StreamUtils.readWord(inputStream,b);
            if (status != Status.MORE) {
              break;
            }
            final String mapSizeString=b.toString();
            final int mapSize, lastEntry;
            try {
              mapSize=Integer.parseInt(mapSizeString,10);
              lastEntry=mapSize - 1;
            }
 catch (            NumberFormatException e) {
              e.printStackTrace(System.err);
              break;
            }
            final Map<String,String> env=new HashMap<String,String>();
            for (int i=0; i < mapSize; i++) {
              status=StreamUtils.readWord(inputStream,b);
              if (status != Status.MORE) {
                break OUT;
              }
              final String key=b.toString();
              status=StreamUtils.readWord(inputStream,b);
              if (status == Status.MORE || (i == lastEntry && status == Status.END_OF_LINE)) {
                env.put(key,b.toString());
              }
 else {
                break OUT;
              }
            }
            master.addProcess(name,execCmd,env,workingDirectory);
            break;
          }
case START:
{
          if (status != Status.MORE) {
            break;
          }
          status=StreamUtils.readWord(inputStream,b);
          final String name=b.toString();
          master.startProcess(name);
          break;
        }
case STOP:
{
        if (status != Status.MORE) {
          break;
        }
        status=StreamUtils.readWord(inputStream,b);
        final String name=b.toString();
        master.stopProcess(name);
        break;
      }
case SERVERS_SHUTDOWN:
{
      if (processName.equals(ProcessManagerMaster.SERVER_MANAGER_PROCESS_NAME)) {
        master.serversShutdown();
      }
 else {
        log.warnf("%s received from wrong process %s",Command.SERVERS_SHUTDOWN,processName);
      }
      break;
    }
case REMOVE:
{
    if (status != Status.MORE) {
      break;
    }
    status=StreamUtils.readWord(inputStream,b);
    final String name=b.toString();
    master.removeProcess(name);
    break;
  }
case SEND:
{
  if (status != Status.MORE) {
    break;
  }
  status=StreamUtils.readWord(inputStream,b);
  final String recipient=b.toString();
  final List<String> msg=new ArrayList<String>(0);
  while (status == Status.MORE) {
    status=StreamUtils.readWord(inputStream,b);
    msg.add(b.toString());
  }
  master.sendMessage(processName,recipient,msg);
  break;
}
case SEND_BYTES:
{
if (status != Status.MORE) {
  break;
}
status=StreamUtils.readWord(inputStream,b);
if (status == Status.MORE) {
  final String recipient=b.toString();
  master.sendMessage(processName,recipient,StreamUtils.readBytesWithLength(inputStream));
  status=StreamUtils.readStatus(inputStream);
}
break;
}
case BROADCAST:
{
final List<String> msg=new ArrayList<String>(0);
while (status == Status.MORE) {
status=StreamUtils.readWord(inputStream,b);
msg.add(b.toString());
}
master.broadcastMessage(processName,msg);
break;
}
case BROADCAST_BYTES:
{
if (status == Status.MORE) {
master.broadcastMessage(processName,StreamUtils.readBytesWithLength(inputStream));
status=StreamUtils.readStatus(inputStream);
}
break;
}
case RECONNECT_SERVERS:
{
status=StreamUtils.readWord(inputStream,b);
if (status != Status.MORE) {
break;
}
final String smAddress=b.toString();
status=StreamUtils.readWord(inputStream,b);
final String smPort=b.toString();
master.reconnectServersToServerManager(smAddress,smPort);
break;
}
}
}
 catch (IllegalArgumentException e) {
log.error("Received unknown command: " + b.toString());
}
if (status == Status.MORE) StreamUtils.readToEol(inputStream);
}
}
 catch (Exception e) {
log.error("Output stream handler for process " + processName + " caught an exception; shutting down",e);
managed.closeCommandStream();
}
 finally {
ManagedProcess.safeClose(inputStream);
}
}
