{
  K key=entry.getId();
  if (cache.containsKey(key)) {
    throw EjbMessages.MESSAGES.duplicateCacheEntry(key);
  }
  CacheableTimestamp<K> timestamp=new CacheableTimestamp<K>(entry);
  cache.put(key,new EntryHolder(entry,timestamp));
  this.entries.add(timestamp);
  final Set<K> toPassivate=new HashSet<K>();
  int maxSize=this.getConfig().getMaxSize();
  int thisSize=cache.size();
  if (thisSize > maxSize) {
    int remaining=thisSize - maxSize;
    final Iterator<CacheableTimestamp<K>> iterator=this.entries.iterator();
    while (remaining > 0 && iterator.hasNext()) {
      final EntryHolder holder=this.cache.get(iterator.next().getId());
      if (holder != null && !holder.value.getId().equals(timestamp.getId()) && !holder.value.isInUse()) {
        remaining--;
        toPassivate.add(holder.value.getId());
      }
    }
  }
  return toPassivate;
}
