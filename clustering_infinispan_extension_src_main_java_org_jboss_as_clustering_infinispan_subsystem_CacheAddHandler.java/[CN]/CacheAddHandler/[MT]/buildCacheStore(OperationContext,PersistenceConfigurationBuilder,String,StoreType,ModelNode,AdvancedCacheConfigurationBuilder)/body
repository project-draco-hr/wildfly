{
switch (storeType) {
case FILE:
{
      final SingleFileStoreConfigurationBuilder builder=persistenceBuilder.addSingleFileStore();
      final String path=ModelNodes.asString(FileStoreResourceDefinition.RELATIVE_PATH.resolveModelAttribute(context,store),InfinispanExtension.SUBSYSTEM_NAME + File.separatorChar + containerName);
      final String relativeTo=FileStoreResourceDefinition.RELATIVE_TO.resolveModelAttribute(context,store).asString();
      Injector<PathManager> injector=new Injector<PathManager>(){
        private volatile PathManager.Callback.Handle callbackHandle;
        @Override public void inject(        PathManager value){
          this.callbackHandle=value.registerCallback(relativeTo,PathManager.ReloadServerCallback.create(),PathManager.Event.UPDATED,PathManager.Event.REMOVED);
          builder.location(value.resolveRelativePathEntry(path,relativeTo));
        }
        @Override public void uninject(){
          if (this.callbackHandle != null) {
            this.callbackHandle.remove();
          }
        }
      }
;
      configBuilder.addDependency(PathManagerService.SERVICE_NAME,PathManager.class,injector);
      return builder;
    }
case STRING_KEYED_JDBC:
case BINARY_KEYED_JDBC:
case MIXED_KEYED_JDBC:
{
    DatabaseType dialect=ModelNodes.asEnum(JDBCStoreResourceDefinition.DIALECT.resolveModelAttribute(context,store),DatabaseType.class);
    AbstractJdbcStoreConfigurationBuilder<?,?> builder=buildJdbcStore(persistenceBuilder,context,store).dialect(dialect);
    String datasource=JDBCStoreResourceDefinition.DATA_SOURCE.resolveModelAttribute(context,store).asString();
    configBuilder.addDependency(ServiceName.JBOSS.append("data-source",datasource));
    builder.dataSource().jndiUrl(datasource);
    return builder;
  }
case REMOTE:
{
  final RemoteStoreConfigurationBuilder builder=persistenceBuilder.addStore(RemoteStoreConfigurationBuilder.class);
  for (  ModelNode server : store.require(ModelKeys.REMOTE_SERVERS).asList()) {
    String outboundSocketBinding=server.get(ModelKeys.OUTBOUND_SOCKET_BINDING).asString();
    Injector<OutboundSocketBinding> injector=new Injector<OutboundSocketBinding>(){
      @Override public void inject(      OutboundSocketBinding value){
        try {
          builder.addServer().host(value.getResolvedDestinationAddress().getHostAddress()).port(value.getDestinationPort());
        }
 catch (        UnknownHostException e) {
          throw InfinispanLogger.ROOT_LOGGER.failedToInjectSocketBinding(e,value);
        }
      }
      @Override public void uninject(){
      }
    }
;
    configBuilder.addDependency(OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBinding),OutboundSocketBinding.class,injector);
  }
  builder.remoteCacheName(RemoteStoreResourceDefinition.CACHE.resolveModelAttribute(context,store).asString());
  builder.socketTimeout(RemoteStoreResourceDefinition.SOCKET_TIMEOUT.resolveModelAttribute(context,store).asLong());
  builder.tcpNoDelay(RemoteStoreResourceDefinition.TCP_NO_DELAY.resolveModelAttribute(context,store).asBoolean());
  return builder;
}
case CUSTOM:
{
String className=store.require(ModelKeys.CLASS).asString();
try {
  return persistenceBuilder.addStore(StoreConfigurationBuilder.class.getClassLoader().loadClass(className).asSubclass(StoreConfigurationBuilder.class));
}
 catch (Exception e) {
  throw InfinispanLogger.ROOT_LOGGER.invalidCacheStore(e,className);
}
}
default :
{
throw new IllegalStateException();
}
}
}
