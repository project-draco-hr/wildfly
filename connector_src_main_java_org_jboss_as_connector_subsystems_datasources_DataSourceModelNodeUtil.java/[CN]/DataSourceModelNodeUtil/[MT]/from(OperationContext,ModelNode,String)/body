{
  final Map<String,String> connectionProperties=Collections.emptyMap();
  final String connectionUrl=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,CONNECTION_URL,null);
  final String driverClass=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,DRIVER_CLASS,null);
  final String dataSourceClass=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,DATASOURCE_CLASS,null);
  final String jndiName=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,JNDI_NAME,null);
  final String driver=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,DATASOURCE_DRIVER,null);
  final String newConnectionSql=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,NEW_CONNECTION_SQL,null);
  final String poolName=dsName;
  final String urlDelimiter=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,URL_DELIMITER,null);
  final String urlSelectorStrategyClassName=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,URL_SELECTOR_STRATEGY_CLASS_NAME,null);
  final boolean useJavaContext=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_JAVA_CONTEXT,Defaults.USE_JAVA_CONTEXT);
  final boolean enabled=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,ENABLED,Defaults.ENABLED);
  final boolean jta=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,JTA,Defaults.JTA);
  final Integer maxPoolSize=getIntIfSetOrGetDefault(operationContext,dataSourceNode,MAX_POOL_SIZE,Defaults.MAX_POOL_SIZE);
  final Integer minPoolSize=getIntIfSetOrGetDefault(operationContext,dataSourceNode,MIN_POOL_SIZE,Defaults.MIN_POOL_SIZE);
  final boolean prefill=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,POOL_PREFILL,Defaults.PREFILL);
  final boolean useStrictMin=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,POOL_USE_STRICT_MIN,Defaults.USE_STRICT_MIN);
  final String flushStrategyString=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,POOL_FLUSH_STRATEGY,Defaults.FLUSH_STRATEGY.toString());
  final FlushStrategy flushStrategy=FlushStrategy.forName(flushStrategyString);
  final Boolean allowMultipleUsers=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,ALLOW_MULTIPLE_USERS,Defaults.ALLOW_MULTIPLE_USERS);
  final DsPool pool=new DsPoolImpl(minPoolSize,maxPoolSize,prefill,useStrictMin,flushStrategy,allowMultipleUsers);
  final String username=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,USERNAME,null);
  final String password=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,PASSWORD,null);
  final String securityDomain=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,SECURITY_DOMAIN,null);
  final Extension reauthPlugin=extractExtension(operationContext,dataSourceNode,REAUTH_PLUGIN_CLASSNAME,REAUTHPLUGIN_PROPERTIES);
  final DsSecurity security=new DsSecurityImpl(username,password,securityDomain,reauthPlugin);
  final boolean sharePreparedStatements=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SHARE_PREPARED_STATEMENTS,Defaults.SHARE_PREPARED_STATEMENTS);
  final Long preparedStatementsCacheSize=getLongIfSetOrGetDefault(operationContext,dataSourceNode,PREPARED_STATEMENTS_CACHE_SIZE,null);
  final String trackStatementsString=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,TRACK_STATEMENTS,Defaults.TRACK_STATEMENTS.toString());
  final Statement.TrackStatementsEnum trackStatements=Statement.TrackStatementsEnum.valueOf(trackStatementsString.toUpperCase(Locale.ENGLISH));
  final Statement statement=new StatementImpl(sharePreparedStatements,preparedStatementsCacheSize,trackStatements);
  final Integer allocationRetry=getIntIfSetOrGetDefault(operationContext,dataSourceNode,ALLOCATION_RETRY,null);
  final Long allocationRetryWaitMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,ALLOCATION_RETRY_WAIT_MILLIS,null);
  final Long blockingTimeoutMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,BLOCKING_TIMEOUT_WAIT_MILLIS,null);
  final Long idleTimeoutMinutes=getLongIfSetOrGetDefault(operationContext,dataSourceNode,IDLETIMEOUTMINUTES,null);
  final Long queryTimeout=getLongIfSetOrGetDefault(operationContext,dataSourceNode,QUERY_TIMEOUT,null);
  final Integer xaResourceTimeout=getIntIfSetOrGetDefault(operationContext,dataSourceNode,XA_RESOURCE_TIMEOUT,null);
  final Long useTryLock=getLongIfSetOrGetDefault(operationContext,dataSourceNode,USE_TRY_LOCK,null);
  final boolean setTxQueryTimeout=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SET_TX_QUERY_TIMEOUT,Defaults.SET_TX_QUERY_TIMEOUT);
  final TimeOut timeOut=new TimeOutImpl(blockingTimeoutMillis,idleTimeoutMinutes,allocationRetry,allocationRetryWaitMillis,xaResourceTimeout,setTxQueryTimeout,queryTimeout,useTryLock);
  final String transactionIsolationString=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,TRANSACTION_ISOLATION,null);
  TransactionIsolation transactionIsolation=null;
  if (transactionIsolationString != null) {
    transactionIsolation=TransactionIsolation.forName(transactionIsolationString);
    if (transactionIsolation == null) {
      transactionIsolation=TransactionIsolation.customLevel(transactionIsolationString);
    }
  }
  final String checkValidConnectionSql=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,CHECK_VALID_CONNECTION_SQL,null);
  final Extension exceptionSorter=extractExtension(operationContext,dataSourceNode,EXCEPTION_SORTER_CLASSNAME,EXCEPTION_SORTER_PROPERTIES);
  final Extension staleConnectionChecker=extractExtension(operationContext,dataSourceNode,STALE_CONNECTION_CHECKER_CLASSNAME,STALE_CONNECTION_CHECKER_PROPERTIES);
  final Extension validConnectionChecker=extractExtension(operationContext,dataSourceNode,VALID_CONNECTION_CHECKER_CLASSNAME,VALID_CONNECTION_CHECKER_PROPERTIES);
  Long backgroundValidationMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,BACKGROUNDVALIDATIONMILLIS,null);
  final boolean backgroundValidation=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,BACKGROUNDVALIDATION,Defaults.BACKGROUND_VALIDATION);
  boolean useFastFail=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_FAST_FAIL,Defaults.USE_FAST_FAIL);
  final boolean validateOnMatch=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,VALIDATE_ON_MATCH,Defaults.VALIDATE_ON_MATCH);
  final boolean spy=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SPY,Defaults.SPY);
  final boolean useCcm=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_CCM,Defaults.USE_CCM);
  final Validation validation=new ValidationImpl(backgroundValidation,backgroundValidationMillis,useFastFail,validConnectionChecker,checkValidConnectionSql,validateOnMatch,staleConnectionChecker,exceptionSorter);
  return new ModifiableDataSource(connectionUrl,driverClass,dataSourceClass,driver,transactionIsolation,connectionProperties,timeOut,security,statement,validation,urlDelimiter,urlSelectorStrategyClassName,newConnectionSql,useJavaContext,poolName,enabled,jndiName,spy,useCcm,jta,pool);
}
