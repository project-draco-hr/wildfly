{
  final Map<String,String> xaDataSourceProperty;
  xaDataSourceProperty=Collections.emptyMap();
  final String xaDataSourceClass=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,XADATASOURCECLASS,null);
  final String jndiName=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,JNDINAME,null);
  final String module=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,DATASOURCE_DRIVER,null);
  final String newConnectionSql=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,NEW_CONNECTION_SQL,null);
  final String poolName=dsName;
  final String urlDelimiter=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,URL_DELIMITER,null);
  final String urlSelectorStrategyClassName=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,URL_SELECTOR_STRATEGY_CLASS_NAME,null);
  final Boolean useJavaContext=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_JAVA_CONTEXT,Defaults.USE_JAVA_CONTEXT);
  final Boolean enabled=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,ENABLED,Defaults.ENABLED);
  final Integer maxPoolSize=getIntIfSetOrGetDefault(operationContext,dataSourceNode,MAX_POOL_SIZE,Defaults.MAX_POOL_SIZE);
  final Integer minPoolSize=getIntIfSetOrGetDefault(operationContext,dataSourceNode,MIN_POOL_SIZE,Defaults.MIN_POOL_SIZE);
  final Boolean prefill=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,POOL_PREFILL,Defaults.PREFILL);
  final Boolean useStrictMin=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,POOL_USE_STRICT_MIN,Defaults.USE_STRICT_MIN);
  final Boolean interleaving=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,INTERLEAVING,Defaults.INTERLEAVING);
  final Boolean noTxSeparatePool=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,NOTXSEPARATEPOOL,Defaults.NO_TX_SEPARATE_POOL);
  final Boolean padXid=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,PAD_XID,Defaults.PAD_XID);
  final Boolean isSameRmOverride=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SAME_RM_OVERRIDE,Defaults.IS_SAME_RM_OVERRIDE);
  final Boolean wrapXaDataSource=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,WRAP_XA_RESOURCE,Defaults.WRAP_XA_RESOURCE);
  final FlushStrategy flushStrategy=dataSourceNode.hasDefined(POOL_FLUSH_STRATEGY.getName()) ? FlushStrategy.forName(dataSourceNode.get(POOL_FLUSH_STRATEGY.getName()).asString()) : Defaults.FLUSH_STRATEGY;
  final CommonXaPool xaPool=new CommonXaPoolImpl(minPoolSize,maxPoolSize,prefill,useStrictMin,flushStrategy,isSameRmOverride,interleaving,padXid,wrapXaDataSource,noTxSeparatePool);
  final String username=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,USERNAME,null);
  final String password=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,PASSWORD,null);
  final String securityDomain=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,SECURITY_DOMAIN,null);
  final Extension reauthPlugin=extractExtension(operationContext,dataSourceNode,REAUTHPLUGIN_CLASSNAME,REAUTHPLUGIN_PROPERTIES);
  final DsSecurity security=new DsSecurityImpl(username,password,securityDomain,reauthPlugin);
  final Boolean sharePreparedStatements=dataSourceNode.hasDefined(SHAREPREPAREDSTATEMENTS.getName()) ? dataSourceNode.get(SHAREPREPAREDSTATEMENTS.getName()).asBoolean() : Defaults.SHARE_PREPARED_STATEMENTS;
  final Long preparedStatementsCacheSize=getLongIfSetOrGetDefault(operationContext,dataSourceNode,PREPAREDSTATEMENTSCACHESIZE,null);
  final Statement.TrackStatementsEnum trackStatements=dataSourceNode.hasDefined(TRACKSTATEMENTS.getName()) ? Statement.TrackStatementsEnum.valueOf(dataSourceNode.get(TRACKSTATEMENTS.getName()).asString()) : Defaults.TRACK_STATEMENTS;
  final Statement statement=new StatementImpl(sharePreparedStatements,preparedStatementsCacheSize,trackStatements);
  final Integer allocationRetry=getIntIfSetOrGetDefault(operationContext,dataSourceNode,ALLOCATION_RETRY,null);
  final Long allocationRetryWaitMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,ALLOCATION_RETRY_WAIT_MILLIS,null);
  final Long blockingTimeoutMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,BLOCKING_TIMEOUT_WAIT_MILLIS,null);
  final Long idleTimeoutMinutes=getLongIfSetOrGetDefault(operationContext,dataSourceNode,IDLETIMEOUTMINUTES,null);
  final Long queryTimeout=getLongIfSetOrGetDefault(operationContext,dataSourceNode,QUERYTIMEOUT,null);
  final Integer xaResourceTimeout=getIntIfSetOrGetDefault(operationContext,dataSourceNode,XA_RESOURCE_TIMEOUT,null);
  final Long useTryLock=getLongIfSetOrGetDefault(operationContext,dataSourceNode,USETRYLOCK,null);
  final Boolean setTxQuertTimeout=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SETTXQUERYTIMEOUT,Defaults.SET_TX_QUERY_TIMEOUT);
  final TimeOut timeOut=new TimeOutImpl(blockingTimeoutMillis,idleTimeoutMinutes,allocationRetry,allocationRetryWaitMillis,xaResourceTimeout,setTxQuertTimeout,queryTimeout,useTryLock);
  final TransactionIsolation transactionIsolation=dataSourceNode.hasDefined(TRANSACTION_ISOLATION.getName()) ? TransactionIsolation.valueOf(dataSourceNode.get(TRANSACTION_ISOLATION.getName()).asString()) : null;
  final String checkValidConnectionSql=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,CHECKVALIDCONNECTIONSQL,null);
  final Extension exceptionSorter=extractExtension(operationContext,dataSourceNode,EXCEPTIONSORTERCLASSNAME,EXCEPTIONSORTER_PROPERTIES);
  final Extension staleConnectionChecker=extractExtension(operationContext,dataSourceNode,STALECONNECTIONCHECKERCLASSNAME,STALECONNECTIONCHECKER_PROPERTIES);
  final Extension validConnectionChecker=extractExtension(operationContext,dataSourceNode,VALIDCONNECTIONCHECKERCLASSNAME,VALIDCONNECTIONCHECKER_PROPERTIES);
  Long backgroundValidationMillis=getLongIfSetOrGetDefault(operationContext,dataSourceNode,BACKGROUNDVALIDATIONMILLIS,null);
  final Boolean backgroundValidation=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,BACKGROUNDVALIDATION,Defaults.BACKGROUND_VALIDATION);
  boolean useFastFail=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_FAST_FAIL,Defaults.USE_FAST_FAIl);
  final Boolean validateOnMatch=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,VALIDATEONMATCH,Defaults.VALIDATE_ON_MATCH);
  final Boolean spy=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,SPY,Defaults.SPY);
  final Boolean useCcm=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,USE_CCM,Defaults.USE_CCM);
  final Validation validation=new ValidationImpl(backgroundValidation,backgroundValidationMillis,useFastFail,validConnectionChecker,checkValidConnectionSql,validateOnMatch,staleConnectionChecker,exceptionSorter);
  final String recoveryUsername=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,RECOVERY_USERNAME,null);
  final String recoveryPassword=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,RECOVERY_PASSWORD,null);
  final String recoverySecurityDomain=getResolvedStringIfSetOrGetDefault(operationContext,dataSourceNode,RECOVERY_SECURITY_DOMAIN,null);
  Boolean noRecovery=getBooleanIfSetOrGetDefault(operationContext,dataSourceNode,NO_RECOVERY,null);
  Recovery recovery=null;
  if ((recoveryUsername != null && recoveryPassword != null) || recoverySecurityDomain != null || noRecovery != null) {
    Credential credential=null;
    if ((recoveryUsername != null && recoveryPassword != null) || recoverySecurityDomain != null)     credential=new CredentialImpl(recoveryUsername,recoveryPassword,recoverySecurityDomain);
    Extension recoverPlugin=extractExtension(operationContext,dataSourceNode,RECOVERLUGIN_CLASSNAME,RECOVERLUGIN_PROPERTIES);
    if (noRecovery == null)     noRecovery=Boolean.FALSE;
    recovery=new Recovery(credential,recoverPlugin,noRecovery);
  }
  return new ModifiableXaDataSource(transactionIsolation,timeOut,security,statement,validation,urlDelimiter,urlSelectorStrategyClassName,useJavaContext,poolName,enabled,jndiName,spy,useCcm,xaDataSourceProperty,xaDataSourceClass,module,newConnectionSql,xaPool,recovery);
}
