{
  requireNoAttributes(reader);
  final Set<String> found=new HashSet<String>();
  final ExtensionParsingContextImpl context=new ExtensionParsingContextImpl(reader.getXMLMapper());
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
    requireNamespace(reader,expectedNs);
    final Element element=Element.forName(reader.getLocalName());
    if (element != Element.EXTENSION) {
      throw unexpectedElement(reader);
    }
    final String moduleName=readStringAttributeElement(reader,Attribute.MODULE.getLocalName());
    if (!found.add(moduleName)) {
      throw invalidAttributeValue(reader,0);
    }
    try {
      final Module module=moduleLoader.loadModule(ModuleIdentifier.fromString(moduleName));
      boolean initialized=false;
      for (      final Extension extension : module.loadService(Extension.class)) {
        ClassLoader oldTccl=SecurityActions.setThreadContextClassLoader(extension.getClass());
        try {
          extension.initializeParsers(context);
        }
  finally {
          SecurityActions.setThreadContextClassLoader(oldTccl);
        }
        if (!initialized) {
          initialized=true;
        }
      }
      if (!initialized) {
        throw new IllegalStateException("No META-INF/services/" + Extension.class.getName() + " found for "+ module.getIdentifier());
      }
      final ModelNode add=new ModelNode();
      add.get(OP_ADDR).set(address).add(EXTENSION,moduleName);
      add.get(OP).set(ADD);
      list.add(add);
    }
 catch (    final ModuleLoadException e) {
      throw new XMLStreamException("Failed to load module",e);
    }
  }
}
