{
  final ProcessControllerClient client;
  try {
    final ThreadFactory threadFactory=new JBossThreadFactory(new ThreadGroup("ProcessControllerConnection-thread"),Boolean.FALSE,null,"%G - %t",null,null,doPrivileged(GetAccessControlContextAction.getInstance()));
    final ThreadPoolExecutor executorService=new ThreadPoolExecutor(THREAD_POOL_CORE_SIZE,THREAD_POOL_MAX_SIZE,30L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(WORK_QUEUE_SIZE),threadFactory);
    final ProtocolClient.Configuration configuration=new ProtocolClient.Configuration();
    configuration.setReadExecutor(executorService);
    configuration.setServerAddress(new InetSocketAddress(environment.getProcessControllerAddress(),environment.getProcessControllerPort().intValue()));
    configuration.setBindAddress(new InetSocketAddress(environment.getHostControllerAddress(),environment.getHostControllerPort()));
    configuration.setThreadFactory(threadFactory);
    configuration.setSocketFactory(SocketFactory.getDefault());
    client=ProcessControllerClient.connect(configuration,authCode,new ProcessMessageHandler(){
      @Override public void handleProcessAdded(      final ProcessControllerClient client,      final String processName){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        if (ManagedServer.isServerProcess(processName)) {
          serverInventory.serverProcessAdded(processName);
        }
      }
      @Override public void handleProcessStarted(      final ProcessControllerClient client,      final String processName){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        if (ManagedServer.isServerProcess(processName)) {
          serverInventory.serverProcessStarted(processName);
        }
      }
      @Override public void handleProcessStopped(      final ProcessControllerClient client,      final String processName,      final long uptimeMillis){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        if (ManagedServer.isServerProcess(processName)) {
          serverInventory.serverProcessStopped(processName);
        }
      }
      @Override public void handleProcessRemoved(      final ProcessControllerClient client,      final String processName){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        if (ManagedServer.isServerProcess(processName)) {
          serverInventory.serverProcessRemoved(processName);
        }
      }
      @Override public void handleProcessInventory(      final ProcessControllerClient client,      final Map<String,ProcessInfo> inventory){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        serverInventory.processInventory(inventory);
      }
      @Override public void handleConnectionShutdown(      final ProcessControllerClient client){
        if (serverInventory == null) {
          return;
        }
        serverInventory.connectionFinished();
      }
      @Override public void handleConnectionFailure(      final ProcessControllerClient client,      final IOException cause){
        if (serverInventory == null) {
          return;
        }
        serverInventory.connectionFinished();
      }
      @Override public void handleConnectionFinished(      final ProcessControllerClient client){
        if (serverInventory == null) {
          return;
        }
        serverInventory.connectionFinished();
      }
      @Override public void handleOperationFailed(      ProcessControllerClient client,      OperationType operation,      String processName){
        if (serverInventory == null) {
          throw MESSAGES.noServerInventory();
        }
        if (ManagedServer.isServerProcess(processName)) {
          serverInventory.operationFailed(processName,operation);
        }
      }
    }
);
  }
 catch (  IOException e) {
    throw new StartException(e);
  }
  this.client=client;
}
