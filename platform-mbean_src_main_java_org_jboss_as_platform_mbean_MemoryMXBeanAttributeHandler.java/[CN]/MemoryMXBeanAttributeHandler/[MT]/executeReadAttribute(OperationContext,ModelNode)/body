{
  final String name=operation.require(ModelDescriptionConstants.NAME).asString();
  if (PlatformMBeanUtil.JVM_MAJOR_VERSION > 6 && PlatformMBeanConstants.OBJECT_NAME.equals(name)) {
    context.getResult().set(ManagementFactory.MEMORY_MXBEAN_NAME);
  }
 else   if (PlatformMBeanConstants.OBJECT_PENDING_FINALIZATION_COUNT.equals(name)) {
    context.getResult().set(ManagementFactory.getMemoryMXBean().getObjectPendingFinalizationCount());
  }
 else   if (PlatformMBeanConstants.HEAP_MEMORY_USAGE.equals(name)) {
    final ModelNode mu=PlatformMBeanUtil.getDetypedMemoryUsage(ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());
    context.getResult().set(mu);
  }
 else   if (PlatformMBeanConstants.NON_HEAP_MEMORY_USAGE.equals(name)) {
    final ModelNode mu=PlatformMBeanUtil.getDetypedMemoryUsage(ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage());
    context.getResult().set(mu);
  }
 else   if (PlatformMBeanConstants.VERBOSE.equals(name)) {
    context.getResult().set(ManagementFactory.getMemoryMXBean().isVerbose());
  }
 else   if (PlatformMBeanConstants.MEMORY_METRICS.contains(name) || PlatformMBeanConstants.MEMORY_READ_WRITE_ATTRIBUTES.contains(name)) {
    throw new IllegalStateException(String.format("Read support for attribute %s was not properly implemented",name));
  }
 else {
    throw unknownAttribute(operation);
  }
}
