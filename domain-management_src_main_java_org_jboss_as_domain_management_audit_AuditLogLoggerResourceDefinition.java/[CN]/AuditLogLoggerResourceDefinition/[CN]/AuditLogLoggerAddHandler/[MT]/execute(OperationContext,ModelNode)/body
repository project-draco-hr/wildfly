{
  final Resource resource=context.createResource(PathAddress.EMPTY_ADDRESS);
  final ModelNode model=resource.getModel();
  for (  AttributeDefinition attr : AuditLogLoggerResourceDefinition.ATTRIBUTE_DEFINITIONS) {
    attr.validateAndSet(operation,model);
  }
  if (executeRuntime) {
    context.addStep(new OperationStepHandler(){
      public void execute(      final OperationContext context,      final ModelNode operation) throws OperationFailedException {
        final boolean wasReadOnly=auditLoggerProvider.isLogReadOnly();
        final AuditLogger.Status oldStatus=auditLoggerProvider.getLoggerStatus();
        auditLoggerProvider.setLogBoot(AuditLogLoggerResourceDefinition.LOG_BOOT.resolveModelAttribute(context,model).asBoolean());
        auditLoggerProvider.setLogReadOnly(AuditLogLoggerResourceDefinition.LOG_READ_ONLY.resolveModelAttribute(context,model).asBoolean());
        boolean enabled=AuditLogLoggerResourceDefinition.ENABLED.resolveModelAttribute(context,model).asBoolean();
        AuditLogger.Status status=enabled ? AuditLogger.Status.LOGGING : AuditLogger.Status.DISABLED;
        auditLoggerProvider.setLoggerStatus(status);
        context.completeStep(new OperationContext.RollbackHandler(){
          @Override public void handleRollback(          OperationContext context,          ModelNode operation){
            auditLoggerProvider.setLogReadOnly(wasReadOnly);
            auditLoggerProvider.setLoggerStatus(oldStatus);
          }
        }
);
      }
    }
,OperationContext.Stage.RUNTIME);
  }
 else {
    auditLoggerProvider.setLoggerStatus(AuditLogger.Status.DISABLED);
  }
  context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
