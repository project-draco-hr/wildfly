{
  final Endpoint endpoint=endpointInjector.getValue();
  try {
    final URI connectionURI=new URI("remote://" + NetworkUtils.formatPossibleIpv6Address(hostName) + ":"+ port);
    final OptionMap options=OptionMap.create(Options.SASL_DISALLOWED_MECHANISMS,Sequence.of(JBOSS_LOCAL_USER));
    final ProtocolConnectionConfiguration configuration=ProtocolConnectionConfiguration.create(endpoint,connectionURI,options);
    configuration.setCallbackHandler(HostControllerConnection.createClientCallbackHandler(userName,initialAuthKey));
    configuration.setConnectionTimeout(SERVER_CONNECTION_TIMEOUT);
    configuration.setSslContext(getAcceptingSSLContext());
    final HostControllerConnection connection=new HostControllerConnection(serverProcessName,userName,connectOperationID,configuration,executorInjector.getValue());
    final ControlledProcessStateService processService=processStateServiceInjectedValue.getValue();
    processService.addPropertyChangeListener(new PropertyChangeListener(){
      @Override public void propertyChange(      final PropertyChangeEvent evt){
        final ControlledProcessState.State old=(ControlledProcessState.State)evt.getOldValue();
        final ControlledProcessState.State current=(ControlledProcessState.State)evt.getNewValue();
        if (old == ControlledProcessState.State.STARTING) {
          if (current == ControlledProcessState.State.RUNNING || current == ControlledProcessState.State.RESTART_REQUIRED) {
            connection.started();
          }
 else {
            IoUtils.safeClose(connection);
          }
        }
      }
    }
);
    this.client=new HostControllerClient(serverName,connection.getChannelHandler(),connection,managementSubsystemEndpoint);
  }
 catch (  Exception e) {
    throw new StartException(e);
  }
}
