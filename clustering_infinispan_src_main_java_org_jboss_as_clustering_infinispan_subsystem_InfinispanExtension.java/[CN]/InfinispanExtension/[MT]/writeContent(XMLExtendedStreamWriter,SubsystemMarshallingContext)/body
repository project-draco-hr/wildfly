{
  context.startSubsystemElement(Namespace.CURRENT.getUri(),false);
  ModelNode model=context.getModelNode();
  if (model.isDefined()) {
    writer.writeAttribute(Attribute.DEFAULT_CACHE_CONTAINER.getLocalName(),model.require(ModelKeys.DEFAULT_CACHE_CONTAINER).asString());
    for (    Property entry : model.get(ModelKeys.CACHE_CONTAINER).asPropertyList()) {
      writer.writeStartElement(Element.CACHE_CONTAINER.getLocalName());
      writer.writeAttribute(Attribute.NAME.getLocalName(),entry.getName());
      ModelNode container=entry.getValue();
      this.writeRequired(writer,Attribute.DEFAULT_CACHE,container,ModelKeys.DEFAULT_CACHE);
      this.writeOptional(writer,Attribute.JNDI_NAME,container,ModelKeys.JNDI_NAME);
      this.writeOptional(writer,Attribute.LISTENER_EXECUTOR,container,ModelKeys.LISTENER_EXECUTOR);
      this.writeOptional(writer,Attribute.EVICTION_EXECUTOR,container,ModelKeys.EVICTION_EXECUTOR);
      this.writeOptional(writer,Attribute.REPLICATION_QUEUE_EXECUTOR,container,ModelKeys.REPLICATION_QUEUE_EXECUTOR);
      if (container.hasDefined(ModelKeys.ALIAS)) {
        for (        ModelNode alias : container.get(ModelKeys.ALIAS).asList()) {
          writer.writeStartElement(Element.ALIAS.getLocalName());
          writer.writeCharacters(alias.asString());
          writer.writeEndElement();
        }
      }
      if (container.hasDefined(ModelKeys.TRANSPORT)) {
        writer.writeStartElement(Element.TRANSPORT.getLocalName());
        ModelNode transport=container.get(ModelKeys.TRANSPORT);
        this.writeOptional(writer,Attribute.STACK,transport,ModelKeys.STACK);
        this.writeOptional(writer,Attribute.EXECUTOR,transport,ModelKeys.EXECUTOR);
        this.writeOptional(writer,Attribute.LOCK_TIMEOUT,transport,ModelKeys.LOCK_TIMEOUT);
        this.writeOptional(writer,Attribute.SITE,transport,ModelKeys.SITE);
        this.writeOptional(writer,Attribute.RACK,transport,ModelKeys.RACK);
        this.writeOptional(writer,Attribute.MACHINE,transport,ModelKeys.MACHINE);
        writer.writeEndElement();
      }
      for (      ModelNode cache : container.get(ModelKeys.CACHE).asList()) {
        CacheMode mode=CacheMode.valueOf(cache.get(ModelKeys.MODE).asString());
        if (mode.isClustered()) {
          if (mode.isDistributed()) {
            writer.writeStartElement(Element.DISTRIBUTED_CACHE.getLocalName());
            this.writeOptional(writer,Attribute.OWNERS,cache,ModelKeys.OWNERS);
            this.writeOptional(writer,Attribute.VIRTUAL_NODES,cache,ModelKeys.VIRTUAL_NODES);
            this.writeOptional(writer,Attribute.L1_LIFESPAN,cache,ModelKeys.L1_LIFESPAN);
          }
 else           if (mode.isInvalidation()) {
            writer.writeStartElement(Element.INVALIDATION_CACHE.getLocalName());
          }
 else {
            writer.writeStartElement(Element.REPLICATED_CACHE.getLocalName());
          }
          writer.writeAttribute(Attribute.MODE.getLocalName(),Mode.forCacheMode(mode).name());
          this.writeOptional(writer,Attribute.QUEUE_SIZE,cache,ModelKeys.QUEUE_SIZE);
          this.writeOptional(writer,Attribute.QUEUE_FLUSH_INTERVAL,cache,ModelKeys.QUEUE_FLUSH_INTERVAL);
          this.writeOptional(writer,Attribute.REMOTE_TIMEOUT,cache,ModelKeys.REMOTE_TIMEOUT);
        }
 else {
          writer.writeStartElement(Element.LOCAL_CACHE.getLocalName());
        }
        this.writeRequired(writer,Attribute.NAME,cache,ModelKeys.NAME);
        this.writeOptional(writer,Attribute.START,cache,ModelKeys.START);
        this.writeOptional(writer,Attribute.BATCHING,cache,ModelKeys.BATCHING);
        this.writeOptional(writer,Attribute.INDEXING,cache,ModelKeys.INDEXING);
        if (cache.hasDefined(ModelKeys.LOCKING)) {
          writer.writeStartElement(Element.LOCKING.getLocalName());
          ModelNode locking=cache.get(ModelKeys.LOCKING);
          this.writeOptional(writer,Attribute.ISOLATION,locking,ModelKeys.ISOLATION);
          this.writeOptional(writer,Attribute.STRIPING,locking,ModelKeys.STRIPING);
          this.writeOptional(writer,Attribute.ACQUIRE_TIMEOUT,locking,ModelKeys.ACQUIRE_TIMEOUT);
          this.writeOptional(writer,Attribute.CONCURRENCY_LEVEL,locking,ModelKeys.CONCURRENCY_LEVEL);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.TRANSACTION)) {
          writer.writeStartElement(Element.TRANSACTION.getLocalName());
          ModelNode transaction=cache.get(ModelKeys.TRANSACTION);
          this.writeOptional(writer,Attribute.STOP_TIMEOUT,transaction,ModelKeys.STOP_TIMEOUT);
          this.writeOptional(writer,Attribute.MODE,transaction,ModelKeys.MODE);
          this.writeOptional(writer,Attribute.LOCKING,transaction,ModelKeys.LOCKING);
          this.writeOptional(writer,Attribute.EAGER_LOCKING,transaction,ModelKeys.EAGER_LOCKING);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.EVICTION)) {
          writer.writeStartElement(Element.EVICTION.getLocalName());
          ModelNode eviction=cache.get(ModelKeys.EVICTION);
          this.writeOptional(writer,Attribute.STRATEGY,eviction,ModelKeys.STRATEGY);
          this.writeOptional(writer,Attribute.MAX_ENTRIES,eviction,ModelKeys.MAX_ENTRIES);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.EXPIRATION)) {
          writer.writeStartElement(Element.EXPIRATION.getLocalName());
          ModelNode expiration=cache.get(ModelKeys.EXPIRATION);
          this.writeOptional(writer,Attribute.MAX_IDLE,expiration,ModelKeys.MAX_IDLE);
          this.writeOptional(writer,Attribute.LIFESPAN,expiration,ModelKeys.LIFESPAN);
          this.writeOptional(writer,Attribute.INTERVAL,expiration,ModelKeys.INTERVAL);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.STORE)) {
          ModelNode store=cache.get(ModelKeys.STORE);
          if (store.hasDefined(ModelKeys.CLASS)) {
            writer.writeStartElement(Element.STORE.getLocalName());
            this.writeRequired(writer,Attribute.CLASS,store,ModelKeys.CLASS);
          }
 else {
            writer.writeStartElement(Element.FILE_STORE.getLocalName());
            this.writeOptional(writer,Attribute.RELATIVE_TO,store,ModelKeys.RELATIVE_TO);
            this.writeOptional(writer,Attribute.PATH,store,ModelKeys.PATH);
          }
          this.writeOptional(writer,Attribute.SHARED,store,ModelKeys.SHARED);
          this.writeOptional(writer,Attribute.PRELOAD,store,ModelKeys.PRELOAD);
          this.writeOptional(writer,Attribute.PASSIVATION,store,ModelKeys.PASSIVATION);
          this.writeOptional(writer,Attribute.FETCH_STATE,store,ModelKeys.FETCH_STATE);
          this.writeOptional(writer,Attribute.PURGE,store,ModelKeys.PURGE);
          this.writeOptional(writer,Attribute.SINGLETON,store,ModelKeys.SINGLETON);
          if (store.hasDefined(ModelKeys.PROPERTY)) {
            for (            Property property : store.get(ModelKeys.PROPERTY).asPropertyList()) {
              writer.writeStartElement(Element.PROPERTY.getLocalName());
              writer.writeAttribute(Attribute.NAME.getLocalName(),property.getName());
              writer.writeCharacters(property.getValue().asString());
              writer.writeEndElement();
            }
          }
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.STATE_TRANSFER)) {
          ModelNode stateTransfer=cache.get(ModelKeys.STATE_TRANSFER);
          writer.writeStartElement(Element.STATE_TRANSFER.getLocalName());
          this.writeOptional(writer,Attribute.ENABLED,stateTransfer,ModelKeys.ENABLED);
          this.writeOptional(writer,Attribute.TIMEOUT,stateTransfer,ModelKeys.TIMEOUT);
          this.writeOptional(writer,Attribute.FLUSH_TIMEOUT,stateTransfer,ModelKeys.FLUSH_TIMEOUT);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.REHASHING)) {
          ModelNode rehashing=cache.get(ModelKeys.REHASHING);
          writer.writeStartElement(Element.REHASHING.getLocalName());
          this.writeOptional(writer,Attribute.ENABLED,rehashing,ModelKeys.ENABLED);
          this.writeOptional(writer,Attribute.TIMEOUT,rehashing,ModelKeys.TIMEOUT);
          writer.writeEndElement();
        }
        writer.writeEndElement();
      }
      writer.writeEndElement();
    }
  }
  writer.writeEndElement();
}
