{
  FrameworkStartLevel frameworkStartLevel=bundleManager.getSystemBundle().adapt(FrameworkStartLevel.class);
  BundleStartLevel bundleStartLevel=bundle.adapt(BundleStartLevel.class);
  int startlevel=bundleStartLevel.getStartLevel();
  if (startlevel > frameworkStartLevel.getStartLevel()) {
    LOGGER.debugf("Start level [%d] not valid for: %s",startlevel,bundle);
    return;
  }
  LOGGER.infoActivateDeferredModulePhase(bundle);
  if (!bundle.isResolved()) {
    XResolveContext context=resolver.createResolveContext(environment,Collections.singleton(bundle.getBundleRevision()),null);
    try {
      resolver.resolveAndApply(context);
    }
 catch (    ResolutionException ex) {
      throw new BundleException(FrameworkMessages.MESSAGES.cannotResolveBundle(bundle),BundleException.RESOLVE_ERROR,ex);
    }
  }
  depUnit.getAttachment(Attachments.DEFERRED_ACTIVATION_COUNT).incrementAndGet();
  StabilityMonitor monitor=new StabilityMonitor();
  monitor.addController(parentDeploymentService);
  monitor.addController(phaseService);
  Set<ServiceController<?>> failed=new HashSet<ServiceController<?>>();
  Set<ServiceController<?>> problems=new HashSet<ServiceController<?>>();
  try {
    phaseService.setMode(Mode.ACTIVE);
    monitor.awaitStability(failed,problems);
  }
 catch (  final InterruptedException ex) {
  }
 finally {
    monitor.clear();
  }
  if (failed.size() > 0 || problems.size() > 0) {
    List<ServiceController<?>> combined=new ArrayList<ServiceController<?>>();
    combined.addAll(failed);
    combined.addAll(problems);
    StartException startex=null;
    for (    ServiceController<?> aux : combined) {
      if (aux.getStartException() != null) {
        startex=aux.getStartException();
        break;
      }
    }
    BundleException failure;
    if (startex != null && startex.getCause() instanceof BundleException) {
      failure=(BundleException)startex.getCause();
    }
 else {
      failure=MESSAGES.cannotActivateDeferredModulePhase(startex,bundle);
    }
    depUnit.putAttachment(OSGiConstants.DEFERRED_ACTIVATION_FAILED,Boolean.TRUE);
    LOGGER.warnDeactivateDeferredModulePhase(bundle);
    phaseService.setMode(Mode.NEVER);
    try {
      FutureServiceValue<Phase> future=new FutureServiceValue<Phase>(phaseService,State.DOWN);
      future.get(30,TimeUnit.SECONDS);
    }
 catch (    ExecutionException ex) {
      LOGGER.errorf(failure,failure.getMessage());
      throw MESSAGES.cannotDeactivateDeferredModulePhase(ex,bundle);
    }
catch (    TimeoutException ex) {
      LOGGER.errorf(failure,failure.getMessage());
      throw MESSAGES.cannotDeactivateDeferredModulePhase(ex,bundle);
    }
    throw failure;
  }
}
