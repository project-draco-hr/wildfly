{
  final Interceptor interceptor=new StatefulSessionSynchronizationInterceptor();
  final InterceptorContext context=new InterceptorContext();
  context.setInterceptorIterator(Arrays.asList(noop()).listIterator());
  final StatefulSessionComponent component=mock(StatefulSessionComponent.class);
  context.putPrivateData(Component.class,component);
  when(component.getAccessTimeout()).thenReturn(defaultAccessTimeout());
  Cache<StatefulSessionComponentInstance> cache=mock(Cache.class);
  when(component.getCache()).thenReturn(cache);
  final TransactionSynchronizationRegistry transactionSynchronizationRegistry=mock(TransactionSynchronizationRegistry.class);
  when(component.getTransactionSynchronizationRegistry()).thenReturn(transactionSynchronizationRegistry);
  when(transactionSynchronizationRegistry.getTransactionKey()).thenReturn("TX1");
  final List<Synchronization> synchronizations=new LinkedList<Synchronization>();
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Synchronization synchronization=(Synchronization)invocation.getArguments()[0];
      synchronizations.add(synchronization);
      return null;
    }
  }
).when(transactionSynchronizationRegistry).registerInterposedSynchronization((Synchronization)any());
  final StatefulSessionComponentInstance instance=mock(StatefulSessionComponentInstance.class);
  when(instance.getComponent()).thenReturn(component);
  context.putPrivateData(ComponentInstance.class,instance);
  interceptor.processInvocation(context);
  when(transactionSynchronizationRegistry.getTransactionKey()).thenReturn("TX2");
  try {
    interceptor.processInvocation(context);
    fail("Expected an Exception when invoking SFSB from 2 transactions concurrently");
  }
 catch (  Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage().contains("is already associated with tx TX1 (current tx TX2)"));
  }
}
