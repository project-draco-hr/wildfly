{
  String patchID=randomString();
  String invalidPatchId=randomString();
  String layerPatchID=randomString();
  File oneOffPatchDir=mkdir(tempDir,patchID);
  File invalidOneOffPatchDir=mkdir(tempDir,invalidPatchId);
  final String moduleName="org.wildfly.test." + randomString();
  final String modulePath=PATCHES_PATH + FILE_SEPARATOR + layerPatchID+ FILE_SEPARATOR+ moduleName.replace(".",FILE_SEPARATOR)+ FILE_SEPARATOR+ "main";
  final ResourceItem resourceItem1=new ResourceItem("testFile1","content1".getBytes());
  final ResourceItem resourceItem2=new ResourceItem("testFile2","content2".getBytes());
  Module newModule=new Module.Builder(moduleName).miscFile(resourceItem1).miscFile(resourceItem2).build();
  ContentModification moduleAdded=ContentModificationUtils.addModule(oneOffPatchDir,layerPatchID,newModule);
  ProductConfig productConfig=new ProductConfig(PRODUCT,AS_VERSION,"main");
  Patch oneOffPatch=PatchBuilder.create().setPatchId(patchID).setDescription("A one-off patch adding a new module.").oneOffPatchIdentity(productConfig.getProductName(),productConfig.getProductVersion()).getParent().oneOffPatchElement(layerPatchID,"base",false).setDescription("New module for the base layer").addContentModification(moduleAdded).getParent().build();
  createPatchXMLFile(oneOffPatchDir,oneOffPatch);
  File zippedPatch=createZippedPatchFile(oneOffPatchDir,patchID);
  ContentModification invalidContentModification=ContentModificationUtils.addModule(invalidOneOffPatchDir,invalidPatchId,newModule);
  Patch invalidOneOffPatch=PatchBuilder.create().setPatchId(invalidPatchId).setDescription("A invalid one-off patch adding a new module.").oneOffPatchIdentity(productConfig.getProductName(),productConfig.getProductVersion()).getParent().oneOffPatchElement(layerPatchID,"base",false).setDescription("New module for the base layer").addContentModification(invalidContentModification).getParent().build();
  createPatchXMLFile(invalidOneOffPatchDir,invalidOneOffPatch);
  File zippedInvalidPatch=createZippedPatchFile(invalidOneOffPatchDir,invalidPatchId);
  controller.start(CONTAINER);
  Assert.assertFalse("Patch shouldn't be accepted",CliUtilsForPatching.applyPatch(zippedInvalidPatch.getAbsolutePath()));
  Assert.assertTrue("Patch should be accepted",CliUtilsForPatching.applyPatch(zippedPatch.getAbsolutePath()));
  Assert.assertTrue("server should be in restart-required mode",CliUtilsForPatching.doesServerRequireRestart());
  controller.stop(CONTAINER);
  controller.start(CONTAINER);
  List<String> paths=CliUtilsForPatching.getResourceLoaderPathsForModule(moduleName,false);
  Assert.assertTrue("Module should be loaded from the .overlays directory but was: " + paths.get(0),paths.get(0).contains(".overlays" + File.separator + layerPatchID));
  Assert.assertTrue("The patch " + patchID + " should be listed as installed",CliUtilsForPatching.getInstalledPatches().contains(patchID));
  Assert.assertTrue("The file " + resourceItem1.getItemName() + " should exist",new File(modulePath + FILE_SEPARATOR + resourceItem1.getItemName()).exists());
  Assert.assertTrue("The file " + resourceItem2.getItemName() + " should exist",new File(modulePath + FILE_SEPARATOR + resourceItem2.getItemName()).exists());
  List<ModelNode> history=CliUtilsForPatching.getPatchingHistory();
  Assert.assertTrue("Patch " + patchID + " should be visible in history: "+ Arrays.deepToString(history.toArray()),PatchingTestUtil.isOneOffPatchContainedInHistory(history,patchID));
  Assert.assertTrue("Rollback should be accepted",CliUtilsForPatching.rollbackPatch(patchID));
  Assert.assertTrue("server should be in restart-required mode",CliUtilsForPatching.doesServerRequireRestart());
  controller.stop(CONTAINER);
  controller.start(CONTAINER);
  try {
    CliUtilsForPatching.getResourceLoaderPathsForModule(moduleName,true);
    Assert.fail("Module " + moduleName + " should have been removed");
  }
 catch (  RuntimeException expected) {
  }
  Assert.assertFalse("The patch " + patchID + " NOT should be listed as installed",CliUtilsForPatching.getInstalledPatches().contains(patchID));
  Assert.assertFalse("The file " + resourceItem1.getItemName() + "should have been deleted",new File(modulePath + FILE_SEPARATOR + resourceItem1.getItemName()).exists());
  Assert.assertFalse("The file " + resourceItem2.getItemName() + "should have been deleted",new File(modulePath + FILE_SEPARATOR + resourceItem2.getItemName()).exists());
  Assert.assertTrue("Patch should be accepted",CliUtilsForPatching.applyPatch(zippedPatch.getAbsolutePath()));
  Assert.assertTrue("server should be in restart-required mode",CliUtilsForPatching.doesServerRequireRestart());
  controller.stop(CONTAINER);
  controller.start(CONTAINER);
  paths=CliUtilsForPatching.getResourceLoaderPathsForModule(moduleName,false);
  Assert.assertTrue("Module should be loaded from the .overlays directory but was: " + paths.get(0),paths.get(0).contains(".overlays" + File.separator + layerPatchID));
  Assert.assertTrue("The patch " + patchID + " should be listed as installed",CliUtilsForPatching.getInstalledPatches().contains(patchID));
  Assert.assertTrue("The file " + resourceItem1.getItemName() + " should exist",new File(modulePath + FILE_SEPARATOR + resourceItem1.getItemName()).exists());
  Assert.assertTrue("The file " + resourceItem2.getItemName() + " should exist",new File(modulePath + FILE_SEPARATOR + resourceItem2.getItemName()).exists());
  controller.stop(CONTAINER);
}
