{
  if (securityRealm != null) {
    Set<AuthMechanism> mechanisms=securityRealm.getSupportedAuthenticationMechanisms();
    List<AuthenticationMechanism> undertowMechanisms=new ArrayList<AuthenticationMechanism>(mechanisms.size());
    undertowMechanisms.add(wrap(new CachedAuthenticatedSessionMechanism(),null));
    for (    AuthMechanism current : mechanisms) {
switch (current) {
case CLIENT_CERT:
        undertowMechanisms.add(wrap(new ClientCertAuthenticationMechanism(),current));
      break;
case DIGEST:
    Map<String,String> mechConfig=securityRealm.getMechanismConfig(AuthMechanism.DIGEST);
  boolean plainTextDigest=true;
if (mechConfig.containsKey(DIGEST_PLAIN_TEXT)) {
  plainTextDigest=Boolean.parseBoolean(mechConfig.get(DIGEST_PLAIN_TEXT));
}
List<DigestAlgorithm> digestAlgorithms=Collections.singletonList(DigestAlgorithm.MD5);
List<DigestQop> digestQops=Collections.emptyList();
undertowMechanisms.add(wrap(new DigestAuthenticationMechanism(digestAlgorithms,digestQops,securityRealm.getName(),"/management",new SimpleNonceManager(),plainTextDigest),current));
break;
case PLAIN:
undertowMechanisms.add(wrap(new BasicAuthenticationMechanism(securityRealm.getName()),current));
break;
}
}
if (undertowMechanisms.size() > 1) {
HttpHandler current=domainHandler;
current=new AuthenticationCallHandler(current);
current=new AuthenticationConstraintHandler(current);
current=new AuthenticationMechanismsHandler(current,undertowMechanisms);
current=new ConnectionAuthenticationCacheHandler(current);
return new SecurityInitialHandler(AuthenticationMode.PRO_ACTIVE,new RealmIdentityManager(securityRealm),current);
}
}
return domainHandler;
}
