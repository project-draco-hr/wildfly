{
  int count=updates.size();
  log.debugf("Received %s updates",count);
  List<UpdateResultHandlerResponse<?>> results=new ArrayList<UpdateResultHandlerResponse<?>>(count);
  if (modelOnly && !standalone) {
    Exception e=new IllegalStateException("Update sets that only affect the configuration and not the runtime are not valid on a domain-based server");
    for (int i=0; i < count; i++) {
      results.add(UpdateResultHandlerResponse.createFailureResponse(e));
    }
    return results;
  }
  final CountDownLatch latch=new CountDownLatch(1);
  ServerUpdateCommitHandlerImpl handler=new ServerUpdateCommitHandlerImpl(results,count,latch);
  final ServerUpdateController controller=new ServerUpdateController(getServerModel(),container,executor,handler,rollbackOnFailure,!modelOnly);
  for (int i=0; i < count; i++) {
    controller.addServerModelUpdate(updates.get(i),handler,Integer.valueOf(i));
  }
  controller.executeUpdates();
  log.debugf("Executed %s updates",updates.size());
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new ManagementException("failed to execute updates",e);
  }
  return results;
}
