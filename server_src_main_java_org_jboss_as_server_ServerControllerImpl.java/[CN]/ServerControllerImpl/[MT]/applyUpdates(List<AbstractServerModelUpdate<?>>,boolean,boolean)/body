{
  final int count=updates.size();
  log.debugf("Received %d updates",Integer.valueOf(count));
  final List<UpdateResultHandlerResponse<?>> results=new ArrayList<UpdateResultHandlerResponse<?>>(count);
  if (modelOnly && !serverEnvironment.isStandalone()) {
    final Exception e=new IllegalStateException("Update sets that only affect the configuration and not the runtime are not valid on a domain-based server");
    for (int i=0; i < count; i++) {
      results.add(UpdateResultHandlerResponse.createFailureResponse(e));
    }
    return results;
  }
  final CountDownLatch latch=new CountDownLatch(1);
  final ServerUpdateCommitHandlerImpl handler=new ServerUpdateCommitHandlerImpl(results,count,latch);
  final ServerUpdateController controller=new ServerUpdateController(serverModel,container,executor,handler,rollbackOnFailure,!modelOnly);
  for (int i=0; i < count; i++) {
    controller.addServerModelUpdate(updates.get(i),handler,Integer.valueOf(i));
  }
  controller.executeUpdates();
  log.debugf("Executed %d updates",Integer.valueOf(updates.size()));
  try {
    latch.await();
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new ManagementException("failed to execute updates",e);
  }
  return results;
}
