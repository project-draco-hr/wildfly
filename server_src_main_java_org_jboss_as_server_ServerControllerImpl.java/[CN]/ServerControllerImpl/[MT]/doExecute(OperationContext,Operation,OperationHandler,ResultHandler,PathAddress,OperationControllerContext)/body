{
  boolean rollback=isRollbackOnRuntimeFailure(context,operation.getOperation());
  RollbackAwareResultHandler rollbackAwareHandler=new RollbackAwareResultHandler(resultHandler);
  final OperationResult result=super.doExecute(context,operation,operationHandler,rollbackAwareHandler,address,operationControllerContext);
  if (context instanceof ServerOperationContextImpl) {
    if (rollback) {
      rollbackAwareHandler.setRollbackOperation(result.getCompensatingOperation());
    }
    final ServerOperationContextImpl serverOperationContext=ServerOperationContextImpl.class.cast(context);
    if (serverOperationContext.getRuntimeTask() != null) {
      if (!serverStateMonitorListener.isFirstReportComplete() && state.getReference() != State.STARTING) {
        serverStateMonitorListener.awaitUninterruptibly();
      }
      try {
        serverOperationContext.getRuntimeTask().execute(new RuntimeTaskContext(){
          @Override public ServiceTarget getServiceTarget(){
            return serviceTarget;
          }
          @Override public ServiceRegistry getServiceRegistry(){
            return serviceRegistry;
          }
        }
);
      }
 catch (      OperationFailedException e) {
        rollbackAwareHandler.handleFailed(e.getFailureDescription());
      }
catch (      Exception e) {
        rollbackAwareHandler.handleFailed(new ModelNode().set(e.toString()));
      }
      ModelNode serverStateChangeReport=null;
      if (state.getReference() != State.STARTING) {
        serverStateChangeReport=serverStateMonitorListener.awaitUninterruptibly();
      }
      if (serverStateChangeReport != null && !rollbackAwareHandler.isTerminalState()) {
        rollbackAwareHandler.handleFailed(serverStateChangeReport);
      }
    }
    if (!rollbackAwareHandler.isTerminalState()) {
      rollbackAwareHandler.notifySuccess();
    }
  }
  return result;
}
