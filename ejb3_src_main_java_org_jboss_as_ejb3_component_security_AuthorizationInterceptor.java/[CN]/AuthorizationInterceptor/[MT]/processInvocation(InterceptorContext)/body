{
  final Component component=context.getPrivateData(Component.class);
  if (component instanceof EJBComponent == false) {
    throw new IllegalStateException("Unexpected component type: " + component.getClass() + " expected: "+ EJBComponent.class);
  }
  final ComponentViewInstance viewInstance=context.getPrivateData(ComponentViewInstance.class);
  final Method invokedMethod=context.getMethod();
  final EJBComponent ejbComponent=(EJBComponent)component;
  final EJBSecurityMetaData securityMetaData=ejbComponent.getSecurityMetaData();
  if (viewInstance != null) {
    final String viewClassName=viewInstance.getViewClass().getName();
    if (securityMetaData.isMethodAccessDenied(viewClassName,invokedMethod)) {
      throw new EJBAccessException("Invocation on method: " + invokedMethod + " of bean: "+ ejbComponent.getComponentName()+ " is not allowed");
    }
    final Collection<String> allowedRoles=securityMetaData.getAllowedRoles(viewClassName,invokedMethod);
    if (!allowedRoles.isEmpty()) {
      final SimpleSecurityManager securityManager=ejbComponent.getSecurityManager();
      if (!securityManager._isCallerInRole(allowedRoles.toArray(new String[allowedRoles.size()]))) {
        throw new EJBAccessException("Invocation on method: " + invokedMethod + " of bean: "+ ejbComponent.getComponentName()+ " is not allowed because caller is *not* in any of the "+ "allowed roles: "+ allowedRoles);
      }
    }
  }
  return context.proceed();
}
