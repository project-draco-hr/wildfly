{
  final List<Map<ModuleIdentifier,ModuleParseResult>> allModules=new ArrayList<>();
  for (  Server server : build.getServers()) {
    allModules.add(ModuleUtils.enumerateModuleDirectory(getLog(),Paths.get(server.getPath())));
  }
  Deque<ModuleParseResult> transitiveIncludes=new ArrayDeque<>();
  final Map<ModuleIdentifier,ModuleParseResult> finalModuleSet=new HashMap<>();
  for (int i=0; i < allModules.size(); ++i) {
    Server server=build.getServers().get(i);
    Map<ModuleIdentifier,ModuleParseResult> modules=allModules.get(i);
    for (    Map.Entry<ModuleIdentifier,ModuleParseResult> entry : modules.entrySet()) {
      Server.ModuleIncludeType includeType=server.includeModule(entry.getKey().toString());
      if (includeType == Server.ModuleIncludeType.MODULE_ONLY || includeType == Server.ModuleIncludeType.TRANSITIVE) {
        if (finalModuleSet.containsKey(entry.getKey())) {
          throw new RuntimeException("Same module is present in two servers, one of them must be excluded " + finalModuleSet.get(entry.getKey()).moduleXmlFile + " and "+ entry.getValue().moduleXmlFile);
        }
        finalModuleSet.put(entry.getKey(),entry.getValue());
        if (includeType == Server.ModuleIncludeType.TRANSITIVE) {
          transitiveIncludes.add(entry.getValue());
        }
      }
    }
  }
  final Set<String> notFound=new HashSet<>();
  while (!transitiveIncludes.isEmpty()) {
    ModuleParseResult transitive=transitiveIncludes.pop();
    for (    ModuleParseResult.ModuleDependency dep : transitive.getDependencies()) {
      if (!finalModuleSet.containsKey(dep.getModuleId())) {
        ModuleParseResult found=null;
        for (        Map<ModuleIdentifier,ModuleParseResult> moduleMap : allModules) {
          if (moduleMap.containsKey(dep.getModuleId())) {
            if (found == null) {
              found=moduleMap.get(dep.getModuleId());
            }
 else {
              throw new RuntimeException("Same module is present in two servers, one of them must be excluded " + moduleMap.get(dep.getModuleId()) + " and "+ found.moduleXmlFile);
            }
          }
        }
        if (found == null && !dep.isOptional()) {
          notFound.add("Could not find module " + dep.getModuleId() + " referenced from module "+ transitive.getIdentifier()+ " at "+ transitive.getModuleXmlFile());
        }
 else         if (found != null) {
          finalModuleSet.put(found.getIdentifier(),found);
          transitiveIncludes.add(found);
        }
 else {
          getLog().warn("Could not find optional dependency " + dep.getModuleId());
        }
      }
    }
  }
  if (!notFound.isEmpty()) {
    StringBuilder sb=new StringBuilder();
    for (    String problem : notFound) {
      sb.append(problem);
      sb.append('\n');
    }
    throw new RuntimeException(sb.toString());
  }
  Properties artifactPropertyMap=new Properties();
  for (  Map.Entry<String,Artifact> entry : artifactMap.entrySet()) {
    StringBuilder sb=new StringBuilder();
    sb.append(entry.getValue().getGroupId());
    sb.append(":");
    sb.append(entry.getValue().getArtifactId());
    sb.append(":");
    sb.append(entry.getValue().getVersion());
    if (entry.getValue().getClassifier() != null) {
      sb.append(':');
      sb.append(entry.getValue().getClassifier());
    }
    artifactPropertyMap.put(entry.getKey(),sb.toString());
  }
  final Set<String> errors=new HashSet<>();
  final BuildPropertyReplacer moduleReplacer=new BuildPropertyReplacer(artifactPropertyMap);
  File baseDir=new File(buildName,serverName);
  Path modulesDir=Paths.get(baseDir.getAbsolutePath());
  for (  Map.Entry<ModuleIdentifier,ModuleParseResult> entry : finalModuleSet.entrySet()) {
    Path moduleRoot=entry.getValue().getModuleRoot();
    Path module=entry.getValue().getModuleXmlFile();
    final Path moduleParent=module.getParent();
    final Path relativeParent=moduleRoot.relativize(moduleParent);
    final Path targetDir=modulesDir.resolve(relativeParent);
    if (!Files.isDirectory(targetDir)) {
      targetDir.toFile().mkdirs();
    }
    Files.walkFileTree(moduleParent,new FileVisitor<Path>(){
      @Override public FileVisitResult preVisitDirectory(      Path dir,      BasicFileAttributes attrs) throws IOException {
        String relative=moduleParent.relativize(dir).toString();
        Path rel=targetDir.resolve(relative);
        if (!Files.isDirectory(rel)) {
          if (!rel.toFile().mkdirs()) {
            throw new IOException("Could not create directory " + rel.toString());
          }
        }
        return FileVisitResult.CONTINUE;
      }
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        try {
          String relative=moduleParent.relativize(file).toString();
          Path targetFile=targetDir.resolve(relative);
          if (relative.equals("module.xml")) {
            String data=readFile(file.toFile());
            data=moduleReplacer.replaceProperties(data);
            copyFile(new ByteArrayInputStream(data.getBytes("UTF-8")),targetFile.toFile());
          }
 else {
            copyFile(file.toFile(),targetFile.toFile());
            Files.setPosixFilePermissions(targetFile,Files.getPosixFilePermissions(file));
          }
          return FileVisitResult.CONTINUE;
        }
 catch (        Exception e) {
          errors.add(e.getMessage());
          return FileVisitResult.CONTINUE;
        }
      }
      @Override public FileVisitResult visitFileFailed(      Path file,      IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
      }
      @Override public FileVisitResult postVisitDirectory(      Path dir,      IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
  if (!errors.isEmpty()) {
    StringBuilder sb=new StringBuilder();
    for (    String problem : errors) {
      sb.append(problem);
      sb.append('\n');
    }
    throw new RuntimeException(sb.toString());
  }
}
