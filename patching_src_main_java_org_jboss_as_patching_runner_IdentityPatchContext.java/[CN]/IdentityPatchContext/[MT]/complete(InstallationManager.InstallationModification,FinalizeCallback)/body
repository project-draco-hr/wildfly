{
  final List<File> processed=new ArrayList<File>();
  try {
    try {
      if (stateUpdater.compareAndSet(this,State.PREPARED,State.INVALIDATE) && mode == PatchingTaskContext.Mode.APPLY) {
        for (        final File invalidation : moduleInvalidations) {
          processed.add(invalidation);
          PatchModuleInvalidationUtils.processFile(invalidation,mode);
        }
      }
      modification.complete();
      callback.completed(this);
      state=State.COMPLETED;
    }
 catch (    Exception e) {
      this.moduleInvalidations.clear();
      this.moduleInvalidations.addAll(processed);
      throw new RuntimeException(e);
    }
  }
  finally {
    if (state != State.COMPLETED) {
      try {
        modification.cancel();
      }
  finally {
        try {
          undoChanges();
        }
  finally {
          callback.operationCancelled(this);
        }
      }
    }
 else {
      try {
        if (checkForGarbageOnRestart) {
          final File cleanupMarker=new File(installedImage.getInstallationMetadata(),"cleanup-patching-dirs");
          cleanupMarker.createNewFile();
        }
      }
 catch (      IOException e) {
        PatchLogger.ROOT_LOGGER.infof(e,"failed to create cleanup marker");
      }
    }
  }
}
