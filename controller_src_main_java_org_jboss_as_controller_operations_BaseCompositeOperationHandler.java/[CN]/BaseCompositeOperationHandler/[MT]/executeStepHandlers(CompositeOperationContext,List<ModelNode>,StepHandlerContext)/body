{
  for (int i=0; i < steps.size(); i++) {
    final ModelNode step=steps.get(i);
    if (stepHandlerContext.hasFailures()) {
      stepHandlerContext.recordCancellation(Integer.valueOf(i));
    }
 else {
      final PathAddress address=PathAddress.pathAddress(step.require(OP_ADDR));
      final String operationName=step.require(OP).asString();
      final OperationHandler stepHandler=context.getRegistry().getOperationHandler(address,operationName);
      final Integer id=Integer.valueOf(i);
      final OperationContext stepContext=context.getStepOperationContext(id,address,stepHandler);
      final ResultHandler stepResultHandler=new StepResultHandler(id,stepHandlerContext);
      try {
        final OperationResult result=stepHandler.execute(stepContext,step,stepResultHandler);
        stepHandlerContext.setRollbackOp(id,result.getCompensatingOperation());
        final ModelNode overallModel=context.getSubModel();
        final ModelNode stepModel=stepContext.getSubModel();
        if (stepModel != null) {
synchronized (overallModel) {
            if (stepHandler instanceof ModelRemoveOperationHandler) {
              address.remove(overallModel);
            }
 else {
              address.navigate(overallModel,true).set(stepModel);
            }
          }
        }
      }
 catch (      OperationFailedException e) {
        stepResultHandler.handleFailed(e.getFailureDescription());
      }
catch (      Throwable t) {
        stepResultHandler.handleFailed(new ModelNode().set(t.getLocalizedMessage()));
      }
    }
  }
}
