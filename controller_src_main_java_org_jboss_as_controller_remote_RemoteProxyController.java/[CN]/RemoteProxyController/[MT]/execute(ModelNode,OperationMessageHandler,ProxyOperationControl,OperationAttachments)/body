{
  final BlockingQueue<TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation>> queue=new ArrayBlockingQueue<TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation>>(1,true);
  final TransactionalProtocolClient.TransactionalOperationListener<TransactionalProtocolClient.Operation> operationListener=new TransactionalProtocolClient.TransactionalOperationListener<TransactionalProtocolClient.Operation>(){
    @Override public void operationPrepared(    TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation> prepared){
      if (!queue.offer(prepared)) {
        prepared.rollback();
      }
    }
    @Override public void operationFailed(    TransactionalProtocolClient.Operation operation,    ModelNode result){
      queue.offer(new BlockingQueueOperationListener.FailedOperation<TransactionalProtocolClient.Operation>(operation,result));
    }
    @Override public void operationComplete(    TransactionalProtocolClient.Operation operation,    ModelNode result){
      control.operationCompleted(result);
    }
  }
;
  Future<ModelNode> futureResult=null;
  try {
    final ModelNode translated=getOperationForProxy(original);
    futureResult=client.execute(operationListener,translated,messageHandler,attachments);
    final TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation> prepared=queue.take();
    if (prepared.isFailed()) {
      control.operationFailed(prepared.getPreparedResult());
      return;
    }
    control.operationPrepared(new ModelController.OperationTransaction(){
      @Override public void commit(){
        prepared.commit();
        try {
          prepared.getFinalResult().get();
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
        }
      }
      @Override public void rollback(){
        prepared.rollback();
        try {
          prepared.getFinalResult().get();
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
        }
      }
    }
,prepared.getPreparedResult());
  }
 catch (  InterruptedException e) {
    if (futureResult != null) {
      futureResult.cancel(false);
    }
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
