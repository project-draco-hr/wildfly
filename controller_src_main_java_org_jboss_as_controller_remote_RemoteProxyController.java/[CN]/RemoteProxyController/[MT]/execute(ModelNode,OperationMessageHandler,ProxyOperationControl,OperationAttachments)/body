{
  final CountDownLatch completed=new CountDownLatch(1);
  final BlockingQueue<TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation>> queue=new ArrayBlockingQueue<TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation>>(1,true);
  final TransactionalProtocolClient.TransactionalOperationListener<TransactionalProtocolClient.Operation> operationListener=new TransactionalProtocolClient.TransactionalOperationListener<TransactionalProtocolClient.Operation>(){
    @Override public void operationPrepared(    TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation> prepared){
      if (!queue.offer(prepared)) {
        prepared.rollback();
      }
    }
    @Override public void operationFailed(    TransactionalProtocolClient.Operation operation,    ModelNode result){
      try {
        queue.offer(new BlockingQueueOperationListener.FailedOperation<TransactionalProtocolClient.Operation>(operation,result));
      }
  finally {
        completed.countDown();
      }
    }
    @Override public void operationComplete(    TransactionalProtocolClient.Operation operation,    ModelNode result){
      try {
        control.operationCompleted(result);
      }
  finally {
        completed.countDown();
      }
    }
  }
;
  Future<ModelNode> futureResult=null;
  try {
    final ModelNode translated=translateOperationForProxy(original);
    ControllerLogger.MGMT_OP_LOGGER.tracef("Executing %s for %s",translated.get(OP).asString(),getProxyNodeAddress());
    futureResult=client.execute(operationListener,translated,messageHandler,attachments);
    final TransactionalProtocolClient.PreparedOperation<TransactionalProtocolClient.Operation> prepared=queue.take();
    if (prepared.isFailed()) {
      control.operationFailed(prepared.getPreparedResult());
      return;
    }
    final Future cancellable=futureResult;
    control.operationPrepared(new ModelController.OperationTransaction(){
      @Override public void commit(){
        prepared.commit();
        try {
          completed.await();
        }
 catch (        InterruptedException e) {
          cancellable.cancel(true);
          ControllerLogger.MGMT_OP_LOGGER.interruptedAwaitingFinalResponse(translated.get(OP).asString(),getProxyNodeAddress());
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
        }
      }
      @Override public void rollback(){
        prepared.rollback();
        try {
          completed.await();
        }
 catch (        InterruptedException e) {
          cancellable.cancel(true);
          ControllerLogger.MGMT_OP_LOGGER.interruptedAwaitingFinalResponse(translated.get(OP).asString(),getProxyNodeAddress());
          Thread.currentThread().interrupt();
        }
catch (        Exception e) {
        }
      }
    }
,prepared.getPreparedResult());
  }
 catch (  InterruptedException e) {
    if (futureResult != null) {
      ControllerLogger.MGMT_OP_LOGGER.interruptedAwaitingInitialResponse(original.get(OP).asString(),getProxyNodeAddress());
      futureResult.cancel(true);
    }
    control.operationFailed(getCancelledResponse());
    Thread.currentThread().interrupt();
  }
catch (  IOException e) {
    final ModelNode result=new ModelNode();
    result.get(OUTCOME).set(FAILED);
    result.get(FAILURE_DESCRIPTION).set(e.getLocalizedMessage());
    control.operationFailed(result);
  }
}
