{
  if (!(target instanceof MethodInfo)) {
    throw new IllegalArgumentException(annotationType + " is only valid on method targets.");
  }
  final MethodInfo methodInfo=MethodInfo.class.cast(target);
  final ClassInfo classInfo=methodInfo.declaringClass();
  final EEModuleClassDescription classDescription=eeModuleDescription.getOrAddClassByName(classInfo.name().toString());
  final Type[] args=methodInfo.args();
  if (args.length > 1) {
    log.warn("Invalid number of arguments for method " + methodInfo.name() + " annotated with "+ annotationType+ " on class "+ classInfo.name());
    return;
  }
 else   if (args.length == 1 && !args[0].name().toString().equals(InvocationContext.class.getName())) {
    log.warn("Invalid signature for method " + methodInfo.name() + " annotated with "+ annotationType+ " on class "+ classInfo.name()+ ", signature must be void methodName(InvocationContext ctx)");
    return;
  }
  final MethodIdentifier methodIdentifier;
  if (args.length == 0) {
    methodIdentifier=MethodIdentifier.getIdentifier(Void.TYPE,methodInfo.name());
  }
 else {
    methodIdentifier=MethodIdentifier.getIdentifier(Void.TYPE,methodInfo.name(),InvocationContext.class);
  }
  if (annotationType == POST_CONSTRUCT_ANNOTATION) {
    classDescription.setPostConstructMethod(methodIdentifier);
  }
 else {
    classDescription.setPreDestroyMethod(methodIdentifier);
  }
}
