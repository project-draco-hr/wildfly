{
  final K key=this.keyFactory.createKey(sessionId);
  Operation<IncomingDistributableSessionData> operation=new Operation<IncomingDistributableSessionData>(){
    @Override public IncomingDistributableSessionData invoke(    Cache<K,Map<Object,Object>> cache){
      Map<Object,Object> map=cache.get(key);
      if (map == null)       return null;
      Integer version=SessionMapEntry.VERSION.get(map);
      Long timestamp=SessionMapEntry.TIMESTAMP.get(map);
      DistributableSessionMetadata metadata=SessionMapEntry.METADATA.get(map);
      IncomingDistributableSessionDataImpl result=new IncomingDistributableSessionDataImpl(version,timestamp,metadata);
      if (includeAttributes) {
        try {
          result.setSessionAttributes(DistributedCacheManager.this.attributeStorage.load(map));
        }
 catch (        Exception e) {
          throw MESSAGES.failedToStoreSessionAttributes(e,mask(key.getSessionId()));
        }
      }
      return result;
    }
  }
;
  try {
    return this.invoker.invoke(this.sessionCache,operation);
  }
 catch (  Exception e) {
    ROOT_LOGGER.errorAccessingSession(e,mask(sessionId),e.getLocalizedMessage());
    ROOT_LOGGER.errorAccessingSession(mask(sessionId),e.getLocalizedMessage());
    this.removeSessionLocal(sessionId);
    return null;
  }
}
