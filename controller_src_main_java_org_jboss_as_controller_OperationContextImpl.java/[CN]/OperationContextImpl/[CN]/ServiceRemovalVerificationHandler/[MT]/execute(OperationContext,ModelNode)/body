{
  final Map<Step,Map<ServiceName,Set<ServiceName>>> missingByStep=new HashMap<Step,Map<ServiceName,Set<ServiceName>>>();
  Object mutex=realRemovingControllers;
synchronized (mutex) {
    for (    Map.Entry<ServiceName,ContainerStateMonitor.MissingDependencyInfo> entry : containerStateChangeReport.getMissingServices().entrySet()) {
      ContainerStateMonitor.MissingDependencyInfo missingDependencyInfo=entry.getValue();
      Step removalStep=removalSteps.get(entry.getKey());
      if (removalStep != null) {
        Map<ServiceName,Set<ServiceName>> stepBadRemovals=missingByStep.get(removalStep);
        if (stepBadRemovals == null) {
          stepBadRemovals=new HashMap<ServiceName,Set<ServiceName>>();
          missingByStep.put(removalStep,stepBadRemovals);
        }
        stepBadRemovals.put(entry.getKey(),missingDependencyInfo.getDependents());
      }
    }
  }
  for (  Map.Entry<Step,Map<ServiceName,Set<ServiceName>>> entry : missingByStep.entrySet()) {
    Step step=entry.getKey();
    if (!step.response.hasDefined(FAILURE_DESCRIPTION)) {
      StringBuilder sb=new StringBuilder("Removing services has lead to unsatisfied dependencies:");
      for (      Map.Entry<ServiceName,Set<ServiceName>> removed : entry.getValue().entrySet()) {
        sb.append("\nService ");
        sb.append(removed.getKey().getCanonicalName());
        sb.append(" was depended upon by ");
        boolean first=true;
        for (        ServiceName dependent : removed.getValue()) {
          if (!first) {
            sb.append(", ");
          }
 else {
            first=false;
          }
          sb.append(dependent);
        }
      }
      step.response.get(FAILURE_DESCRIPTION).set(sb.toString());
    }
  }
  if (!missingByStep.isEmpty() && context.isRollbackOnRuntimeFailure()) {
    context.setRollbackOnly();
  }
  context.completeStep();
}
