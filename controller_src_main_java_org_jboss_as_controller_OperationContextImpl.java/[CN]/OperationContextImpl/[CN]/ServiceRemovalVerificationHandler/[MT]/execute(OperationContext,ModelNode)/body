{
  final Map<Step,Map<ServiceName,Set<ServiceName>>> missingByStep=new HashMap<Step,Map<ServiceName,Set<ServiceName>>>();
synchronized (realRemovingControllers) {
    for (    Map.Entry<ServiceName,ContainerStateMonitor.MissingDependencyInfo> entry : containerStateChangeReport.getMissingServices().entrySet()) {
      ContainerStateMonitor.MissingDependencyInfo missingDependencyInfo=entry.getValue();
      Step removalStep=removalSteps.get(entry.getKey());
      if (removalStep != null) {
        Map<ServiceName,Set<ServiceName>> stepBadRemovals=missingByStep.get(removalStep);
        if (stepBadRemovals == null) {
          stepBadRemovals=new HashMap<ServiceName,Set<ServiceName>>();
          missingByStep.put(removalStep,stepBadRemovals);
        }
        stepBadRemovals.put(entry.getKey(),missingDependencyInfo.getDependents());
      }
    }
  }
  for (  Map.Entry<Step,Map<ServiceName,Set<ServiceName>>> entry : missingByStep.entrySet()) {
    Step step=entry.getKey();
    if (!step.response.hasDefined(ModelDescriptionConstants.FAILURE_DESCRIPTION)) {
      StringBuilder sb=new StringBuilder(ControllerLogger.ROOT_LOGGER.removingServiceUnsatisfiedDependencies());
      for (      Map.Entry<ServiceName,Set<ServiceName>> removed : entry.getValue().entrySet()) {
        sb.append(ControllerLogger.ROOT_LOGGER.removingServiceUnsatisfiedDependencies(removed.getKey().getCanonicalName()));
        boolean first=true;
        for (        ServiceName dependent : removed.getValue()) {
          if (!first) {
            sb.append(", ");
          }
 else {
            first=false;
          }
          sb.append(dependent);
        }
      }
      step.response.get(ModelDescriptionConstants.FAILURE_DESCRIPTION).set(sb.toString());
    }
  }
  if (!missingByStep.isEmpty() && context.isRollbackOnRuntimeFailure()) {
    context.setRollbackOnly();
  }
  context.completeStep(RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
