{
  if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {
    HOST_CONTROLLER_LOGGER.trace("Executing two-phase");
  }
  DomainOperationContext overallContext=new DomainOperationContext(localHostControllerInfo);
  ModelNode rolloutPlan=operation.hasDefined(OPERATION_HEADERS) && operation.get(OPERATION_HEADERS).has(ROLLOUT_PLAN) ? operation.get(OPERATION_HEADERS).remove(ROLLOUT_PLAN) : new ModelNode();
  context.addStep(new DomainFinalResultHandler(overallContext),OperationContext.Stage.MODEL);
  final ModelNode slaveOp=operation.clone();
  slaveOp.get(OPERATION_HEADERS,EXECUTE_FOR_COORDINATOR).set(true);
  slaveOp.protect();
  String localHostName=localHostControllerInfo.getLocalHostName();
  if (routing.isLocalCallNeeded(localHostName)) {
    ModelNode localResponse=overallContext.getCoordinatorResult();
    localSlaveHandler.addSteps(context,slaveOp.clone(),localResponse,false);
  }
  if (localHostControllerInfo.isMasterDomainController()) {
    Set<String> remoteHosts=new HashSet<String>(routing.getHosts());
    boolean global=remoteHosts.size() == 0;
    remoteHosts.remove(localHostName);
    if (remoteHosts.size() > 0 || global) {
      context.acquireControllerLock();
      if (global) {
        remoteHosts.addAll(hostProxies.keySet());
      }
      Map<String,ProxyController> remoteProxies=new HashMap<String,ProxyController>();
      for (      String host : remoteHosts) {
        ProxyController proxy=hostProxies.get(host);
        if (proxy != null) {
          remoteProxies.put(host,proxy);
        }
 else         if (!global) {
          throw MESSAGES.invalidOperationTargetHost(host);
        }
      }
      context.addStep(slaveOp.clone(),new DomainSlaveHandler(remoteProxies,overallContext,runtimeIgnoreTransformationRegistry),OperationContext.Stage.DOMAIN);
    }
  }
  context.addStep(new DomainRolloutStepHandler(hostProxies,serverProxies,overallContext,rolloutPlan,getExecutorService()),OperationContext.Stage.DOMAIN);
  context.stepCompleted();
}
