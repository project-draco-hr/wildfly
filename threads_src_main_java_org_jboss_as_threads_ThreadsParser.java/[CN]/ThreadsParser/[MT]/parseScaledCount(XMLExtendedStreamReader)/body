{
  final int attrCount=reader.getAttributeCount();
  BigDecimal count=null;
  BigDecimal perCpu=new BigDecimal(0);
  for (int i=0; i < attrCount; i++) {
    requireNoNamespaceAttribute(reader,i);
    final String value=reader.getAttributeValue(i);
    final Attribute attribute=Attribute.forName(reader.getAttributeLocalName(i));
switch (attribute) {
case COUNT:
{
        try {
          count=new BigDecimal(value);
          if (count.compareTo(BigDecimal.ZERO) < 0) {
            throw ThreadsLogger.ROOT_LOGGER.countMustBePositive(attribute,reader.getLocation());
          }
        }
 catch (        NumberFormatException e) {
          throw invalidAttributeValue(reader,i);
        }
        break;
      }
case PER_CPU:
{
      try {
        perCpu=new BigDecimal(value);
        if (perCpu.compareTo(BigDecimal.ZERO) < 0) {
          throw ThreadsLogger.ROOT_LOGGER.perCpuMustBePositive(attribute,reader.getLocation());
        }
      }
 catch (      NumberFormatException e) {
        throw invalidAttributeValue(reader,i);
      }
      break;
    }
default :
  throw unexpectedAttribute(reader,i);
}
}
if (count == null) {
throw missingRequired(reader,EnumSet.of(Attribute.COUNT));
}
ParseUtils.requireNoContent(reader);
int fullCount=getScaledCount(count,perCpu);
if (!perCpu.equals(new BigDecimal(0))) {
ThreadsLogger.ROOT_LOGGER.perCpuNotSupported(Attribute.PER_CPU,count,Attribute.COUNT,perCpu,Attribute.PER_CPU,Runtime.getRuntime().availableProcessors(),fullCount,Attribute.COUNT);
}
return String.valueOf(fullCount);
}
