{
  requireSingleAttribute(reader,Attribute.NAME.getLocalName());
  final String name=reader.getAttributeValue(0);
  if (!names.add(name)) {
    throw duplicateNamedElement(reader,name);
  }
  ScaledCount maxSize=null;
  TimeSpec keepaliveTime=null;
  String threadFactoryRef=null;
  final Map<String,String> map=new HashMap<String,String>();
  final EnumSet<Element> required=EnumSet.of(Element.MAX_THREADS);
  final EnumSet<Element> encountered=EnumSet.noneOf(Element.class);
  while (reader.nextTag() != END_ELEMENT) {
    if (!reader.getNamespaceURI().equals(Namespace.CURRENT.getUriString())) {
      throw unexpectedElement(reader);
    }
    final Element element=Element.forName(reader.getLocalName());
    required.remove(element);
    if (!encountered.add(element)) {
      throw unexpectedElement(reader);
    }
switch (element) {
case MAX_THREADS:
{
        maxSize=readScaledCountElement(reader);
        break;
      }
case KEEPALIVE_TIME:
{
      keepaliveTime=readTimeSpecElement(reader);
      break;
    }
}
}
final ScheduledThreadPoolAdd add=new ScheduledThreadPoolAdd(name,maxSize);
if (keepaliveTime != null) add.setKeepaliveTime(keepaliveTime);
if (threadFactoryRef != null) add.setThreadFactory(threadFactoryRef);
add.getProperties().putAll(map);
updates.add(add);
}
