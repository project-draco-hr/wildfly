{
  if (SessionSynchronization.class.isAssignableFrom(componentClass)) {
    return;
  }
  RuntimeAnnotationInformation<Boolean> afterBegin=MethodAnnotationAggregator.runtimeAnnotationInformation(componentClass,applicationClasses,deploymentReflectionIndex,AfterBegin.class);
  if (afterBegin.getMethodAnnotations().size() > 1) {
    throw new RuntimeException("Only one @AfterBegin method is allowed on bean " + description.getEJBClassName());
  }
 else   if (!afterBegin.getMethodAnnotations().isEmpty()) {
    Map.Entry<Method,List<Boolean>> entry=afterBegin.getMethodAnnotations().entrySet().iterator().next();
    description.setAfterBegin(entry.getKey().getDeclaringClass().getName(),entry.getKey().getName());
  }
  RuntimeAnnotationInformation<Boolean> afterComp=MethodAnnotationAggregator.runtimeAnnotationInformation(componentClass,applicationClasses,deploymentReflectionIndex,AfterCompletion.class);
  if (afterComp.getMethodAnnotations().size() > 1) {
    throw new RuntimeException("Only one @AfterCompletion method is allowed on bean " + description.getEJBClassName());
  }
 else   if (!afterComp.getMethodAnnotations().isEmpty()) {
    Map.Entry<Method,List<Boolean>> entry=afterComp.getMethodAnnotations().entrySet().iterator().next();
    description.setAfterCompletion(entry.getKey().getDeclaringClass().getName(),entry.getKey().getName());
  }
  RuntimeAnnotationInformation<Boolean> beforeComp=MethodAnnotationAggregator.runtimeAnnotationInformation(componentClass,applicationClasses,deploymentReflectionIndex,BeforeCompletion.class);
  if (beforeComp.getMethodAnnotations().size() > 1) {
    throw new RuntimeException("Only one @BeforeCompletion method is allowed on bean " + description.getEJBClassName());
  }
 else   if (!beforeComp.getMethodAnnotations().isEmpty()) {
    Map.Entry<Method,List<Boolean>> entry=beforeComp.getMethodAnnotations().entrySet().iterator().next();
    description.setBeforeCompletion(entry.getKey().getDeclaringClass().getName(),entry.getKey().getName());
  }
}
