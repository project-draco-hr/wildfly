{
  context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);
  context.addStep(new OperationStepHandler(){
    @Override public void execute(    final OperationContext context,    ModelNode operation){
      boolean start=operation.get("start").asBoolean(false);
      boolean stop=operation.get("stop").asBoolean(false);
      boolean fail=operation.get("fail").asBoolean(false);
      final boolean repair=fail && operation.get("repair").asBoolean(false);
      BlockingService bad=start ? (stop ? BlockingService.BOTH : BlockingService.START) : (stop ? BlockingService.STOP : BlockingService.NEITHER);
      final ServiceName svcName=ServiceName.JBOSS.append("bad-service");
      ServiceVerificationHandler verificationHandler=new ServiceVerificationHandler();
      context.getServiceTarget().addService(svcName,bad).addListener(verificationHandler).install();
      context.addStep(verificationHandler,OperationContext.Stage.VERIFY);
      try {
        bad.startLatch.await(20,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
      }
      if (fail) {
        context.setRollbackOnly();
        context.getFailureDescription().set("failfailfail");
      }
      context.completeStep(new OperationContext.ResultHandler(){
        @Override public void handleResult(        OperationContext.ResultAction resultAction,        OperationContext context,        ModelNode operation){
          if (repair) {
            releaseBlockingThreads();
          }
          context.removeService(svcName);
        }
      }
);
    }
  }
,OperationContext.Stage.RUNTIME);
  context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);
}
