{
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  final DeploymentUnit parent=deploymentUnit.getParent();
  final DeploymentUnit topLevelDeployment=parent == null ? deploymentUnit : parent;
  final VirtualFile topLevelRoot=topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();
  final ExternalModuleService externalModuleService=topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);
  final ResourceRoot deploymentRoot=deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
  final Set<VirtualFile> existingAccessibleRoots=new HashSet<VirtualFile>();
  final Map<VirtualFile,ResourceRoot> subDeployments=new HashMap<VirtualFile,ResourceRoot>();
  for (  ResourceRoot root : DeploymentUtils.allResourceRoots(topLevelDeployment)) {
    if (SubDeploymentMarker.isSubDeployment(root)) {
      subDeployments.put(root.getRoot(),root);
    }
 else     if (ModuleRootMarker.isModuleRoot(root)) {
      existingAccessibleRoots.add(root.getRoot());
    }
  }
  final ArrayDeque<RootEntry> resourceRoots=new ArrayDeque<RootEntry>();
  if (deploymentUnit.getParent() != null) {
    for (    ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {
      if (ModuleRootMarker.isModuleRoot(root)) {
        existingAccessibleRoots.add(root.getRoot());
      }
    }
  }
  for (  ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {
    resourceRoots.add(new RootEntry(deploymentUnit,root));
  }
  final Map<VirtualFile,AdditionalModuleSpecification> additionalModules=new HashMap<VirtualFile,AdditionalModuleSpecification>();
  for (  AdditionalModuleSpecification module : topLevelDeployment.getAttachmentList(Attachments.ADDITIONAL_MODULES)) {
    for (    ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {
      additionalModules.put(additionalModuleResourceRoot.getRoot(),module);
    }
  }
  while (!resourceRoots.isEmpty()) {
    final RootEntry entry=resourceRoots.pop();
    final ResourceRoot resourceRoot=entry.resourceRoot;
    final Attachable target=entry.target;
    if (SubDeploymentMarker.isSubDeployment(resourceRoot) && resourceRoot != deploymentRoot) {
      continue;
    }
    final String[] items=getClassPathEntries(resourceRoot);
    for (    final String item : items) {
      if (item.isEmpty()) {
        continue;
      }
      final VirtualFile classPathFile=resourceRoot.getRoot().getParent().getChild(item);
      final VirtualFile topLevelClassPathFile=deploymentRoot.getRoot().getParent().getChild(item);
      if (item.startsWith("/")) {
        final ModuleIdentifier moduleIdentifier=externalModuleService.addExternalModule(item);
        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,moduleIdentifier);
        ServerLogger.DEPLOYMENT_LOGGER.debugf("Resource %s added as external jar %s",classPathFile,resourceRoot.getRoot());
      }
 else {
        if (classPathFile.exists()) {
          handlingExistingClassPathEntry(deploymentUnit,resourceRoots,topLevelDeployment,topLevelRoot,subDeployments,additionalModules,existingAccessibleRoots,resourceRoot,target,classPathFile);
        }
 else         if (topLevelClassPathFile.exists()) {
          handlingExistingClassPathEntry(deploymentUnit,resourceRoots,topLevelDeployment,topLevelRoot,subDeployments,additionalModules,existingAccessibleRoots,resourceRoot,target,topLevelClassPathFile);
        }
 else {
          ServerLogger.DEPLOYMENT_LOGGER.warn("Class Path entry " + item + " in "+ resourceRoot.getRoot()+ "  does not point to a valid jar for a Class-Path reference.");
        }
      }
    }
  }
}
