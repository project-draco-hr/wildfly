{
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  final List<ResourceRoot> resourceRoots=DeploymentUtils.allResourceRoots(deploymentUnit);
  final DeploymentUnit parent=deploymentUnit.getParent();
  final DeploymentUnit topLevelDeployment=parent == null ? deploymentUnit : parent;
  final VirtualFile toplevelRoot=topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();
  final VirtualFile deploymentDirRoot=toplevelRoot.getParent();
  final ExternalModuleService externalModuleService=topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);
  final List<AdditionalModuleSpecification> additionalModuleList=topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);
  final List<ResourceRoot> topLevelResourceRoots=topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);
  final Map<VirtualFile,AdditionalModuleSpecification> additionalModules;
  if (additionalModuleList == null) {
    additionalModules=Collections.emptyMap();
  }
 else {
    additionalModules=new HashMap<VirtualFile,AdditionalModuleSpecification>();
    for (    AdditionalModuleSpecification module : additionalModuleList) {
      for (      ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {
        additionalModules.put(additionalModuleResourceRoot.getRoot(),module);
      }
    }
  }
  final Set<VirtualFile> earLibJars=new HashSet<VirtualFile>();
  if (topLevelResourceRoots != null) {
    for (    ResourceRoot resourceRoot : topLevelResourceRoots) {
      if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {
        earLibJars.add(resourceRoot.getRoot());
      }
    }
  }
  for (  ResourceRoot resourceRoot : resourceRoots) {
    if (deploymentUnit.getParent() == null && ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {
      continue;
    }
    final Attachable target;
    if (additionalModules.containsKey(resourceRoot.getRoot())) {
      target=additionalModules.get(resourceRoot.getRoot());
    }
 else {
      target=deploymentUnit;
    }
    final String[] items=getClassPathEntries(resourceRoot);
    for (    String item : items) {
      final VirtualFile classPathFile=resourceRoot.getRoot().getParent().getChild(item);
      if (!classPathFile.exists()) {
        throw new DeploymentUnitProcessingException("Class Path entry " + item + " in "+ resourceRoot.getRoot()+ "  not found. ");
      }
      if (isInside(classPathFile,toplevelRoot)) {
        if (earLibJars.contains(classPathFile)) {
          log.debugf("Class-Path entry %s in %s ignored, as target is in or referenced by /lib",classPathFile,resourceRoot.getRoot());
          continue;
        }
 else         if (additionalModules.containsKey(classPathFile)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,additionalModules.get(classPathFile).getModuleIdentifier());
        }
 else {
          throw new DeploymentUnitProcessingException("Class Path entry " + item + " in "+ resourceRoot.getRoot()+ "  does not point to a valid jar for a Class-Path reference.");
        }
      }
 else       if (isInside(classPathFile,deploymentDirRoot)) {
        if (classPathFile.getParent().equals(deploymentDirRoot)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + classPathFile.getName()));
        }
 else {
          throw new DeploymentUnitProcessingException("Class Path entries that references nestled jars inside another deployment are disallowed");
        }
      }
 else {
        ModuleIdentifier moduleIdentifier=externalModuleService.addExternalModule(classPathFile);
        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,moduleIdentifier);
        log.debugf("Resource %s added as external jar %s",classPathFile,resourceRoot.getRoot());
      }
    }
  }
}
