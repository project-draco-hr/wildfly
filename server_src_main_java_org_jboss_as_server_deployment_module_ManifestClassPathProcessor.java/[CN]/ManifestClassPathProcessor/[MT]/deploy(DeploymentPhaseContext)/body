{
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  if (deploymentUnit.getAttachment(Attachments.CLASS_PATH_ENTRIES) != null) {
    return;
  }
  final List<ResourceRoot> resourceRoots=DeploymentUtils.allResourceRoots(deploymentUnit);
  final DeploymentUnit parent=deploymentUnit.getParent();
  final DeploymentUnit topLevelDeployment=parent == null ? deploymentUnit : parent;
  final VirtualFile topLevelRoot=topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();
  final ExternalModuleService externalModuleService=topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);
  final List<AdditionalModuleSpecification> additionalModuleList=topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);
  final List<ResourceRoot> topLevelResourceRoots=topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);
  final ResourceRoot deploymentRoot=deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);
  final List<DeploymentUnit> subDeployments;
  if (deploymentUnit.getParent() == null) {
    subDeployments=deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);
  }
 else {
    subDeployments=deploymentUnit.getParent().getAttachmentList(Attachments.SUB_DEPLOYMENTS);
  }
  final Map<VirtualFile,ModuleIdentifier> subDeploymentModules=new HashMap<VirtualFile,ModuleIdentifier>();
  for (  DeploymentUnit deployment : subDeployments) {
    final ResourceRoot root=deployment.getAttachment(Attachments.DEPLOYMENT_ROOT);
    final ModuleIdentifier identifier=deployment.getAttachment(Attachments.MODULE_IDENTIFIER);
    if (root == null || identifier == null) {
      continue;
    }
    subDeploymentModules.put(root.getRoot(),identifier);
  }
  final Map<VirtualFile,AdditionalModuleSpecification> additionalModules;
  if (additionalModuleList == null) {
    additionalModules=Collections.emptyMap();
  }
 else {
    additionalModules=new HashMap<VirtualFile,AdditionalModuleSpecification>();
    for (    AdditionalModuleSpecification module : additionalModuleList) {
      for (      ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {
        additionalModules.put(additionalModuleResourceRoot.getRoot(),module);
      }
    }
  }
  final Set<VirtualFile> earLibJars=new HashSet<VirtualFile>();
  if (deploymentUnit.getParent() != null && topLevelResourceRoots != null) {
    for (    ResourceRoot resourceRoot : topLevelResourceRoots) {
      if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {
        earLibJars.add(resourceRoot.getRoot());
      }
    }
  }
  for (  ResourceRoot resourceRoot : resourceRoots) {
    if (SubDeploymentMarker.isSubDeployment(resourceRoot) && resourceRoot != deploymentRoot) {
      continue;
    }
    final Attachable target;
    if (additionalModules.containsKey(resourceRoot.getRoot())) {
      target=additionalModules.get(resourceRoot.getRoot());
    }
 else {
      target=deploymentUnit;
    }
    final String[] items=getClassPathEntries(resourceRoot);
    for (    String item : items) {
      boolean found=false;
      final VirtualFile classPathFile=resourceRoot.getRoot().getParent().getChild(item);
      final VirtualFile topLevelClassPathFile=deploymentRoot.getRoot().getParent().getChild(item);
      if (isInside(classPathFile,topLevelRoot)) {
        if (earLibJars.contains(classPathFile)) {
          log.debugf("Class-Path entry %s in %s ignored, as target is in or referenced by /lib",classPathFile,resourceRoot.getRoot());
        }
 else         if (additionalModules.containsKey(classPathFile)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,additionalModules.get(classPathFile).getModuleIdentifier());
        }
 else         if (subDeploymentModules.containsKey(classPathFile)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,subDeploymentModules.get(classPathFile));
        }
 else         if (additionalModules.containsKey(topLevelClassPathFile)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,additionalModules.get(topLevelClassPathFile).getModuleIdentifier());
        }
 else         if (subDeploymentModules.containsKey(topLevelClassPathFile)) {
          target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,subDeploymentModules.get(topLevelClassPathFile));
        }
 else         if (classPathFile.exists() && classPathFile.isDirectory()) {
        }
 else         if (topLevelClassPathFile.exists() && topLevelClassPathFile.isDirectory()) {
        }
 else {
          log.warn("Class Path entry " + item + " in "+ resourceRoot.getRoot()+ "  does not point to a valid jar for a Class-Path reference.");
        }
      }
 else       if (item.startsWith("/")) {
        ModuleIdentifier moduleIdentifier=externalModuleService.addExternalModule(item);
        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,moduleIdentifier);
        log.debugf("Resource %s added as external jar %s",classPathFile,resourceRoot.getRoot());
      }
 else {
        log.debugf("Ignoring missing Class-Path entry %s",classPathFile);
      }
    }
  }
}
