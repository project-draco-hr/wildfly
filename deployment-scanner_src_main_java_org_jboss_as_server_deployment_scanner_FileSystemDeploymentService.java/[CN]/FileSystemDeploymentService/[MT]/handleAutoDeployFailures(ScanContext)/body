{
  ScanStatus result=ScanStatus.PROCEED;
  boolean warnLogged=false;
  Set<File> noLongerIncomplete=new HashSet<File>(incompleteDeployments.keySet());
  noLongerIncomplete.removeAll(scanContext.incompleteFiles.keySet());
  int oldIncompleteCount=incompleteDeployments.size();
  incompleteDeployments.keySet().retainAll(scanContext.incompleteFiles.keySet());
  if (scanContext.incompleteFiles.size() > 0) {
    result=ScanStatus.RETRY;
    boolean logAll=incompleteDeployments.size() != oldIncompleteCount;
    long now=System.currentTimeMillis();
    for (    Map.Entry<File,IncompleteDeploymentStatus> entry : scanContext.incompleteFiles.entrySet()) {
      File incompleteFile=entry.getKey();
      String deploymentName=incompleteFile.getName();
      IncompleteDeploymentStatus status=incompleteDeployments.get(incompleteFile);
      if (status == null || status.size < entry.getValue().size) {
        status=entry.getValue();
      }
      if (now - status.timestamp > maxNoProgress) {
        if (!status.warned) {
          String suffix=deployed.containsKey(deploymentName) ? MESSAGES.previousContentDeployed() : "";
          String msg=MESSAGES.deploymentContentIncomplete(incompleteFile,suffix);
          writeFailedMarker(incompleteFile,msg,status.timestamp);
          ROOT_LOGGER.error(msg);
          status.warned=true;
          warnLogged=true;
          result=ScanStatus.ABORT;
        }
        new File(incompleteFile.getParentFile(),deploymentName + PENDING).delete();
      }
 else {
        boolean newIncomplete=incompleteDeployments.put(incompleteFile,status) == null;
        if (newIncomplete || logAll) {
          ROOT_LOGGER.incompleteContent(entry.getKey().getPath());
        }
        if (newIncomplete) {
          File pending=new File(incompleteFile.getParentFile(),deploymentName + PENDING);
          createMarkerFile(pending,deploymentName);
        }
      }
    }
  }
  for (  File complete : noLongerIncomplete) {
    File pending=new File(complete.getParentFile(),complete.getName() + PENDING);
    removeExtraneousMarker(pending,pending.getName());
  }
  int oldNonScannableCount=nonscannableLogged.size();
  nonscannableLogged.retainAll(scanContext.nonscannable.keySet());
  if (scanContext.nonscannable.size() > 0) {
    result=(result == ScanStatus.PROCEED ? ScanStatus.RETRY : result);
    boolean logAll=nonscannableLogged.size() != oldNonScannableCount;
    for (    Map.Entry<File,NonScannableStatus> entry : scanContext.nonscannable.entrySet()) {
      File nonScannable=entry.getKey();
      String fileName=nonScannable.getName();
      if (nonscannableLogged.add(nonScannable) || logAll) {
        NonScannableStatus nonScannableStatus=entry.getValue();
        NonScannableZipException e=nonScannableStatus.exception;
        String msg=MESSAGES.unsafeAutoDeploy(e.getLocalizedMessage(),fileName,DO_DEPLOY);
        writeFailedMarker(nonScannable,msg,nonScannableStatus.timestamp);
        ROOT_LOGGER.error(msg);
        warnLogged=true;
        result=ScanStatus.ABORT;
      }
    }
  }
  if (warnLogged) {
    Set<String> allProblems=new HashSet<String>();
    for (    File f : scanContext.nonscannable.keySet()) {
      allProblems.add(f.getName());
    }
    for (    File f : scanContext.incompleteFiles.keySet()) {
      allProblems.add(f.getName());
    }
    ROOT_LOGGER.unsafeAutoDeploy(DO_DEPLOY,SKIP_DEPLOY,allProblems);
  }
  return result;
}
