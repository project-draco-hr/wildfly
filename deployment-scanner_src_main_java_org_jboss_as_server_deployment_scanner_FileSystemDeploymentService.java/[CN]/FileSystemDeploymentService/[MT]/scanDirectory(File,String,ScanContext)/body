{
  final File[] children=directory.listFiles(filter);
  if (children == null) {
    return;
  }
  for (  File child : children) {
    final String fileName=child.getName();
    if (fileName.endsWith(DEPLOYED)) {
      final String deploymentName=fileName.substring(0,fileName.length() - DEPLOYED.length());
      DeploymentMarker deploymentMarker=deployed.get(deploymentName);
      if (deploymentMarker == null) {
        scanContext.toRemove.remove(deploymentName);
        removeExtraneousMarker(child,fileName);
      }
 else {
        final File deploymentFile=new File(directory,deploymentName);
        if (deploymentFile.exists()) {
          scanContext.toRemove.remove(deploymentName);
          if (deployed.get(deploymentName).lastModified != child.lastModified()) {
            scanContext.scannerTasks.add(new RedeployTask(deploymentName,child.lastModified(),directory,!child.isDirectory()));
          }
 else {
            Boolean isDeployed=scanContext.registeredDeployments.get(deploymentName);
            if (isDeployed == null || !isDeployed) {
              deployed.remove(deploymentName);
              removeExtraneousMarker(child,fileName);
              final File marker=new File(directory,deploymentName + UNDEPLOYED);
              createMarkerFile(marker,deploymentName);
              if (isDeployed == null) {
                DeploymentScannerLogger.ROOT_LOGGER.scannerDeploymentRemovedButNotByScanner(deploymentName,marker);
              }
 else {
                DeploymentScannerLogger.ROOT_LOGGER.scannerDeploymentUndeployedButNotByScanner(deploymentName,marker);
              }
            }
          }
        }
 else {
          boolean autoDeployable=deploymentMarker.archive ? autoDeployZip : autoDeployExploded;
          if (!autoDeployable) {
            scanContext.toRemove.remove(deploymentName);
            if (!deploymentMarker.archive) {
              scanContext.prematureExplodedDeletions.add(deploymentName);
            }
          }
        }
      }
    }
 else     if (fileName.endsWith(DO_DEPLOY) || (fileName.endsWith(FAILED_DEPLOY) && firstScan)) {
      final String markerStatus=fileName.endsWith(DO_DEPLOY) ? DO_DEPLOY : FAILED_DEPLOY;
      final String deploymentName=fileName.substring(0,fileName.length() - markerStatus.length());
      if (FAILED_DEPLOY.equals(markerStatus)) {
        ROOT_LOGGER.reattemptingFailedDeployment(deploymentName);
      }
      final File deploymentFile=new File(directory,deploymentName);
      if (!deploymentFile.exists()) {
        scanContext.ignoredMissingDeployments.add(deploymentName);
        continue;
      }
      long timestamp=getDeploymentTimestamp(deploymentFile);
      final String path=relativeTo == null ? deploymentFile.getAbsolutePath() : relativePath + deploymentName;
      final boolean archive=deploymentFile.isFile();
      addContentAddingTask(path,archive,deploymentName,deploymentFile,timestamp,scanContext);
    }
 else     if (fileName.endsWith(FAILED_DEPLOY)) {
      final String deploymentName=fileName.substring(0,fileName.length() - FAILED_DEPLOY.length());
      scanContext.toRemove.remove(deploymentName);
      if (!deployed.containsKey(deploymentName) && !(new File(child.getParent(),deploymentName).exists())) {
        removeExtraneousMarker(child,fileName);
      }
    }
 else     if (isEEArchive(fileName)) {
      boolean autoDeployable=child.isDirectory() ? autoDeployExploded : autoDeployZip;
      if (autoDeployable) {
        if (!isAutoDeployDisabled(child)) {
          long timestamp=getDeploymentTimestamp(child);
          if (isFailedOrUndeployed(scanContext,directory,fileName,timestamp))           continue;
          DeploymentMarker marker=deployed.get(fileName);
          if (marker == null || marker.lastModified != timestamp) {
            try {
              if (isZipComplete(child)) {
                final String path=relativeTo == null ? child.getAbsolutePath() : relativePath + fileName;
                final boolean archive=child.isFile();
                addContentAddingTask(path,archive,fileName,child,timestamp,scanContext);
              }
 else {
                if (child.exists()) {
                  scanContext.incompleteFiles.put(child,new IncompleteDeploymentStatus(child,timestamp));
                }
              }
            }
 catch (            NonScannableZipException e) {
              scanContext.nonscannable.put(child,new NonScannableStatus(e,timestamp));
            }
          }
        }
      }
 else       if (!deployed.containsKey(fileName) && !new File(fileName + DO_DEPLOY).exists() && !new File(fileName + FAILED_DEPLOY).exists()) {
        scanContext.nonDeployable.add(fileName);
      }
    }
 else     if (isXmlFile(fileName)) {
      if (autoDeployXml) {
        if (!isAutoDeployDisabled(child)) {
          long timestamp=getDeploymentTimestamp(child);
          if (isFailedOrUndeployed(scanContext,directory,fileName,timestamp))           continue;
          DeploymentMarker marker=deployed.get(fileName);
          if (marker == null || marker.lastModified != timestamp) {
            if (isXmlComplete(child)) {
              final String path=relativeTo == null ? child.getAbsolutePath() : relativePath + fileName;
              addContentAddingTask(path,true,fileName,child,timestamp,scanContext);
            }
 else {
              if (child.exists()) {
                scanContext.incompleteFiles.put(child,new IncompleteDeploymentStatus(child,timestamp));
              }
            }
          }
        }
      }
 else       if (!deployed.containsKey(fileName) && !new File(fileName + DO_DEPLOY).exists() && !new File(fileName + FAILED_DEPLOY).exists()) {
        scanContext.nonDeployable.add(fileName);
      }
    }
 else     if (fileName.endsWith(DEPLOYING) || fileName.endsWith(UNDEPLOYING)) {
      removeExtraneousMarker(child,fileName);
    }
 else     if (fileName.endsWith(PENDING)) {
      final String deploymentName=fileName.substring(0,fileName.length() - PENDING.length());
      File deployment=new File(child.getParent(),deploymentName);
      if (!deployment.exists()) {
        removeExtraneousMarker(child,fileName);
      }
    }
 else     if (child.isDirectory()) {
      if (WEB_INF.equalsIgnoreCase(fileName) || META_INF.equalsIgnoreCase(fileName)) {
        scanContext.illegalDir.add(fileName);
      }
 else {
        scanDirectory(child,relativePath + child.getName() + File.separator,scanContext);
      }
    }
  }
}
