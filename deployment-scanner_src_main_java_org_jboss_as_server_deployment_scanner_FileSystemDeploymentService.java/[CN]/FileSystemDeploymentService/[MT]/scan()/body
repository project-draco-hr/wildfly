{
  try {
    scanLock.lockInterruptibly();
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
    return;
  }
  boolean scheduleRescan=false;
  try {
    if (scanEnabled) {
      log.tracef("Scanning directory %s for deployment content changes",deploymentDir.getAbsolutePath());
      ScanContext scanContext=new ScanContext();
      scanDirectory(deploymentDir,relativePath,scanContext);
      ignoredMissingDeployments.retainAll(scanContext.ignoredMissingDeployments);
      for (      String deploymentName : scanContext.ignoredMissingDeployments) {
        if (ignoredMissingDeployments.add(deploymentName)) {
          log.warnf("Deployment of '%s' requested, but the deployment is not present",deploymentName);
        }
      }
      noticeLogged.retainAll(scanContext.nonDeployable);
      for (      String fileName : scanContext.nonDeployable) {
        if (noticeLogged.add(fileName)) {
          log.infof("Found %s in deployment directory. To trigger deployment create a file called %s%s",fileName,fileName,DO_DEPLOY);
        }
      }
      illegalDirLogged.retainAll(scanContext.illegalDir);
      for (      String fileName : scanContext.illegalDir) {
        if (illegalDirLogged.add(fileName)) {
          log.errorf("The deployment scanner found a directory named %s that was not inside a directory whose " + "name ends with .ear, .jar, .rar, .sar or .war. This is likely the result of unzipping an " + "archive directly inside the %s directory, which is a user error. "+ "The %s directory will not be scanned for deployments, but it is possible that the scanner may"+ "find other files from the unzipped archive and attempt to deploy them, leading to errors.",fileName,deploymentDir.getAbsolutePath(),fileName);
        }
      }
      ScanStatus status=handleAutoDeployFailures(scanContext);
      if (status != ScanStatus.PROCEED) {
        if (status == ScanStatus.RETRY && scanInterval > 1000) {
          scheduleRescan=true;
        }
        return;
      }
      List<ScannerTask> scannerTasks=scanContext.scannerTasks;
      for (      String missing : scanContext.toRemove) {
        File parent=deploymentDir;
        scannerTasks.add(new UndeployTask(missing,parent));
      }
      if (scannerTasks.size() > 0) {
        List<ModelNode> updates=new ArrayList<ModelNode>(scannerTasks.size());
        for (        ScannerTask task : scannerTasks) {
          task.recordInProgress();
          final ModelNode update=task.getUpdate();
          if (log.isDebugEnabled()) {
            log.debugf("Deployment scan of [%s] found update action [%s]",deploymentDir,update);
          }
          updates.add(update);
        }
        while (!updates.isEmpty()) {
          ModelNode composite=getCompositeUpdate(updates);
          final DeploymentTask deploymentTask=new DeploymentTask(new OperationBuilder(composite).build());
          final Future<ModelNode> futureResults=scheduledExecutor.submit(deploymentTask);
          final ModelNode results;
          try {
            results=futureResults.get(deploymentTimeout,TimeUnit.SECONDS);
          }
 catch (          TimeoutException e) {
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set("Did not receive a response to the deployment operation within " + "the allowed timeout period [" + deploymentTimeout + " seconds]. Check the server configuration"+ "file and the server logs to find more about the status of the deployment.");
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
catch (          Exception e) {
            log.error("File system deployment service failed",e);
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set(e.getMessage());
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
          final List<Property> resultList=results.get(RESULT).asPropertyList();
          final List<ModelNode> toRetry=new ArrayList<ModelNode>();
          final List<ScannerTask> retryTasks=new ArrayList<ScannerTask>();
          for (int i=0; i < resultList.size(); i++) {
            final ModelNode result=resultList.get(i).getValue();
            final ScannerTask task=scannerTasks.get(i);
            final ModelNode outcome=result.get(OUTCOME);
            if (outcome.isDefined() && SUCCESS.equals(outcome.asString())) {
              task.handleSuccessResult();
            }
 else             if (outcome.isDefined() && CANCELLED.equals(outcome.asString())) {
              toRetry.add(updates.get(i));
              retryTasks.add(task);
            }
 else {
              task.handleFailureResult(result);
            }
          }
          updates=toRetry;
          scannerTasks=retryTasks;
        }
      }
      log.tracef("Scan complete");
    }
  }
  finally {
    scanLock.unlock();
    if (scheduleRescan) {
synchronized (this) {
        if (scanEnabled) {
          rescanIncompleteTask=scheduledExecutor.schedule(scanRunnable,200,TimeUnit.MILLISECONDS);
        }
      }
    }
  }
}
