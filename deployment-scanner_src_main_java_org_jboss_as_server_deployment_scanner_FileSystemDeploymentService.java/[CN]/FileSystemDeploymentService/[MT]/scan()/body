{
  try {
    scanLock.lockInterruptibly();
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
    return;
  }
  boolean scheduleRescan=false;
  try {
    if (scanEnabled) {
      ROOT_LOGGER.tracef("Scanning directory %s for deployment content changes",deploymentDir.getAbsolutePath());
      ScanContext scanContext=new ScanContext();
      scanDirectory(deploymentDir,relativePath,scanContext);
      ignoredMissingDeployments.retainAll(scanContext.ignoredMissingDeployments);
      for (      String deploymentName : scanContext.ignoredMissingDeployments) {
        if (ignoredMissingDeployments.add(deploymentName)) {
          ROOT_LOGGER.deploymentNotFound(deploymentName);
        }
      }
      noticeLogged.retainAll(scanContext.nonDeployable);
      for (      String fileName : scanContext.nonDeployable) {
        if (noticeLogged.add(fileName)) {
          ROOT_LOGGER.deploymentTriggered(fileName,DO_DEPLOY);
        }
      }
      illegalDirLogged.retainAll(scanContext.illegalDir);
      for (      String fileName : scanContext.illegalDir) {
        if (illegalDirLogged.add(fileName)) {
          ROOT_LOGGER.invalidExplodedDeploymentDirectory(fileName,deploymentDir.getAbsolutePath());
        }
      }
      prematureExplodedContentDeletionLogged.retainAll(scanContext.prematureExplodedDeletions);
      for (      String fileName : scanContext.prematureExplodedDeletions) {
        if (prematureExplodedContentDeletionLogged.add(fileName)) {
          ROOT_LOGGER.explodedDeploymentContentDeleted(fileName,DEPLOYED);
        }
      }
      ScanStatus status=handleAutoDeployFailures(scanContext);
      if (status != ScanStatus.PROCEED) {
        if (status == ScanStatus.RETRY && scanInterval > 1000) {
          scheduleRescan=true;
        }
        return;
      }
      List<ScannerTask> scannerTasks=scanContext.scannerTasks;
      for (      String missing : scanContext.toRemove) {
        File parent=deploymentDir;
        scannerTasks.add(new UndeployTask(missing,parent,scanContext.scanStartTime));
      }
      if (scannerTasks.size() > 0) {
        List<ModelNode> updates=new ArrayList<ModelNode>(scannerTasks.size());
        for (        ScannerTask task : scannerTasks) {
          task.recordInProgress();
          final ModelNode update=task.getUpdate();
          if (ROOT_LOGGER.isDebugEnabled()) {
            ROOT_LOGGER.debugf("Deployment scan of [%s] found update action [%s]",deploymentDir,update);
          }
          updates.add(update);
        }
        while (!updates.isEmpty()) {
          ModelNode composite=getCompositeUpdate(updates);
          final DeploymentTask deploymentTask=new DeploymentTask(new OperationBuilder(composite).build());
          final Future<ModelNode> futureResults=scheduledExecutor.submit(deploymentTask);
          final ModelNode results;
          try {
            results=futureResults.get(deploymentTimeout,TimeUnit.SECONDS);
          }
 catch (          TimeoutException e) {
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set(MESSAGES.deploymentTimeout(deploymentTimeout));
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
catch (          Exception e) {
            ROOT_LOGGER.fileSystemDeploymentFailed(e);
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set(e.getMessage());
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
          final List<Property> resultList=results.get(RESULT).asPropertyList();
          final List<ModelNode> toRetry=new ArrayList<ModelNode>();
          final List<ScannerTask> retryTasks=new ArrayList<ScannerTask>();
          for (int i=0; i < resultList.size(); i++) {
            final ModelNode result=resultList.get(i).getValue();
            final ScannerTask task=scannerTasks.get(i);
            final ModelNode outcome=result.get(OUTCOME);
            if (outcome.isDefined() && SUCCESS.equals(outcome.asString())) {
              task.handleSuccessResult();
            }
 else             if (outcome.isDefined() && CANCELLED.equals(outcome.asString())) {
              toRetry.add(updates.get(i));
              retryTasks.add(task);
            }
 else {
              task.handleFailureResult(result);
            }
          }
          updates=toRetry;
          scannerTasks=retryTasks;
        }
      }
      ROOT_LOGGER.tracef("Scan complete");
    }
  }
  finally {
    scanLock.unlock();
    if (scheduleRescan) {
synchronized (this) {
        if (scanEnabled) {
          rescanIncompleteTask=scheduledExecutor.schedule(scanRunnable,200,TimeUnit.MILLISECONDS);
        }
      }
    }
  }
}
