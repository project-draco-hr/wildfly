{
  try {
    scanLock.lockInterruptibly();
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
    return;
  }
  boolean scheduleRescan=false;
  try {
    if (scanEnabled || oneOffScan) {
      ROOT_LOGGER.tracef("Scanning directory %s for deployment content changes",deploymentDir.getAbsolutePath());
      ScanContext scanContext=new ScanContext(deploymentOperations);
      if (!forcedUndeployScan)       scanDirectory(deploymentDir,relativePath,scanContext);
      ignoredMissingDeployments.retainAll(scanContext.ignoredMissingDeployments);
      for (      String deploymentName : scanContext.ignoredMissingDeployments) {
        if (ignoredMissingDeployments.add(deploymentName)) {
          ROOT_LOGGER.deploymentNotFound(deploymentName);
        }
      }
      noticeLogged.retainAll(scanContext.nonDeployable);
      for (      String fileName : scanContext.nonDeployable) {
        if (noticeLogged.add(fileName)) {
          ROOT_LOGGER.deploymentTriggered(fileName,DO_DEPLOY);
        }
      }
      illegalDirLogged.retainAll(scanContext.illegalDir);
      for (      String fileName : scanContext.illegalDir) {
        if (illegalDirLogged.add(fileName)) {
          ROOT_LOGGER.invalidExplodedDeploymentDirectory(fileName,deploymentDir.getAbsolutePath());
        }
      }
      prematureExplodedContentDeletionLogged.retainAll(scanContext.prematureExplodedDeletions);
      for (      String fileName : scanContext.prematureExplodedDeletions) {
        if (prematureExplodedContentDeletionLogged.add(fileName)) {
          ROOT_LOGGER.explodedDeploymentContentDeleted(fileName,DEPLOYED);
        }
      }
      ScanStatus status=handleAutoDeployFailures(scanContext);
      if (status != ScanStatus.PROCEED) {
        if (status == ScanStatus.RETRY && scanInterval > 1000) {
          scheduleRescan=true;
        }
        return;
      }
      List<ScannerTask> scannerTasks=scanContext.scannerTasks;
      for (      Map.Entry<String,DeploymentMarker> missing : scanContext.toRemove.entrySet()) {
        if (!forcedUndeployScan)         scannerTasks.add(new UndeployTask(missing.getKey(),missing.getValue().parentFolder,scanContext.scanStartTime,false));
 else {
          if (scanContext.registeredDeployments.containsKey(missing.getKey()))           scanContext.registeredDeployments.remove(missing.getKey());
        }
      }
      if (forcedUndeployScan) {
        for (        Map.Entry<String,Boolean> toUndeploy : scanContext.registeredDeployments.entrySet()) {
          scannerTasks.add(new UndeployTask(toUndeploy.getKey(),deploymentDir,scanContext.scanStartTime,true));
        }
      }
      if (scannerTasks.size() > 0) {
        List<ModelNode> updates=new ArrayList<ModelNode>(scannerTasks.size());
        for (        ScannerTask task : scannerTasks) {
          task.recordInProgress();
          final ModelNode update=task.getUpdate();
          if (ROOT_LOGGER.isDebugEnabled()) {
            ROOT_LOGGER.debugf("Deployment scan of [%s] found update action [%s]",deploymentDir,update);
          }
          updates.add(update);
        }
        boolean first=true;
        while (!updates.isEmpty() && (first || !oneOffScan)) {
          first=false;
          final Future<ModelNode> futureResults=deploymentOperations.deploy(getCompositeUpdate(updates),scheduledExecutor);
          final ModelNode results;
          try {
            results=futureResults.get(deploymentTimeout,TimeUnit.SECONDS);
          }
 catch (          TimeoutException e) {
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set(MESSAGES.deploymentTimeout(deploymentTimeout));
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
catch (          Exception e) {
            ROOT_LOGGER.fileSystemDeploymentFailed(e);
            futureResults.cancel(true);
            final ModelNode failure=new ModelNode();
            failure.get(OUTCOME).set(FAILED);
            failure.get(FAILURE_DESCRIPTION).set(e.getMessage());
            for (            ScannerTask task : scannerTasks) {
              task.handleFailureResult(failure);
            }
            break;
          }
          final List<ModelNode> toRetry=new ArrayList<ModelNode>();
          final List<ScannerTask> retryTasks=new ArrayList<ScannerTask>();
          if (results.hasDefined(RESULT)) {
            final List<Property> resultList=results.get(RESULT).asPropertyList();
            requireUndeploy=false;
            for (int i=0; i < resultList.size(); i++) {
              final ModelNode result=resultList.get(i).getValue();
              final ScannerTask task=scannerTasks.get(i);
              final ModelNode outcome=result.get(OUTCOME);
              StringBuilder failureDesc=new StringBuilder();
              if (outcome.isDefined() && SUCCESS.equals(outcome.asString()) && handleCompositeResult(result,failureDesc)) {
                task.handleSuccessResult();
              }
 else               if (outcome.isDefined() && CANCELLED.equals(outcome.asString())) {
                toRetry.add(updates.get(i));
                retryTasks.add(task);
              }
 else {
                if (failureDesc.length() > 0) {
                  result.get(FAILURE_DESCRIPTION).set(failureDesc.toString());
                  requireUndeploy=true;
                }
                task.handleFailureResult(result);
              }
            }
            updates=toRetry;
            scannerTasks=retryTasks;
          }
 else {
            for (            ScannerTask current : scannerTasks) {
              current.handleFailureResult(results);
            }
          }
        }
      }
      ROOT_LOGGER.tracef("Scan complete");
      firstScan=false;
    }
  }
  finally {
    scanLock.unlock();
    if (scheduleRescan) {
synchronized (this) {
        if (scanEnabled && !oneOffScan) {
          rescanIncompleteTask=scheduledExecutor.schedule(scanRunnable,200,TimeUnit.MILLISECONDS);
        }
      }
    }
    if (requireUndeploy) {
synchronized (this) {
        if (scanEnabled && oneOffScan) {
          rescanUndeployTask=scheduledExecutor.schedule(new UndeployScanRunnable(),200,TimeUnit.MILLISECONDS);
        }
      }
    }
  }
}
