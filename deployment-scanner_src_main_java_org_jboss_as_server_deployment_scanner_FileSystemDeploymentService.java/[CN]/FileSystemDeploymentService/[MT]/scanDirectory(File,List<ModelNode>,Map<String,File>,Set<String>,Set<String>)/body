{
  File[] children=directory.listFiles(filter);
  if (children == null) {
    return;
  }
  for (  File child : children) {
    String fileName=child.getName();
    if (fileName.endsWith(DEPLOYED)) {
      String origName=fileName.substring(0,fileName.length() - DEPLOYED.length());
      foundDeployed.put(origName,child);
    }
 else     if (child.isDirectory()) {
      int idx=fileName.lastIndexOf('.');
      if (idx > -1 && ARCHIVES.contains(fileName.substring(idx))) {
        log.warnf("%s is an exploded deployment and exploded deployments are not currently handled by %s",child.getName(),getClass().getSimpleName());
      }
 else {
        scanDirectory(child,updates,foundDeployed,newlyAdded,registeredDeployments);
      }
    }
 else {
      boolean uploaded=false;
      if (registeredDeployments.contains(fileName)) {
        byte[] hash=new byte[0];
        try {
          final InputStream inputStream=new FileInputStream(child);
          hash=deploymentRepository.addDeploymentContent(fileName,fileName,inputStream);
        }
 catch (        IOException e) {
          log.error("Failed to add content to deployment repository for [" + fileName + "]",e);
          continue;
        }
        updates.add(getFullReplaceOperation(fileName,hash));
        uploaded=true;
      }
 else {
        byte[] hash=new byte[0];
        try {
          final InputStream inputStream=new FileInputStream(child);
          hash=deploymentRepository.addDeploymentContent(fileName,fileName,inputStream);
        }
 catch (        IOException e) {
          log.error("Failed to add content to deployment repository for [" + fileName + "]",e);
          continue;
        }
        updates.add(getAddOperation(fileName,hash));
        updates.add(getDeployOperation(fileName));
        uploaded=true;
      }
      if (uploaded && replaceWithDeployedMarker(child)) {
        newlyAdded.add(fileName);
      }
    }
  }
}
