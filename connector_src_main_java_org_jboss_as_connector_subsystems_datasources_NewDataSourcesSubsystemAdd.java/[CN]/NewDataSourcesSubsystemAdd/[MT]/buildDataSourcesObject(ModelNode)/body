{
  List<DataSource> datasourceList=new ArrayList<DataSource>();
  List<XaDataSource> xadatasourceList=new ArrayList<XaDataSource>();
  if (operation.hasDefined(DATASOURCES)) {
    for (    ModelNode dataSourceNode : operation.get(DATASOURCES).asList()) {
      Map<String,String> connectionProperties;
      if (dataSourceNode.has(CONNECTION_PROPERTIES)) {
        connectionProperties=new HashMap<String,String>(dataSourceNode.get(CONNECTION_PROPERTIES).asList().size());
        for (        ModelNode property : dataSourceNode.get(CONNECTION_PROPERTIES).asList()) {
          connectionProperties.put(property.asProperty().getName(),property.asString());
        }
      }
 else {
        connectionProperties=Collections.EMPTY_MAP;
      }
      String connectionUrl=dataSourceNode.get(CONNECTION_URL).asString();
      String driverClass=dataSourceNode.get(DRIVER_CLASS).asString();
      String jndiName=dataSourceNode.get(JNDINAME).asString();
      String module=dataSourceNode.get(MODULE).asString();
      String newConnectionSql=dataSourceNode.get(NEW_CONNECTION_SQL).asString();
      String poolName=dataSourceNode.get(POOLNAME).asString();
      String urlDelimiter=dataSourceNode.get(URL_DELIMITER).asString();
      String urlSelectorStrategyClassName=dataSourceNode.get(URL_SELECTOR_STRATEGY_CLASS_NAME).asString();
      boolean useJavaContext=dataSourceNode.get(USE_JAVA_CONTEXT).asBoolean();
      boolean enabled=dataSourceNode.get(ENABLED).asBoolean();
      Integer maxPoolSize=dataSourceNode.get(MAX_POOL_SIZE).asInt();
      Integer minPoolSize=dataSourceNode.get(MIN_POOL_SIZE).asInt();
      boolean prefill=dataSourceNode.get(POOL_PREFILL).asBoolean();
      boolean useStrictMin=dataSourceNode.get(POOL_USE_STRICT_MIN).asBoolean();
      CommonPool pool=new CommonPoolImpl(minPoolSize,maxPoolSize,prefill,useStrictMin);
      CommonSecurity security=new CommonSecurityImpl(dataSourceNode.get(USERNAME).asString(),dataSourceNode.get(PASSWORD).asString());
      boolean sharePreparedStatements=dataSourceNode.get(SHAREPREPAREDSTATEMENTS).asBoolean();
      Long preparedStatementsCacheSize=dataSourceNode.get(PREPAREDSTATEMENTSCACHESIZE).asLong();
      TrackStatementsEnum trackStatements=TrackStatementsEnum.valueOf(dataSourceNode.get(TRACKSTATEMENTS).asString());
      Statement statement=new StatementImpl(sharePreparedStatements,preparedStatementsCacheSize,trackStatements);
      Integer allocationRetry=dataSourceNode.get(ALLOCATION_RETRY).asInt();
      Long allocationRetryWaitMillis=dataSourceNode.get(ALLOCATION_RETRY_WAIT_MILLIS).asLong();
      Long blockingTimeoutMillis=dataSourceNode.get(BLOCKING_TIMEOUT_WAIT_MILLIS).asLong();
      Long idleTimeoutMinutes=dataSourceNode.get(IDLETIMEOUTMINUTES).asLong();
      Long queryTimeout=dataSourceNode.get(QUERYTIMEOUT).asLong();
      Integer xaResourceTimeout=dataSourceNode.get(XA_RESOURCE_TIMEOUT).asInt();
      Long useTryLock=dataSourceNode.get(USETRYLOCK).asLong();
      Boolean setTxQuertTimeout=dataSourceNode.get(SETTXQUERTTIMEOUT).asBoolean();
      TimeOut timeOut=new TimeOutImpl(blockingTimeoutMillis,idleTimeoutMinutes,allocationRetry,allocationRetryWaitMillis,xaResourceTimeout,setTxQuertTimeout,queryTimeout,useTryLock);
      TransactionIsolation transactionIsolation=TransactionIsolation.valueOf(dataSourceNode.get(TRANSACTION_ISOLOATION).asString());
      String checkValidConnectionSql=dataSourceNode.get(CHECKVALIDCONNECTIONSQL).asString();
      String exceptionSorterClassName=dataSourceNode.get(EXCEPTIONSORTERCLASSNAME).asString();
      String staleConnectionCheckerClassName=dataSourceNode.get(STALECONNECTIONCHECKERCLASSNAME).asString();
      String validConnectionCheckerClassName=dataSourceNode.get(VALIDCONNECTIONCHECKERCLASSNAME).asString();
      Long backgroundValidationMinutes=dataSourceNode.get(BACKGROUNDVALIDATIONMINUTES).asLong();
      boolean backgroundValidation=dataSourceNode.get(BACKGROUNDVALIDATION).asBoolean();
      boolean useFastFail=dataSourceNode.get(USE_FAST_FAIL).asBoolean();
      boolean validateOnMatch=dataSourceNode.get(VALIDATEONMATCH).asBoolean();
      Validation validation=new ValidationImpl(backgroundValidation,backgroundValidationMinutes,useFastFail,validConnectionCheckerClassName,checkValidConnectionSql,validateOnMatch,staleConnectionCheckerClassName,exceptionSorterClassName);
      DataSource ds=new DataSourceImpl(connectionUrl,driverClass,module,transactionIsolation,connectionProperties,timeOut,security,statement,validation,urlDelimiter,urlSelectorStrategyClassName,newConnectionSql,useJavaContext,poolName,enabled,jndiName,pool);
      datasourceList.add(ds);
    }
  }
  if (operation.hasDefined(XA_DATASOURCES)) {
    for (    ModelNode dataSourceNode : operation.get(XA_DATASOURCES).asList()) {
      Map<String,String> xaDataSourceProperty=new HashMap<String,String>(dataSourceNode.get(XADATASOURCEPROPERTIES).asList().size());
      for (      ModelNode property : dataSourceNode.get(XADATASOURCEPROPERTIES).asList()) {
        xaDataSourceProperty.put(property.asProperty().getName(),property.asString());
      }
      String xaDataSourceClass=dataSourceNode.get(XADATASOURCECLASS).asString();
      String jndiName=dataSourceNode.get(JNDINAME).asString();
      String module=dataSourceNode.get(MODULE).asString();
      String newConnectionSql=dataSourceNode.get(NEW_CONNECTION_SQL).asString();
      String poolName=dataSourceNode.get(POOLNAME).asString();
      String urlDelimiter=dataSourceNode.get(URL_DELIMITER).asString();
      String urlSelectorStrategyClassName=dataSourceNode.get(URL_SELECTOR_STRATEGY_CLASS_NAME).asString();
      boolean useJavaContext=dataSourceNode.get(USE_JAVA_CONTEXT).asBoolean();
      boolean enabled=dataSourceNode.get(ENABLED).asBoolean();
      Integer maxPoolSize=dataSourceNode.get(MAX_POOL_SIZE).asInt();
      Integer minPoolSize=dataSourceNode.get(MIN_POOL_SIZE).asInt();
      boolean prefill=dataSourceNode.get(POOL_PREFILL).asBoolean();
      boolean useStrictMin=dataSourceNode.get(POOL_USE_STRICT_MIN).asBoolean();
      boolean interleaving=dataSourceNode.get(INTERLIVING).asBoolean();
      boolean noTxSeparatePool=dataSourceNode.get(NOTXSEPARATEPOOL).asBoolean();
      boolean padXid=dataSourceNode.get(PAD_XID).asBoolean();
      boolean isSameRmOverride=dataSourceNode.get(SAME_RM_OVERRIDE).asBoolean();
      boolean wrapXaDataSource=dataSourceNode.get(WRAP_XA_DATASOURCE).asBoolean();
      CommonXaPool xaPool=new CommonXaPoolImpl(minPoolSize,maxPoolSize,prefill,useStrictMin,isSameRmOverride,interleaving,padXid,wrapXaDataSource,noTxSeparatePool);
      CommonSecurity security=new CommonSecurityImpl(dataSourceNode.get(USERNAME).asString(),dataSourceNode.get(PASSWORD).asString());
      boolean sharePreparedStatements=dataSourceNode.get(SHAREPREPAREDSTATEMENTS).asBoolean();
      Long preparedStatementsCacheSize=dataSourceNode.get(PREPAREDSTATEMENTSCACHESIZE).asLong();
      TrackStatementsEnum trackStatements=TrackStatementsEnum.valueOf(dataSourceNode.get(TRACKSTATEMENTS).asString());
      Statement statement=new StatementImpl(sharePreparedStatements,preparedStatementsCacheSize,trackStatements);
      Integer allocationRetry=dataSourceNode.get(ALLOCATION_RETRY).asInt();
      Long allocationRetryWaitMillis=dataSourceNode.get(ALLOCATION_RETRY_WAIT_MILLIS).asLong();
      Long blockingTimeoutMillis=dataSourceNode.get(BLOCKING_TIMEOUT_WAIT_MILLIS).asLong();
      Long idleTimeoutMinutes=dataSourceNode.get(IDLETIMEOUTMINUTES).asLong();
      Long queryTimeout=dataSourceNode.get(QUERYTIMEOUT).asLong();
      Integer xaResourceTimeout=dataSourceNode.get(XA_RESOURCE_TIMEOUT).asInt();
      Long useTryLock=dataSourceNode.get(USETRYLOCK).asLong();
      Boolean setTxQuertTimeout=dataSourceNode.get(SETTXQUERTTIMEOUT).asBoolean();
      TimeOut timeOut=new TimeOutImpl(blockingTimeoutMillis,idleTimeoutMinutes,allocationRetry,allocationRetryWaitMillis,xaResourceTimeout,setTxQuertTimeout,queryTimeout,useTryLock);
      TransactionIsolation transactionIsolation=TransactionIsolation.valueOf(dataSourceNode.get(TRANSACTION_ISOLOATION).asString());
      String checkValidConnectionSql=dataSourceNode.get(CHECKVALIDCONNECTIONSQL).asString();
      String exceptionSorterClassName=dataSourceNode.get(EXCEPTIONSORTERCLASSNAME).asString();
      String staleConnectionCheckerClassName=dataSourceNode.get(STALECONNECTIONCHECKERCLASSNAME).asString();
      String validConnectionCheckerClassName=dataSourceNode.get(VALIDCONNECTIONCHECKERCLASSNAME).asString();
      Long backgroundValidationMinutes=dataSourceNode.get(BACKGROUNDVALIDATIONMINUTES).asLong();
      boolean backgroundValidation=dataSourceNode.get(BACKGROUNDVALIDATION).asBoolean();
      boolean useFastFail=dataSourceNode.get(USE_FAST_FAIL).asBoolean();
      boolean validateOnMatch=dataSourceNode.get(VALIDATEONMATCH).asBoolean();
      Validation validation=new ValidationImpl(backgroundValidation,backgroundValidationMinutes,useFastFail,validConnectionCheckerClassName,checkValidConnectionSql,validateOnMatch,staleConnectionCheckerClassName,exceptionSorterClassName);
      XaDataSource ds=new XADataSourceImpl(transactionIsolation,timeOut,security,statement,validation,urlDelimiter,urlSelectorStrategyClassName,useJavaContext,poolName,enabled,jndiName,xaDataSourceProperty,xaDataSourceClass,module,newConnectionSql,xaPool);
      xadatasourceList.add(ds);
    }
  }
  return new DatasourcesImpl(datasourceList,xadatasourceList);
}
