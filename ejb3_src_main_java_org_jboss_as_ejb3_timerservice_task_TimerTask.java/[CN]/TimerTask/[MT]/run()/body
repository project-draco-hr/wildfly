{
  Date now=new Date();
  if (ROOT_LOGGER.isDebugEnabled()) {
    ROOT_LOGGER.debug("Timer task invoked at: " + now + " for timer "+ this.timer);
  }
  if (this.timer.isInRetry()) {
    ROOT_LOGGER.skipInvokeTimeoutDuringRetry(this.timer.getTimedObjectId(),this.timer.getId(),now);
    this.timer.setNextTimeout(calculateNextTimeout());
    this.timerService.persistTimer(this.timer,false);
    scheduleTimeoutIfRequired();
    return;
  }
  if (this.timer.getState() == TimerState.IN_TIMEOUT && !this.timer.isCalendarTimer()) {
    ROOT_LOGGER.skipOverlappingInvokeTimeout(this.timer.getTimedObjectId(),this.timer.getId(),now);
    this.timer.setNextTimeout(this.calculateNextTimeout());
    this.timerService.persistTimer(this.timer,false);
    return;
  }
  if (this.timer.isActive() == false) {
    ROOT_LOGGER.debug("Timer is not active, skipping this scheduled execution at: " + now);
  }
  this.timer.setPreviousRun(new Date());
  Date nextTimeout=this.calculateNextTimeout();
  this.timer.setNextTimeout(nextTimeout);
  this.timer.setTimerState(TimerState.IN_TIMEOUT);
  this.timerService.persistTimer(this.timer,false);
  try {
    this.callTimeout();
  }
 catch (  BeanRemovedException e) {
    ROOT_LOGGER.debugf("Removing timer %s as EJB has been removed ",this.timer);
    timer.cancel();
  }
catch (  Exception e) {
    ROOT_LOGGER.errorInvokeTimeout(this.timer,e);
    try {
      ROOT_LOGGER.timerRetried(this.timer);
      retryTimeout();
    }
 catch (    Exception retryException) {
      ROOT_LOGGER.errorDuringRetryTimeout(timer,retryException);
    }
  }
 finally {
    this.postTimeoutProcessing();
    this.timerService.persistTimer(this.timer,false);
  }
}
