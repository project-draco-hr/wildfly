{
  try {
    TimerImpl timer=timerService.getTimer(timerId);
    if (cancelled) {
      ROOT_LOGGER.debug("Timer task was cancelled for " + timer);
      return;
    }
    Date now=new Date();
    if (ROOT_LOGGER.isDebugEnabled()) {
      ROOT_LOGGER.debug("Timer task invoked at: " + now + " for timer "+ timer);
    }
    if (timer.isInRetry()) {
      ROOT_LOGGER.skipInvokeTimeoutDuringRetry(timer.getTimedObjectId(),timer.getId(),now);
      timer.setNextTimeout(calculateNextTimeout(timer));
      timerService.persistTimer(timer,false);
      scheduleTimeoutIfRequired(timer);
      return;
    }
    if (!timerService.shouldRun(timer)) {
      ROOT_LOGGER.debugf("Skipping execution of timer for %s as it is being run on another node",timer.getTimedObjectId());
      timer.setNextTimeout(calculateNextTimeout(timer));
      scheduleTimeoutIfRequired(timer);
      return;
    }
    if (timer.getState() == TimerState.IN_TIMEOUT && !timer.isCalendarTimer()) {
      ROOT_LOGGER.skipOverlappingInvokeTimeout(timer.getTimedObjectId(),timer.getId(),now);
      timer.setNextTimeout(this.calculateNextTimeout(timer));
      timerService.persistTimer(timer,false);
      return;
    }
    if (timer.isInRetry()) {
      ROOT_LOGGER.debug("Timer in retry mode, skipping this scheduled execution at: " + now);
      timer.setNextTimeout(calculateNextTimeout(timer));
      timerService.persistTimer(timer,false);
      scheduleTimeoutIfRequired(timer);
      return;
    }
    if (timer.getState() == TimerState.IN_TIMEOUT && !timer.isCalendarTimer()) {
      ROOT_LOGGER.skipOverlappingInvokeTimeout(timer.getTimedObjectId(),timer.getId(),now);
      timer.setNextTimeout(this.calculateNextTimeout(timer));
      timerService.persistTimer(timer,false);
      return;
    }
    timer.lock();
    try {
      if (!timer.isActive()) {
        ROOT_LOGGER.debug("Timer is not active, skipping this scheduled execution at: " + now + "for "+ timer);
        return;
      }
      timer.setPreviousRun(new Date());
      Date nextTimeout=this.calculateNextTimeout(timer);
      timer.setNextTimeout(nextTimeout);
      timer.setTimerState(TimerState.IN_TIMEOUT);
      timerService.persistTimer(timer,false);
    }
  finally {
      timer.unlock();
    }
    try {
      this.callTimeout(timer);
    }
 catch (    BeanRemovedException e) {
      ROOT_LOGGER.debugf("Removing timer %s as EJB has been removed ",timer);
      timer.cancel();
    }
catch (    Exception e) {
      ROOT_LOGGER.errorInvokeTimeout(timer,e);
      try {
        ROOT_LOGGER.timerRetried(timer);
        retryTimeout(timer);
      }
 catch (      Exception retryException) {
        ROOT_LOGGER.errorDuringRetryTimeout(timer,retryException);
      }
    }
 finally {
      this.postTimeoutProcessing(timer);
      timerService.persistTimer(timer,false);
    }
  }
 catch (  Exception e) {
    ROOT_LOGGER.exceptionRunningTimerTask(timerId,timedObjectId,e);
  }
}
