{
  final String name=reader.getAttributeValue(0);
  if (name == null) {
    ParseUtils.missingRequired(reader,Collections.singleton("name"));
  }
  final ConnectionFactoryElement cf=new ConnectionFactoryElement(name);
  final Set<String> bindings=new HashSet<String>();
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
    final Element element=Element.forName(reader.getLocalName());
switch (element) {
case DISCOVERY_GROUP_REF:
{
        final String groupRef=reader.getAttributeValue(0);
        if (groupRef != null) {
          cf.setDiscoveryGroupName(groupRef.trim());
        }
        ParseUtils.requireNoContent(reader);
        break;
      }
case DISCOVERY_INITIAL_WAIT_TIMEOUT:
{
      cf.setInitialWaitTimeout(textAsLong(reader));
      break;
    }
case CONNECTORS:
{
    List<ConnectionFactoryConnectorRef> connectors=processConnectors(reader);
    if (!connectors.isEmpty()) {
      cf.setConnectorRef(connectors);
    }
    break;
  }
case ENTRIES:
{
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
    final Element local=Element.forName(reader.getLocalName());
    if (local != Element.ENTRY) {
      throw ParseUtils.unexpectedElement(reader);
    }
    final String entry=reader.getAttributeValue(0);
    bindings.add(entry.trim());
    ParseUtils.requireNoContent(reader);
  }
  break;
}
case CLIENT_FAILURE_CHECK_PERIOD:
{
cf.setClientFailureCheckPeriod(textAsLong(reader));
break;
}
case CONNECTION_TTL:
{
cf.setConnectionTTL(textAsLong(reader));
break;
}
case CALL_TIMEOUT:
{
cf.setCallTimeout(textAsLong(reader));
break;
}
case CONSUMER_WINDOW_SIZE:
{
cf.setConsumerWindowSize(textAsInt(reader));
break;
}
case CONSUMER_MAX_RATE:
{
cf.setConsumerMaxRate(textAsInt(reader));
break;
}
case CONFIRMATION_WINDOW_SIZE:
{
cf.setConfirmationWindowSize(textAsInt(reader));
break;
}
case PRODUCER_WINDOW_SIZE:
{
cf.setProducerWindowSize(textAsInt(reader));
break;
}
case PRODUCER_MAX_RATE:
{
cf.setProducerMaxRate(textAsInt(reader));
break;
}
case CACHE_LARGE_MESSAGE_CLIENT:
{
cf.setCacheLargeMessagesClient(textAsBoolean(reader));
break;
}
case MIN_LARGE_MESSAGE_SIZE:
{
cf.setMinLargeMessageSize(textAsInt(reader));
break;
}
case CLIENT_ID:
{
cf.setClientID(elementText(reader));
break;
}
case DUPS_OK_BATCH_SIZE:
{
cf.setDupsOKBatchSize(textAsInt(reader));
break;
}
case TRANSACTION_BATH_SIZE:
{
cf.setTransactionBatchSize(textAsInt(reader));
break;
}
case BLOCK_ON_ACK:
{
cf.setBlockOnAcknowledge(textAsBoolean(reader));
break;
}
case BLOCK_ON_NON_DURABLE_SEND:
{
cf.setBlockOnNonDurableSend(textAsBoolean(reader));
break;
}
case BLOCK_ON_DURABLE_SEND:
{
cf.setBlockOnDurableSend(textAsBoolean(reader));
break;
}
case AUTO_GROUP:
{
cf.setAutoGroup(textAsBoolean(reader));
break;
}
case PRE_ACK:
{
cf.setPreAcknowledge(textAsBoolean(reader));
break;
}
case RETRY_INTERVAL:
{
cf.setRetryInterval(textAsLong(reader));
break;
}
case RETRY_INTERVAL_MULTIPLIER:
{
cf.setRetryIntervalMultiplier(Double.valueOf(elementText(reader)));
break;
}
case MAX_RETRY_INTERVAL:
{
cf.setMaxRetryInterval(textAsLong(reader));
break;
}
case RECONNECT_ATTEMPTS:
{
cf.setReconnectAttempts(textAsInt(reader));
break;
}
case FAILOVER_ON_INITIAL_CONNECTION:
{
cf.setFailoverOnInitialConnection(textAsBoolean(reader));
break;
}
case FAILOVER_ON_SERVER_SHUTDOWN:
{
cf.setFailoverOnServerShutdown(textAsBoolean(reader));
break;
}
case LOAD_BALANCING_CLASS_NAME:
{
cf.setLoadBalancingPolicyClassName(elementText(reader));
break;
}
case USE_GLOBAL_POOLS:
{
cf.setUseGlobalPools(textAsBoolean(reader));
break;
}
case SCHEDULED_THREAD_POOL_MAX_SIZE:
{
cf.setScheduledThreadPoolMaxSize(textAsInt(reader));
break;
}
case THREAD_POOL_MAX_SIZE:
{
cf.setThreadPoolMaxSize(textAsInt(reader));
break;
}
case GROUP_ID:
{
cf.setGroupID(elementText(reader));
break;
}
default :
{
throw ParseUtils.unexpectedElement(reader);
}
}
}
cf.setBindings(bindings);
updates.add(new ConnectionFactoryAdd(cf));
}
