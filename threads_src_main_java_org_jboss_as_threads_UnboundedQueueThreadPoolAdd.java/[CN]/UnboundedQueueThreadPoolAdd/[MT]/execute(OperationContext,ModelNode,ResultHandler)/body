{
  BaseOperationParameters params=ThreadsSubsystemThreadPoolOperationUtils.parseUnboundedQueueThreadPoolOperationParameters(operation);
  final ModelNode model=context.getSubModel();
  model.get(NAME).set(params.getName());
  if (params.getThreadFactory() != null) {
    model.get(THREAD_FACTORY).set(params.getThreadFactory());
  }
  if (params.getProperties() != null && params.getProperties().asList().size() > 0) {
    model.get(PROPERTIES).set(params.getProperties());
  }
  if (params.getMaxThreads() != null) {
    model.get(MAX_THREADS).set(operation.get(MAX_THREADS));
  }
  if (params.getKeepAliveTime() != null) {
    model.get(KEEPALIVE_TIME).set(operation.get(KEEPALIVE_TIME));
  }
  if (context instanceof RuntimeOperationContext) {
    ServiceTarget target=((RuntimeOperationContext)context).getServiceTarget();
    final ServiceName serviceName=ThreadsServices.executorName(params.getName());
    final UnboundedQueueThreadPoolService service=new UnboundedQueueThreadPoolService(params.getMaxThreads().getScaledCount(),params.getKeepAliveTime());
    final ServiceBuilder<ExecutorService> serviceBuilder=target.addService(serviceName,service);
    ThreadsSubsystemThreadPoolOperationUtils.addThreadFactoryDependency(params.getThreadFactory(),serviceName,serviceBuilder,service.getThreadFactoryInjector(),target);
    serviceBuilder.install();
  }
  final ModelNode compensating=Util.getResourceRemoveOperation(params.getAddress());
  resultHandler.handleResultComplete(compensating);
  return Cancellable.NULL;
}
