{
  final Element element=Element.forName(property.getName());
switch (element) {
case LINK_LOCAL_ADDRESS:
    return LinkLocalInterfaceCriteria.INSTANCE;
case LOOPBACK:
  return LoopbackInterfaceCriteria.INSTANCE;
case MULTICAST:
return SupportsMulticastInterfaceCriteria.INSTANCE;
case POINT_TO_POINT:
return PointToPointInterfaceCriteria.INSTANCE;
case PUBLIC_ADDRESS:
return PublicAddressInterfaceCriteria.INSTANCE;
case SITE_LOCAL_ADDRESS:
return SiteLocalInterfaceCriteria.INSTANCE;
case UP:
return UpInterfaceCriteria.INSTANCE;
case VIRTUAL:
return VirtualInterfaceCriteria.INSTANCE;
case INET_ADDRESS:
{
ModelNode value=parsePossibleExpression(property.getValue());
checkStringType(value,element.getLocalName(),true);
return createInetAddressCriteria(value,expressionResolver);
}
case LOOPBACK_ADDRESS:
{
ModelNode value=parsePossibleExpression(property.getValue());
checkStringType(value,element.getLocalName(),true);
return new LoopbackAddressInterfaceCriteria(parseInetAddress(value,expressionResolver));
}
case NIC:
{
ModelNode value=parsePossibleExpression(property.getValue());
checkStringType(property.getValue(),element.getLocalName());
return new NicInterfaceCriteria(expressionResolver.resolveExpressions(value).asString());
}
case NIC_MATCH:
{
ModelNode value=parsePossibleExpression(property.getValue());
checkStringType(property.getValue(),element.getLocalName());
return createNicMatchCriteria(expressionResolver.resolveExpressions(value));
}
case SUBNET_MATCH:
{
ModelNode value=parsePossibleExpression(property.getValue());
return createSubnetMatchCriteria(expressionResolver.resolveExpressions(value));
}
case ANY:
case NOT:
if (nested) {
throw new ParsingException(ControllerLogger.ROOT_LOGGER.nestedElementNotAllowed(element));
}
return parseNested(property.getValue(),element == Element.ANY,expressionResolver);
default :
throw new ParsingException(ControllerLogger.ROOT_LOGGER.unknownCriteriaInterfaceType(property.getName()));
}
}
