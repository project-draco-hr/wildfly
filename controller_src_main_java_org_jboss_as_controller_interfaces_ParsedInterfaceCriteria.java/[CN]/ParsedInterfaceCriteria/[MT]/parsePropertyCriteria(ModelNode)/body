{
  Property prop=node.asProperty();
  String propName=prop.getName();
  final Element element=Element.forName(propName);
switch (element) {
case ANY:
{
      return parseCompoundCriteria(prop.getValue(),true);
    }
case NOT:
{
    return parseCompoundCriteria(prop.getValue(),true);
  }
case INET_ADDRESS:
{
  checkStringType(prop.getValue(),element.getLocalName(),true);
  return new InetAddressMatchInterfaceCriteria(prop.getValue());
}
case LOOPBACK_ADDRESS:
{
checkStringType(prop.getValue(),element.getLocalName(),true);
return new LoopbackAddressInterfaceCriteria(prop.getValue());
}
case NIC:
{
checkStringType(prop.getValue(),element.getLocalName());
return new NicInterfaceCriteria(prop.getValue().asString());
}
case NIC_MATCH:
{
checkStringType(prop.getValue(),element.getLocalName());
try {
Pattern pattern=Pattern.compile(prop.getValue().asString());
return new NicMatchInterfaceCriteria(pattern);
}
 catch (PatternSyntaxException e) {
throw new ParsingException(String.format("Invalid pattern %s for interface criteria %s",prop.getValue().asString(),element.getLocalName()));
}
}
case SUBNET_MATCH:
{
String value;
String[] split=null;
try {
value=prop.getValue().asString();
split=value.split("/");
if (split.length != 2) {
throw new ParsingException(String.format("Invalid 'value' %s -- must be of the form address/mask",value));
}
final InetAddress addr=InetAddress.getByName(split[0]);
final byte[] net=addr.getAddress();
final int mask=Integer.parseInt(split[1]);
return new SubnetMatchInterfaceCriteria(net,mask);
}
 catch (final ParsingException e) {
throw e;
}
catch (final NumberFormatException e) {
throw new ParsingException(String.format("Invalid mask %s (%s)",split[0],e.getLocalizedMessage()));
}
catch (final UnknownHostException e) {
throw new ParsingException(String.format("Invalid address %s (%s)",split[1],e.getLocalizedMessage()));
}
}
default :
throw new ParsingException("Unknown complex interface criteria type " + node.asString());
}
}
