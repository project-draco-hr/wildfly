{
  final Element element=Element.forName(property.getName());
switch (element) {
case LINK_LOCAL_ADDRESS:
    return LinkLocalInterfaceCriteria.INSTANCE;
case LOOPBACK:
  return LoopbackInterfaceCriteria.INSTANCE;
case MULTICAST:
return SupportsMulticastInterfaceCriteria.INSTANCE;
case POINT_TO_POINT:
return PointToPointInterfaceCriteria.INSTANCE;
case PUBLIC_ADDRESS:
return PublicAddressInterfaceCriteria.INSTANCE;
case SITE_LOCAL_ADDRESS:
return SiteLocalInterfaceCriteria.INSTANCE;
case UP:
return UpInterfaceCriteria.INSTANCE;
case VIRTUAL:
return VirtualInterfaceCriteria.INSTANCE;
case INET_ADDRESS:
{
ModelNode value=property.getValue();
value=parsePossibleExpression(value);
checkStringType(value,element.getLocalName(),true);
return createInetAddressCriteria(property.getValue());
}
case LOOPBACK_ADDRESS:
{
ModelNode value=property.getValue();
value=parsePossibleExpression(value);
checkStringType(value,element.getLocalName(),true);
return new LoopbackAddressInterfaceCriteria(property.getValue());
}
case NIC:
{
checkStringType(property.getValue(),element.getLocalName());
return new NicInterfaceCriteria(property.getValue().asString());
}
case NIC_MATCH:
{
checkStringType(property.getValue(),element.getLocalName());
return createNicMatchCriteria(property.getValue());
}
case SUBNET_MATCH:
{
return createSubnetMatchCriteria(property.getValue());
}
case ANY:
case NOT:
if (nested) {
throw new ParsingException(MESSAGES.nestedElementNotAllowed(element));
}
final ModelNode subModel=property.getValue().get(element.getLocalName());
return parseNested(subModel,element == Element.ANY);
default :
throw new ParsingException(MESSAGES.unknownCriteriaInterfaceType(property.getName()));
}
}
