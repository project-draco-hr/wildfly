{
  final String localHostName=domainOperationContext.getLocalHostInfo().getLocalHostName();
  Map<String,ModelNode> hostResults=new HashMap<String,ModelNode>(domainOperationContext.getHostControllerResults());
  if (domainOperationContext.getCoordinatorResult().isDefined()) {
    hostResults.put(localHostName,domainOperationContext.getCoordinatorResult());
  }
  Map<String,Map<ServerIdentity,ModelNode>> opsByGroup=getOpsByGroup(hostResults);
  if (opsByGroup.size() > 0) {
    final ModelNode rolloutPlan=getRolloutPlan(this.providedRolloutPlan,opsByGroup);
    if (trace) {
      HOST_CONTROLLER_LOGGER.tracef("Rollout plan is %s",rolloutPlan);
    }
    final NewServerOperationExecutor operationExecutor=new NewServerOperationExecutor(){
      @Override public ModelNode executeServerOperation(      ServerIdentity server,      ModelNode operation){
        ProxyController proxy=hostProxies.get(server.getHostName());
        if (proxy == null) {
          if (localHostName.equals(server.getHostName())) {
            proxy=serverProxies.get(server.getServerName());
            if (proxy == null) {
              if (trace) {
                HOST_CONTROLLER_LOGGER.tracef("No proxy for %s",server);
              }
              return null;
            }
          }
        }
        ProxyTask task=new ProxyTask(server.getHostName(),operation,context,proxy);
        tasks.put(server,task);
        boolean interrupted=false;
        Future<ModelNode> future=null;
        ModelNode result=null;
        try {
          future=executorService.submit(task);
          result=task.getUncommittedResult();
          futures.put(server,future);
        }
 catch (        Exception e) {
          result=new ModelNode();
          result.get(OUTCOME).set(FAILED);
          if (e instanceof InterruptedException) {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromServer(server));
            interrupted=true;
          }
 else {
            result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromServer(server,e.getMessage()));
          }
          task.cancel();
          future.cancel(true);
        }
 finally {
          if (interrupted) {
            Thread.currentThread().interrupt();
          }
        }
        return result;
      }
    }
;
    NewRolloutPlanController rolloutPlanController=new NewRolloutPlanController(opsByGroup,rolloutPlan,domainOperationContext,operationExecutor,executorService);
    NewRolloutPlanController.Result planResult=rolloutPlanController.execute();
    if (trace) {
      HOST_CONTROLLER_LOGGER.tracef("Rollout plan result is %s",planResult);
    }
    if (planResult == NewRolloutPlanController.Result.FAILED) {
      domainOperationContext.setCompleteRollback(true);
      context.getResult();
      context.getFailureDescription().set(MESSAGES.operationFailedOrRolledBack());
      domainOperationContext.setFailureReported(true);
    }
  }
}
