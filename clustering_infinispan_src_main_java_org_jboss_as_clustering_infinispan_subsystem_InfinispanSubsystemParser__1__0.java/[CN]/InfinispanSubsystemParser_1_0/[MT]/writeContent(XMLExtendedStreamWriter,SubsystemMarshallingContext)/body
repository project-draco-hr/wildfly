{
  context.startSubsystemElement(Namespace.CURRENT.getUri(),false);
  ModelNode model=context.getModelNode();
  if (model.isDefined()) {
    writer.writeAttribute(Attribute.DEFAULT_CACHE_CONTAINER.getLocalName(),model.require(ModelKeys.DEFAULT_CACHE_CONTAINER).asString());
    for (    Property entry : model.get(ModelKeys.CACHE_CONTAINER).asPropertyList()) {
      writer.writeStartElement(Element.CACHE_CONTAINER.getLocalName());
      writer.writeAttribute(Attribute.NAME.getLocalName(),entry.getName());
      ModelNode container=entry.getValue();
      this.writeRequired(writer,Attribute.DEFAULT_CACHE,container,ModelKeys.DEFAULT_CACHE);
      this.writeOptional(writer,Attribute.JNDI_NAME,container,ModelKeys.JNDI_NAME);
      this.writeOptional(writer,Attribute.LISTENER_EXECUTOR,container,ModelKeys.LISTENER_EXECUTOR);
      this.writeOptional(writer,Attribute.EVICTION_EXECUTOR,container,ModelKeys.EVICTION_EXECUTOR);
      this.writeOptional(writer,Attribute.REPLICATION_QUEUE_EXECUTOR,container,ModelKeys.REPLICATION_QUEUE_EXECUTOR);
      if (container.hasDefined(ModelKeys.ALIAS)) {
        for (        ModelNode alias : container.get(ModelKeys.ALIAS).asList()) {
          writer.writeStartElement(Element.ALIAS.getLocalName());
          writer.writeCharacters(alias.asString());
          writer.writeEndElement();
        }
      }
      if (container.hasDefined(ModelKeys.TRANSPORT)) {
        writer.writeStartElement(Element.TRANSPORT.getLocalName());
        ModelNode transport=container.get(ModelKeys.TRANSPORT);
        this.writeOptional(writer,Attribute.STACK,transport,ModelKeys.STACK);
        this.writeOptional(writer,Attribute.EXECUTOR,transport,ModelKeys.EXECUTOR);
        this.writeOptional(writer,Attribute.LOCK_TIMEOUT,transport,ModelKeys.LOCK_TIMEOUT);
        this.writeOptional(writer,Attribute.SITE,transport,ModelKeys.SITE);
        this.writeOptional(writer,Attribute.RACK,transport,ModelKeys.RACK);
        this.writeOptional(writer,Attribute.MACHINE,transport,ModelKeys.MACHINE);
        writer.writeEndElement();
      }
      for (      ModelNode cache : container.get(ModelKeys.CACHE).asList()) {
        Configuration.CacheMode mode=Configuration.CacheMode.valueOf(cache.get(ModelKeys.MODE).asString());
        if (mode.isClustered()) {
          if (mode.isDistributed()) {
            writer.writeStartElement(Element.DISTRIBUTED_CACHE.getLocalName());
            this.writeOptional(writer,Attribute.OWNERS,cache,ModelKeys.OWNERS);
            this.writeOptional(writer,Attribute.VIRTUAL_NODES,cache,ModelKeys.VIRTUAL_NODES);
            this.writeOptional(writer,Attribute.L1_LIFESPAN,cache,ModelKeys.L1_LIFESPAN);
          }
 else           if (mode.isInvalidation()) {
            writer.writeStartElement(Element.INVALIDATION_CACHE.getLocalName());
          }
 else {
            writer.writeStartElement(Element.REPLICATED_CACHE.getLocalName());
          }
          writer.writeAttribute(Attribute.MODE.getLocalName(),Mode.forCacheMode(mode).name());
          this.writeOptional(writer,Attribute.QUEUE_SIZE,cache,ModelKeys.QUEUE_SIZE);
          this.writeOptional(writer,Attribute.QUEUE_FLUSH_INTERVAL,cache,ModelKeys.QUEUE_FLUSH_INTERVAL);
          this.writeOptional(writer,Attribute.REMOTE_TIMEOUT,cache,ModelKeys.REMOTE_TIMEOUT);
        }
 else {
          writer.writeStartElement(Element.LOCAL_CACHE.getLocalName());
        }
        this.writeRequired(writer,Attribute.NAME,cache,ModelKeys.NAME);
        this.writeOptional(writer,Attribute.START,cache,ModelKeys.START);
        this.writeOptional(writer,Attribute.BATCHING,cache,ModelKeys.BATCHING);
        this.writeOptional(writer,Attribute.INDEXING,cache,ModelKeys.INDEXING);
        if (cache.hasDefined(ModelKeys.LOCKING)) {
          writer.writeStartElement(Element.LOCKING.getLocalName());
          ModelNode locking=cache.get(ModelKeys.LOCKING);
          this.writeOptional(writer,Attribute.ISOLATION,locking,ModelKeys.ISOLATION);
          this.writeOptional(writer,Attribute.STRIPING,locking,ModelKeys.STRIPING);
          this.writeOptional(writer,Attribute.ACQUIRE_TIMEOUT,locking,ModelKeys.ACQUIRE_TIMEOUT);
          this.writeOptional(writer,Attribute.CONCURRENCY_LEVEL,locking,ModelKeys.CONCURRENCY_LEVEL);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.TRANSACTION)) {
          writer.writeStartElement(Element.TRANSACTION.getLocalName());
          ModelNode transaction=cache.get(ModelKeys.TRANSACTION);
          this.writeOptional(writer,Attribute.STOP_TIMEOUT,transaction,ModelKeys.STOP_TIMEOUT);
          this.writeOptional(writer,Attribute.MODE,transaction,ModelKeys.MODE);
          this.writeOptional(writer,Attribute.LOCKING,transaction,ModelKeys.LOCKING);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.EVICTION)) {
          writer.writeStartElement(Element.EVICTION.getLocalName());
          ModelNode eviction=cache.get(ModelKeys.EVICTION);
          this.writeOptional(writer,Attribute.STRATEGY,eviction,ModelKeys.STRATEGY);
          this.writeOptional(writer,Attribute.MAX_ENTRIES,eviction,ModelKeys.MAX_ENTRIES);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.EXPIRATION)) {
          writer.writeStartElement(Element.EXPIRATION.getLocalName());
          ModelNode expiration=cache.get(ModelKeys.EXPIRATION);
          this.writeOptional(writer,Attribute.MAX_IDLE,expiration,ModelKeys.MAX_IDLE);
          this.writeOptional(writer,Attribute.LIFESPAN,expiration,ModelKeys.LIFESPAN);
          this.writeOptional(writer,Attribute.INTERVAL,expiration,ModelKeys.INTERVAL);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.STORE)) {
          ModelNode store=cache.get(ModelKeys.STORE);
          writer.writeStartElement(Element.STORE.getLocalName());
          this.writeRequired(writer,Attribute.CLASS,store,ModelKeys.CLASS);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.FILE_STORE)) {
          ModelNode store=cache.get(ModelKeys.FILE_STORE);
          writer.writeStartElement(Element.FILE_STORE.getLocalName());
          this.writeOptional(writer,Attribute.RELATIVE_TO,store,ModelKeys.RELATIVE_TO);
          this.writeOptional(writer,Attribute.PATH,store,ModelKeys.PATH);
          this.writeStoreAttributes(writer,store);
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.JDBC_STORE)) {
          ModelNode store=cache.get(ModelKeys.JDBC_STORE);
          writer.writeStartElement(Element.JDBC_STORE.getLocalName());
          this.writeRequired(writer,Attribute.DATASOURCE,store,ModelKeys.DATASOURCE);
          this.writeStoreAttributes(writer,store);
          this.writeJDBCStoreTable(writer,Element.ENTRY_TABLE,store,ModelKeys.ENTRY_TABLE);
          this.writeJDBCStoreTable(writer,Element.BUCKET_TABLE,store,ModelKeys.BUCKET_TABLE);
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.REMOTE_STORE)) {
          ModelNode store=cache.get(ModelKeys.REMOTE_STORE);
          writer.writeStartElement(Element.REMOTE_STORE.getLocalName());
          this.writeOptional(writer,Attribute.CACHE,store,ModelKeys.CACHE);
          this.writeOptional(writer,Attribute.SOCKET_TIMEOUT,store,ModelKeys.SOCKET_TIMEOUT);
          this.writeOptional(writer,Attribute.TCP_NO_DELAY,store,ModelKeys.TCP_NO_DELAY);
          this.writeStoreAttributes(writer,store);
          for (          ModelNode remoteServer : store.get(ModelKeys.REMOTE_SERVER).asList()) {
            writer.writeStartElement(Element.REMOTE_SERVER.getLocalName());
            writer.writeAttribute(Attribute.OUTBOUND_SOCKET_BINDING.getLocalName(),remoteServer.get(ModelKeys.OUTBOUND_SOCKET_BINDING).asString());
            writer.writeEndElement();
          }
          this.writeStoreProperties(writer,store);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.STATE_TRANSFER)) {
          ModelNode stateTransfer=cache.get(ModelKeys.STATE_TRANSFER);
          writer.writeStartElement(Element.STATE_TRANSFER.getLocalName());
          this.writeOptional(writer,Attribute.ENABLED,stateTransfer,ModelKeys.ENABLED);
          this.writeOptional(writer,Attribute.TIMEOUT,stateTransfer,ModelKeys.TIMEOUT);
          this.writeOptional(writer,Attribute.FLUSH_TIMEOUT,stateTransfer,ModelKeys.FLUSH_TIMEOUT);
          writer.writeEndElement();
        }
        if (cache.hasDefined(ModelKeys.REHASHING)) {
          ModelNode rehashing=cache.get(ModelKeys.REHASHING);
          writer.writeStartElement(Element.REHASHING.getLocalName());
          this.writeOptional(writer,Attribute.ENABLED,rehashing,ModelKeys.ENABLED);
          this.writeOptional(writer,Attribute.TIMEOUT,rehashing,ModelKeys.TIMEOUT);
          writer.writeEndElement();
        }
        writer.writeEndElement();
      }
      writer.writeEndElement();
    }
  }
  writer.writeEndElement();
}
