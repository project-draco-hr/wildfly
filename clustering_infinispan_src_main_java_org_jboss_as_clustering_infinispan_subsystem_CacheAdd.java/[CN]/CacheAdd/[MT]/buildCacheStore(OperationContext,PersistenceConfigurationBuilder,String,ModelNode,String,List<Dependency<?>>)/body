{
  ModelNode resolvedValue=null;
  if (storeKey.equals(ModelKeys.FILE_STORE)) {
    final SingleFileStoreConfigurationBuilder builder=persistenceBuilder.addSingleFileStore();
    final String path=((resolvedValue=FileStoreResourceDefinition.PATH.resolveModelAttribute(context,store)).isDefined()) ? resolvedValue.asString() : InfinispanExtension.SUBSYSTEM_NAME + File.separatorChar + containerName;
    final String relativeTo=((resolvedValue=FileStoreResourceDefinition.RELATIVE_TO.resolveModelAttribute(context,store)).isDefined()) ? resolvedValue.asString() : ServerEnvironment.SERVER_DATA_DIR;
    Injector<PathManager> injector=new SimpleInjector<PathManager>(){
      private volatile PathManager.Callback.Handle callbackHandle;
      @Override public void inject(      PathManager value){
        this.callbackHandle=value.registerCallback(relativeTo,PathManager.ReloadServerCallback.create(),PathManager.Event.UPDATED,PathManager.Event.REMOVED);
        builder.location(value.resolveRelativePathEntry(path,relativeTo));
      }
      @Override public void uninject(){
        super.uninject();
        if (this.callbackHandle != null) {
          this.callbackHandle.remove();
        }
      }
    }
;
    dependencies.add(new Dependency<>(PathManagerService.SERVICE_NAME,PathManager.class,injector));
    return builder;
  }
 else   if (storeKey.equals(ModelKeys.STRING_KEYED_JDBC_STORE) || storeKey.equals(ModelKeys.BINARY_KEYED_JDBC_STORE) || storeKey.equals(ModelKeys.MIXED_KEYED_JDBC_STORE)) {
    AbstractJdbcStoreConfigurationBuilder<?,?> builder=buildJdbcStore(persistenceBuilder,context,store);
    String datasource=JDBCStoreResourceDefinition.DATA_SOURCE.resolveModelAttribute(context,store).asString();
    dependencies.add(new Dependency<>(ServiceName.JBOSS.append("data-source",datasource)));
    builder.dataSource().jndiUrl(datasource);
    return builder;
  }
 else   if (storeKey.equals(ModelKeys.REMOTE_STORE)) {
    final RemoteStoreConfigurationBuilder builder=persistenceBuilder.addStore(RemoteStoreConfigurationBuilder.class);
    for (    ModelNode server : store.require(ModelKeys.REMOTE_SERVERS).asList()) {
      String outboundSocketBinding=server.get(ModelKeys.OUTBOUND_SOCKET_BINDING).asString();
      Injector<OutboundSocketBinding> injector=new SimpleInjector<OutboundSocketBinding>(){
        @Override public void inject(        OutboundSocketBinding value){
          try {
            builder.addServer().host(value.getDestinationAddress().getHostAddress()).port(value.getDestinationPort());
          }
 catch (          UnknownHostException e) {
            throw InfinispanMessages.MESSAGES.failedToInjectSocketBinding(e,value);
          }
        }
      }
;
      dependencies.add(new Dependency<>(OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBinding),OutboundSocketBinding.class,injector));
    }
    if (store.hasDefined(ModelKeys.CACHE)) {
      builder.remoteCacheName(store.get(ModelKeys.CACHE).asString());
    }
    if (store.hasDefined(ModelKeys.SOCKET_TIMEOUT)) {
      builder.socketTimeout(store.require(ModelKeys.SOCKET_TIMEOUT).asLong());
    }
    if (store.hasDefined(ModelKeys.TCP_NO_DELAY)) {
      builder.tcpNoDelay(store.require(ModelKeys.TCP_NO_DELAY).asBoolean());
    }
    return builder;
  }
 else {
    String className=store.require(ModelKeys.CLASS).asString();
    try {
      return persistenceBuilder.addStore(StoreConfigurationBuilder.class.getClassLoader().loadClass(className).asSubclass(StoreConfigurationBuilder.class));
    }
 catch (    Exception e) {
      throw InfinispanMessages.MESSAGES.invalidCacheStore(e,className);
    }
  }
}
