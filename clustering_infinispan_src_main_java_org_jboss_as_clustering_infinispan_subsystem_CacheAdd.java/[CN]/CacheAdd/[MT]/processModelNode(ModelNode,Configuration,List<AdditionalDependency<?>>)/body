{
  String cacheName=cache.require(ModelKeys.NAME).asString();
  configuration.setClassLoader(this.getClass().getClassLoader());
  FluentConfiguration fluent=configuration.fluent();
  Configuration.CacheMode mode=Configuration.CacheMode.valueOf(cache.require(ModelKeys.CACHE_MODE).asString());
  fluent.mode(mode);
  if (cache.hasDefined(ModelKeys.BATCHING)) {
    if (cache.get(ModelKeys.BATCHING).asBoolean()) {
      fluent.invocationBatching();
    }
  }
  if (cache.hasDefined(ModelKeys.INDEXING)) {
    Indexing indexing=Indexing.valueOf(cache.get(ModelKeys.INDEXING).asString());
    if (indexing.isEnabled()) {
      fluent.indexing().indexLocalOnly(indexing.isLocalOnly());
    }
  }
  if (cache.hasDefined(ModelKeys.QUEUE_SIZE)) {
    fluent.async().replQueueMaxElements(cache.get(ModelKeys.QUEUE_SIZE).asInt());
  }
  if (cache.hasDefined(ModelKeys.QUEUE_FLUSH_INTERVAL)) {
    fluent.async().replQueueInterval(cache.get(ModelKeys.QUEUE_FLUSH_INTERVAL).asLong());
  }
  if (cache.hasDefined(ModelKeys.REMOTE_TIMEOUT)) {
    fluent.sync().replTimeout(cache.get(ModelKeys.REMOTE_TIMEOUT).asLong());
  }
  if (cache.hasDefined(ModelKeys.OWNERS)) {
    fluent.hash().numOwners(cache.get(ModelKeys.OWNERS).asInt());
  }
  if (cache.hasDefined(ModelKeys.VIRTUAL_NODES)) {
    fluent.hash().numVirtualNodes(cache.get(ModelKeys.VIRTUAL_NODES).asInt());
  }
  if (cache.hasDefined(ModelKeys.L1_LIFESPAN)) {
    long lifespan=cache.get(ModelKeys.L1_LIFESPAN).asLong();
    if (lifespan > 0) {
      fluent.l1().lifespan(lifespan);
    }
 else {
      fluent.l1().disable();
    }
  }
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.LOCKING).isDefined()) {
    ModelNode locking=cache.get(ModelKeys.SINGLETON,ModelKeys.LOCKING);
    FluentConfiguration.LockingConfig fluentLocking=fluent.locking();
    if (locking.hasDefined(ModelKeys.ISOLATION)) {
      fluentLocking.isolationLevel(IsolationLevel.valueOf(locking.get(ModelKeys.ISOLATION).asString()));
    }
    if (locking.hasDefined(ModelKeys.STRIPING)) {
      fluentLocking.useLockStriping(locking.get(ModelKeys.STRIPING).asBoolean());
    }
    if (locking.hasDefined(ModelKeys.ACQUIRE_TIMEOUT)) {
      fluentLocking.lockAcquisitionTimeout(locking.get(ModelKeys.ACQUIRE_TIMEOUT).asLong());
    }
    if (locking.hasDefined(ModelKeys.CONCURRENCY_LEVEL)) {
      fluentLocking.concurrencyLevel(locking.get(ModelKeys.CONCURRENCY_LEVEL).asInt());
    }
  }
  FluentConfiguration.TransactionConfig fluentTx=fluent.transaction();
  TransactionMode txMode=TransactionMode.NON_XA;
  LockingMode lockingMode=LockingMode.OPTIMISTIC;
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.TRANSACTION).isDefined()) {
    ModelNode transaction=cache.get(ModelKeys.SINGLETON,ModelKeys.TRANSACTION);
    if (transaction.hasDefined(ModelKeys.STOP_TIMEOUT)) {
      fluentTx.cacheStopTimeout(transaction.get(ModelKeys.STOP_TIMEOUT).asInt());
    }
    if (transaction.hasDefined(ModelKeys.MODE)) {
      txMode=TransactionMode.valueOf(transaction.get(ModelKeys.MODE).asString());
    }
    if (transaction.hasDefined(ModelKeys.LOCKING)) {
      lockingMode=LockingMode.valueOf(transaction.get(ModelKeys.LOCKING).asString());
    }
  }
  fluentTx.transactionMode(txMode.getMode());
  fluentTx.lockingMode(lockingMode);
  FluentConfiguration.RecoveryConfig recovery=fluentTx.useSynchronization(!txMode.isXAEnabled()).recovery();
  if (txMode.isRecoveryEnabled()) {
    recovery.syncCommitPhase(true).syncRollbackPhase(true);
  }
 else {
    recovery.disable();
  }
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.EVICTION).isDefined()) {
    ModelNode eviction=cache.get(ModelKeys.SINGLETON,ModelKeys.EVICTION);
    FluentConfiguration.EvictionConfig fluentEviction=fluent.eviction();
    if (eviction.hasDefined(ModelKeys.STRATEGY)) {
      fluentEviction.strategy(EvictionStrategy.valueOf(eviction.get(ModelKeys.STRATEGY).asString()));
    }
    if (eviction.hasDefined(ModelKeys.MAX_ENTRIES)) {
      fluentEviction.maxEntries(eviction.get(ModelKeys.MAX_ENTRIES).asInt());
    }
  }
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.EXPIRATION).isDefined()) {
    ModelNode expiration=cache.get(ModelKeys.SINGLETON,ModelKeys.EXPIRATION);
    FluentConfiguration.ExpirationConfig fluentExpiration=fluent.expiration();
    if (expiration.hasDefined(ModelKeys.MAX_IDLE)) {
      fluentExpiration.maxIdle(expiration.get(ModelKeys.MAX_IDLE).asLong());
    }
    if (expiration.hasDefined(ModelKeys.LIFESPAN)) {
      fluentExpiration.lifespan(expiration.get(ModelKeys.LIFESPAN).asLong());
    }
    if (expiration.hasDefined(ModelKeys.INTERVAL)) {
      fluentExpiration.wakeUpInterval(expiration.get(ModelKeys.INTERVAL).asLong());
    }
  }
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.STATE_TRANSFER).isDefined()) {
    ModelNode stateTransfer=cache.get(ModelKeys.SINGLETON,ModelKeys.STATE_TRANSFER);
    FluentConfiguration.StateRetrievalConfig fluentStateTransfer=fluent.stateRetrieval();
    if (stateTransfer.hasDefined(ModelKeys.ENABLED)) {
      fluentStateTransfer.fetchInMemoryState(stateTransfer.get(ModelKeys.ENABLED).asBoolean());
    }
    if (stateTransfer.hasDefined(ModelKeys.TIMEOUT)) {
      fluentStateTransfer.timeout(stateTransfer.get(ModelKeys.TIMEOUT).asLong());
    }
    if (stateTransfer.hasDefined(ModelKeys.FLUSH_TIMEOUT)) {
      fluentStateTransfer.logFlushTimeout(stateTransfer.get(ModelKeys.FLUSH_TIMEOUT).asLong());
    }
  }
  if (cache.hasDefined(ModelKeys.SINGLETON) && cache.get(ModelKeys.SINGLETON,ModelKeys.REHASHING).isDefined()) {
    ModelNode rehashing=cache.get(ModelKeys.SINGLETON,ModelKeys.REHASHING);
    FluentConfiguration.HashConfig fluentHash=fluent.hash();
    if (rehashing.hasDefined(ModelKeys.ENABLED)) {
      fluentHash.rehashEnabled(rehashing.get(ModelKeys.ENABLED).asBoolean());
    }
    if (rehashing.hasDefined(ModelKeys.TIMEOUT)) {
      fluentHash.rehashRpcTimeout(rehashing.get(ModelKeys.TIMEOUT).asLong());
    }
  }
  String storeKey=this.findStoreKey(cache);
  if (storeKey != null) {
    ModelNode store=cache.get(storeKey);
    FluentConfiguration.LoadersConfig fluentStores=fluent.loaders();
    fluentStores.shared(store.hasDefined(ModelKeys.SHARED) ? store.get(ModelKeys.SHARED).asBoolean() : false);
    fluentStores.preload(store.hasDefined(ModelKeys.PRELOAD) ? store.get(ModelKeys.PRELOAD).asBoolean() : false);
    fluentStores.passivation(store.hasDefined(ModelKeys.PASSIVATION) ? store.get(ModelKeys.PASSIVATION).asBoolean() : true);
    CacheStoreConfig storeConfig=buildCacheStore(cacheName,store,storeKey,additionalDeps);
    storeConfig.singletonStore().enabled(store.hasDefined(ModelKeys.SINGLETON) ? store.get(ModelKeys.SINGLETON).asBoolean() : false);
    storeConfig.fetchPersistentState(store.hasDefined(ModelKeys.FETCH_STATE) ? store.get(ModelKeys.FETCH_STATE).asBoolean() : true);
    storeConfig.purgeOnStartup(store.hasDefined(ModelKeys.PURGE) ? store.get(ModelKeys.PURGE).asBoolean() : true);
    fluentStores.addCacheLoader(storeConfig);
  }
}
