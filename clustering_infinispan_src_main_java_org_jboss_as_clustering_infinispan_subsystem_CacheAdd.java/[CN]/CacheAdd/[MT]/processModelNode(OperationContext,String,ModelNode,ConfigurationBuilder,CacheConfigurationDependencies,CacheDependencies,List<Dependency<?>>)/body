{
  builder.jmxStatistics().enabled(CacheResourceDefinition.STATISTICS_ENABLED.resolveModelAttribute(context,cache).asBoolean());
  final Indexing indexing=Indexing.valueOf(CacheResourceDefinition.INDEXING.resolveModelAttribute(context,cache).asString());
  final boolean batching=CacheResourceDefinition.BATCHING.resolveModelAttribute(context,cache).asBoolean();
  builder.clustering().cacheMode(this.mode);
  final ModelNode indexingPropertiesModel=CacheResourceDefinition.INDEXING_PROPERTIES.resolveModelAttribute(context,cache);
  Properties indexingProperties=new Properties();
  if (indexing.isEnabled() && indexingPropertiesModel.isDefined()) {
    for (    Property p : indexingPropertiesModel.asPropertyList()) {
      String value=p.getValue().asString();
      indexingProperties.put(p.getName(),value);
    }
  }
  builder.indexing().enabled(indexing.isEnabled()).indexLocalOnly(indexing.isLocalOnly()).withProperties(indexingProperties);
  IsolationLevel isolationLevel=getDefaultConfiguration(this.mode).locking().isolationLevel();
  if (cache.hasDefined(ModelKeys.LOCKING) && cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME).isDefined()) {
    ModelNode locking=cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);
    isolationLevel=IsolationLevel.valueOf(LockingResourceDefinition.ISOLATION.resolveModelAttribute(context,locking).asString());
    final boolean striping=LockingResourceDefinition.STRIPING.resolveModelAttribute(context,locking).asBoolean();
    final long acquireTimeout=LockingResourceDefinition.ACQUIRE_TIMEOUT.resolveModelAttribute(context,locking).asLong();
    final int concurrencyLevel=LockingResourceDefinition.CONCURRENCY_LEVEL.resolveModelAttribute(context,locking).asInt();
    builder.locking().isolationLevel(isolationLevel).useLockStriping(striping).lockAcquisitionTimeout(acquireTimeout).concurrencyLevel(concurrencyLevel);
  }
  LockingMode lockingMode=getDefaultConfiguration(this.mode).transaction().lockingMode();
  if (cache.hasDefined(ModelKeys.TRANSACTION) && cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME).isDefined()) {
    ModelNode transaction=cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME);
    long stopTimeout=TransactionResourceDefinition.STOP_TIMEOUT.resolveModelAttribute(context,transaction).asLong();
    TransactionMode txMode=TransactionMode.valueOf(TransactionResourceDefinition.MODE.resolveModelAttribute(context,transaction).asString());
    lockingMode=LockingMode.valueOf(TransactionResourceDefinition.LOCKING.resolveModelAttribute(context,transaction).asString());
    builder.transaction().cacheStopTimeout(stopTimeout).transactionMode(txMode.getMode()).lockingMode(lockingMode).useSynchronization(!txMode.isXAEnabled()).recovery().enabled(txMode.isRecoveryEnabled());
    if (txMode.getMode().isTransactional()) {
      dependencies.add(new Dependency<>(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER,TransactionManager.class,cacheConfigurationDependencies.getTransactionManagerInjector()));
      if (!txMode.isXAEnabled()) {
        dependencies.add(new Dependency<>(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY,TransactionSynchronizationRegistry.class,cacheConfigurationDependencies.getTransactionSynchronizationRegistryInjector()));
      }
    }
    if (txMode.isRecoveryEnabled()) {
      dependencies.add(new Dependency<>(TxnServices.JBOSS_TXN_ARJUNA_RECOVERY_MANAGER,XAResourceRecoveryRegistry.class,cacheDependencies.getRecoveryRegistryInjector()));
    }
  }
  if ((lockingMode == LockingMode.OPTIMISTIC) && (isolationLevel == IsolationLevel.REPEATABLE_READ) && this.mode.isSynchronous()&& !this.mode.isInvalidation()) {
    builder.locking().writeSkewCheck(true);
    builder.versioning().enable().scheme(VersioningScheme.SIMPLE);
  }
  if (batching) {
    builder.transaction().transactionMode(org.infinispan.transaction.TransactionMode.TRANSACTIONAL).invocationBatching().enable();
    cacheConfigurationDependencies.getTransactionManagerInjector().inject(BatchModeTransactionManager.getInstance());
  }
 else {
    builder.transaction().invocationBatching().disable();
  }
  if (cache.hasDefined(ModelKeys.EVICTION) && cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME).isDefined()) {
    ModelNode eviction=cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME);
    final EvictionStrategy strategy=EvictionStrategy.valueOf(EvictionResourceDefinition.STRATEGY.resolveModelAttribute(context,eviction).asString());
    builder.eviction().strategy(strategy);
    if (strategy.isEnabled()) {
      final int maxEntries=EvictionResourceDefinition.MAX_ENTRIES.resolveModelAttribute(context,eviction).asInt();
      builder.eviction().maxEntries(maxEntries);
    }
  }
  if (cache.hasDefined(ModelKeys.EXPIRATION) && cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME).isDefined()) {
    ModelNode expiration=cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME);
    final long maxIdle=ExpirationResourceDefinition.MAX_IDLE.resolveModelAttribute(context,expiration).asLong();
    final long lifespan=ExpirationResourceDefinition.LIFESPAN.resolveModelAttribute(context,expiration).asLong();
    final long interval=ExpirationResourceDefinition.INTERVAL.resolveModelAttribute(context,expiration).asLong();
    builder.expiration().maxIdle(maxIdle).lifespan(lifespan).wakeUpInterval(interval);
    if ((maxIdle > 0) || (lifespan > 0)) {
      builder.expiration().enableReaper();
    }
 else {
      builder.expiration().disableReaper();
    }
  }
  String storeKey=findStoreKey(cache);
  if (storeKey != null) {
    ModelNode store=getStoreModelNode(cache);
    final boolean shared=StoreResourceDefinition.SHARED.resolveModelAttribute(context,store).asBoolean();
    final boolean preload=StoreResourceDefinition.PRELOAD.resolveModelAttribute(context,store).asBoolean();
    final boolean passivation=StoreResourceDefinition.PASSIVATION.resolveModelAttribute(context,store).asBoolean();
    final boolean fetchState=StoreResourceDefinition.FETCH_STATE.resolveModelAttribute(context,store).asBoolean();
    final boolean purge=StoreResourceDefinition.PURGE.resolveModelAttribute(context,store).asBoolean();
    final boolean singleton=StoreResourceDefinition.SINGLETON.resolveModelAttribute(context,store).asBoolean();
    final boolean async=store.hasDefined(ModelKeys.WRITE_BEHIND) && store.get(ModelKeys.WRITE_BEHIND,ModelKeys.WRITE_BEHIND_NAME).isDefined();
    PersistenceConfigurationBuilder persistenceBuilder=builder.persistence().passivation(passivation);
    StoreConfigurationBuilder<?,?> storeBuilder=this.buildCacheStore(context,persistenceBuilder,containerName,store,storeKey,dependencies).fetchPersistentState(fetchState).preload(preload).shared(shared).purgeOnStartup(purge);
    storeBuilder.singleton().enabled(singleton);
    if (async) {
      ModelNode writeBehind=store.get(ModelKeys.WRITE_BEHIND,ModelKeys.WRITE_BEHIND_NAME);
      storeBuilder.async().enable().flushLockTimeout(StoreWriteBehindResourceDefinition.FLUSH_LOCK_TIMEOUT.resolveModelAttribute(context,writeBehind).asLong()).modificationQueueSize(StoreWriteBehindResourceDefinition.MODIFICATION_QUEUE_SIZE.resolveModelAttribute(context,writeBehind).asInt()).shutdownTimeout(StoreWriteBehindResourceDefinition.SHUTDOWN_TIMEOUT.resolveModelAttribute(context,writeBehind).asLong()).threadPoolSize(StoreWriteBehindResourceDefinition.THREAD_POOL_SIZE.resolveModelAttribute(context,writeBehind).asInt());
    }
    final Properties properties=new TypedProperties();
    if (store.hasDefined(ModelKeys.PROPERTY)) {
      for (      Property property : store.get(ModelKeys.PROPERTY).asPropertyList()) {
        String propertyName=property.getName();
        ModelNode propertyValue=null;
        propertyValue=StorePropertyResourceDefinition.VALUE.resolveModelAttribute(context,property.getValue());
        properties.setProperty(propertyName,propertyValue.asString());
      }
    }
    storeBuilder.withProperties(properties);
  }
}
