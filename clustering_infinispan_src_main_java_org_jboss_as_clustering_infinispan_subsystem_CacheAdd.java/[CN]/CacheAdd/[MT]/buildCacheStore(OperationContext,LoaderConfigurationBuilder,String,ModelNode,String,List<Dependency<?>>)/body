{
  final Properties properties=new TypedProperties();
  if (store.hasDefined(ModelKeys.PROPERTY)) {
    for (    Property property : store.get(ModelKeys.PROPERTY).asPropertyList()) {
      String propertyName=property.getName();
      Property complexValue=property.getValue().asProperty();
      String propertyValue=complexValue.getValue().asString();
      properties.setProperty(propertyName,propertyValue);
    }
  }
  builder.withProperties(properties);
  ModelNode resolvedValue=null;
  if (storeKey.equals(ModelKeys.FILE_STORE)) {
    builder.cacheLoader(new FileCacheStore());
    final String path=((resolvedValue=CommonAttributes.PATH.resolveModelAttribute(context,store)).isDefined()) ? resolvedValue.asString() : InfinispanExtension.SUBSYSTEM_NAME + File.separatorChar + containerName;
    Injector<String> injector=new SimpleInjector<String>(){
      @Override public void inject(      String value){
        StringBuilder location=new StringBuilder(value);
        if (path != null) {
          location.append(File.separatorChar).append(path);
        }
        properties.setProperty("location",location.toString());
      }
    }
;
    final String relativeTo=((resolvedValue=CommonAttributes.RELATIVE_TO.resolveModelAttribute(context,store)).isDefined()) ? resolvedValue.asString() : ServerEnvironment.SERVER_DATA_DIR;
    dependencies.add(new Dependency<String>(AbstractPathService.pathNameOf(relativeTo),String.class,injector));
    properties.setProperty("fsyncMode","perWrite");
  }
 else   if (storeKey.equals(ModelKeys.STRING_KEYED_JDBC_STORE) || storeKey.equals(ModelKeys.BINARY_KEYED_JDBC_STORE) || storeKey.equals(ModelKeys.MIXED_KEYED_JDBC_STORE)) {
    builder.cacheLoader(this.createJDBCStore(properties,context,store));
    final String datasource=CommonAttributes.DATA_SOURCE.resolveModelAttribute(context,store).asString();
    dependencies.add(new Dependency<Object>(ServiceName.JBOSS.append("data-source",datasource)));
    properties.setProperty("datasourceJndiLocation",datasource);
    properties.setProperty("connectionFactoryClass",ManagedConnectionFactory.class.getName());
  }
 else   if (storeKey.equals(ModelKeys.REMOTE_STORE)) {
    builder.cacheLoader(new RemoteCacheStore());
    for (    ModelNode server : store.require(ModelKeys.REMOTE_SERVERS).asList()) {
      String outboundSocketBinding=server.get(ModelKeys.OUTBOUND_SOCKET_BINDING).asString();
      Injector<OutboundSocketBinding> injector=new SimpleInjector<OutboundSocketBinding>(){
        @Override public void inject(        OutboundSocketBinding value){
          try {
            String address=value.getDestinationAddress().getHostAddress() + ":" + value.getDestinationPort();
            String serverList=properties.getProperty("serverList");
            properties.setProperty("serverList",(serverList == null) ? address : serverList + ";" + address);
          }
 catch (          UnknownHostException e) {
            throw InfinispanMessages.MESSAGES.failedToInjectSocketBinding(e,value);
          }
        }
      }
;
      dependencies.add(new Dependency<OutboundSocketBinding>(OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBinding),OutboundSocketBinding.class,injector));
    }
    if (store.hasDefined(ModelKeys.CACHE)) {
      properties.setProperty("remoteCacheName",store.get(ModelKeys.CACHE).asString());
      properties.setProperty("useDefaultRemoteCache",Boolean.toString(false));
    }
 else {
      properties.setProperty("useDefaultRemoteCache",Boolean.toString(true));
    }
    if (store.hasDefined(ModelKeys.SOCKET_TIMEOUT)) {
      properties.setProperty("soTimeout",store.require(ModelKeys.SOCKET_TIMEOUT).asString());
    }
    if (store.hasDefined(ModelKeys.TCP_NO_DELAY)) {
      properties.setProperty("tcpNoDelay",store.require(ModelKeys.TCP_NO_DELAY).asString());
    }
  }
 else {
    String className=store.require(ModelKeys.CLASS).asString();
    try {
      CacheLoader loader=CacheLoader.class.getClassLoader().loadClass(className).asSubclass(CacheLoader.class).newInstance();
      builder.cacheLoader(loader);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(String.format("%s is not a valid cache store",className),e);
    }
  }
}
