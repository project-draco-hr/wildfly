{
  ModelNode resolvedValue=null;
  final String indexingString=((resolvedValue=CommonAttributes.INDEXING.resolveModelAttribute(context,cache)).isDefined()) ? resolvedValue.asString() : null;
  final int queueSize=CommonAttributes.QUEUE_SIZE.resolveModelAttribute(context,cache).asInt();
  final long queueFlushInterval=CommonAttributes.QUEUE_FLUSH_INTERVAL.resolveModelAttribute(context,cache).asLong();
  final long remoteTimeout=CommonAttributes.REMOTE_TIMEOUT.resolveModelAttribute(context,cache).asLong();
  final boolean batching=CommonAttributes.BATCHING.resolveModelAttribute(context,cache).asBoolean();
  final boolean asyncMarshalling=CommonAttributes.ASYNC_MARSHALLING.resolveModelAttribute(context,cache).asBoolean();
  builder.classLoader(this.getClass().getClassLoader());
  CacheMode cacheMode=CacheMode.valueOf(cache.require(ModelKeys.MODE).asString());
  builder.clustering().cacheMode(cacheMode);
  if (indexingString != null) {
    Indexing indexing=Indexing.valueOf(indexingString);
    builder.indexing().enabled(indexing.isEnabled()).indexLocalOnly(indexing.isLocalOnly());
  }
  if (cacheMode.isSynchronous()) {
    builder.clustering().sync().replTimeout(remoteTimeout);
  }
 else {
    builder.clustering().async().replQueueMaxElements(queueSize).useReplQueue(queueSize > 0);
    builder.clustering().async().replQueueInterval(queueFlushInterval);
    if (asyncMarshalling) {
      builder.clustering().async().asyncMarshalling();
    }
 else {
      builder.clustering().async().syncMarshalling();
    }
  }
  if (cache.hasDefined(ModelKeys.LOCKING) && cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME).isDefined()) {
    ModelNode locking=cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);
    final String isolationLevel=((resolvedValue=CommonAttributes.ISOLATION.resolveModelAttribute(context,locking)).isDefined()) ? resolvedValue.asString() : null;
    final boolean striping=CommonAttributes.SHARED.resolveModelAttribute(context,locking).asBoolean();
    final long acquireTimeout=CommonAttributes.ACQUIRE_TIMEOUT.resolveModelAttribute(context,locking).asLong();
    final int concurrencyLevel=CommonAttributes.CONCURRENCY_LEVEL.resolveModelAttribute(context,locking).asInt();
    builder.locking().isolationLevel(IsolationLevel.valueOf(isolationLevel));
    builder.locking().useLockStriping(striping);
    builder.locking().lockAcquisitionTimeout(acquireTimeout);
    builder.locking().concurrencyLevel(concurrencyLevel);
  }
  TransactionMode txMode=TransactionMode.NONE;
  LockingMode lockingMode=LockingMode.OPTIMISTIC;
  if (cache.hasDefined(ModelKeys.TRANSACTION) && cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME).isDefined()) {
    ModelNode transaction=cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME);
    final long stopTimeout=CommonAttributes.STOP_TIMEOUT.resolveModelAttribute(context,transaction).asLong();
    final String txnMode=((resolvedValue=CommonAttributes.MODE.resolveModelAttribute(context,transaction)).isDefined()) ? resolvedValue.asString() : null;
    final String lockingModeString=((resolvedValue=CommonAttributes.LOCKING.resolveModelAttribute(context,transaction)).isDefined()) ? resolvedValue.asString() : null;
    builder.transaction().cacheStopTimeout(stopTimeout);
    if (txnMode != null) {
      txMode=TransactionMode.valueOf(txnMode);
    }
    if (lockingModeString != null) {
      lockingMode=LockingMode.valueOf(lockingModeString);
    }
  }
  builder.transaction().transactionMode(txMode.getMode()).lockingMode(lockingMode).useSynchronization(!txMode.isXAEnabled()).recovery().enabled(txMode.isRecoveryEnabled());
  if (txMode.isRecoveryEnabled()) {
    builder.transaction().syncCommitPhase(true).syncRollbackPhase(true);
  }
  if (batching) {
    builder.transaction().transactionMode(org.infinispan.transaction.TransactionMode.TRANSACTIONAL).invocationBatching().enable();
  }
 else {
    builder.transaction().invocationBatching().disable();
  }
  if (cache.hasDefined(ModelKeys.EVICTION) && cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME).isDefined()) {
    ModelNode eviction=cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME);
    final String strategy=((resolvedValue=CommonAttributes.STRATEGY.resolveModelAttribute(context,eviction)).isDefined()) ? resolvedValue.asString() : null;
    final int maxEntries=CommonAttributes.MAX_ENTRIES.resolveModelAttribute(context,eviction).asInt();
    if (strategy != null) {
      builder.eviction().strategy(EvictionStrategy.valueOf(strategy));
    }
    builder.eviction().maxEntries(maxEntries);
  }
  if (cache.hasDefined(ModelKeys.EXPIRATION) && cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME).isDefined()) {
    ModelNode expiration=cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME);
    final long maxIdle=CommonAttributes.MAX_IDLE.resolveModelAttribute(context,expiration).asLong();
    final long lifespan=CommonAttributes.LIFESPAN.resolveModelAttribute(context,expiration).asLong();
    final long interval=CommonAttributes.INTERVAL.resolveModelAttribute(context,expiration).asLong();
    builder.expiration().maxIdle(maxIdle);
    builder.expiration().lifespan(lifespan);
    builder.expiration().wakeUpInterval(interval);
  }
  String storeKey=this.findStoreKey(cache);
  if (storeKey != null) {
    ModelNode store=this.getStoreModelNode(cache);
    final boolean shared=CommonAttributes.SHARED.resolveModelAttribute(context,store).asBoolean();
    final boolean preload=CommonAttributes.PRELOAD.resolveModelAttribute(context,store).asBoolean();
    final boolean passivation=CommonAttributes.PASSIVATION.resolveModelAttribute(context,store).asBoolean();
    final boolean fetchState=CommonAttributes.FETCH_STATE.resolveModelAttribute(context,store).asBoolean();
    final boolean purge=CommonAttributes.PURGE.resolveModelAttribute(context,store).asBoolean();
    final boolean singleton=CommonAttributes.SINGLETON.resolveModelAttribute(context,store).asBoolean();
    builder.loaders().shared(shared).preload(preload).passivation(passivation);
    LoaderConfigurationBuilder storeBuilder=builder.loaders().addCacheLoader().fetchPersistentState(fetchState).purgeOnStartup(purge).purgeSynchronously(true);
    storeBuilder.singletonStore().enabled(singleton);
    this.buildCacheStore(context,storeBuilder,containerName,store,storeKey,dependencies);
  }
}
