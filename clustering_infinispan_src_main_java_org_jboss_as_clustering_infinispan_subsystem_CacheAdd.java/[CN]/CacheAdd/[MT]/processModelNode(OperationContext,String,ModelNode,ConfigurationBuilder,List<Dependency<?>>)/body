{
  final Indexing indexing=Indexing.valueOf(CommonAttributes.INDEXING.resolveModelAttribute(context,cache).asString());
  final boolean batching=CommonAttributes.BATCHING.resolveModelAttribute(context,cache).asBoolean();
  builder.clustering().cacheMode(this.mode);
  final ModelNode indexingPropertiesModel=CommonAttributes.INDEXING_PROPERTIES.resolveModelAttribute(context,cache);
  Properties indexingProperties=new Properties();
  if (indexing.isEnabled() && indexingPropertiesModel.isDefined()) {
    for (    Property p : indexingPropertiesModel.asPropertyList()) {
      String value=p.getValue().asString();
      indexingProperties.put(p.getName(),value);
    }
  }
  builder.indexing().enabled(indexing.isEnabled()).indexLocalOnly(indexing.isLocalOnly()).withProperties(indexingProperties);
  if (cache.hasDefined(ModelKeys.LOCKING) && cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME).isDefined()) {
    ModelNode locking=cache.get(ModelKeys.LOCKING,ModelKeys.LOCKING_NAME);
    final IsolationLevel isolationLevel=IsolationLevel.valueOf(CommonAttributes.ISOLATION.resolveModelAttribute(context,locking).asString());
    final boolean striping=CommonAttributes.STRIPING.resolveModelAttribute(context,locking).asBoolean();
    final long acquireTimeout=CommonAttributes.ACQUIRE_TIMEOUT.resolveModelAttribute(context,locking).asLong();
    final int concurrencyLevel=CommonAttributes.CONCURRENCY_LEVEL.resolveModelAttribute(context,locking).asInt();
    builder.locking().isolationLevel(isolationLevel).useLockStriping(striping).lockAcquisitionTimeout(acquireTimeout).concurrencyLevel(concurrencyLevel);
  }
  TransactionMode txMode=TransactionMode.NONE;
  LockingMode lockingMode=LockingMode.OPTIMISTIC;
  if (cache.hasDefined(ModelKeys.TRANSACTION) && cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME).isDefined()) {
    ModelNode transaction=cache.get(ModelKeys.TRANSACTION,ModelKeys.TRANSACTION_NAME);
    final long stopTimeout=CommonAttributes.STOP_TIMEOUT.resolveModelAttribute(context,transaction).asLong();
    txMode=TransactionMode.valueOf(CommonAttributes.MODE.resolveModelAttribute(context,transaction).asString());
    lockingMode=LockingMode.valueOf(CommonAttributes.LOCKING.resolveModelAttribute(context,transaction).asString());
    builder.transaction().cacheStopTimeout(stopTimeout);
  }
  builder.transaction().transactionMode(txMode.getMode()).lockingMode(lockingMode).useSynchronization(!txMode.isXAEnabled()).recovery().enabled(txMode.isRecoveryEnabled());
  if (txMode.isRecoveryEnabled()) {
    builder.transaction().syncCommitPhase(true).syncRollbackPhase(true);
  }
  if (batching) {
    builder.transaction().transactionMode(org.infinispan.transaction.TransactionMode.TRANSACTIONAL).invocationBatching().enable();
  }
 else {
    builder.transaction().invocationBatching().disable();
  }
  if (cache.hasDefined(ModelKeys.EVICTION) && cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME).isDefined()) {
    ModelNode eviction=cache.get(ModelKeys.EVICTION,ModelKeys.EVICTION_NAME);
    final EvictionStrategy strategy=EvictionStrategy.valueOf(CommonAttributes.EVICTION_STRATEGY.resolveModelAttribute(context,eviction).asString());
    builder.eviction().strategy(strategy);
    if (strategy.isEnabled()) {
      final int maxEntries=CommonAttributes.MAX_ENTRIES.resolveModelAttribute(context,eviction).asInt();
      builder.eviction().maxEntries(maxEntries);
    }
  }
  if (cache.hasDefined(ModelKeys.EXPIRATION) && cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME).isDefined()) {
    ModelNode expiration=cache.get(ModelKeys.EXPIRATION,ModelKeys.EXPIRATION_NAME);
    final long maxIdle=CommonAttributes.MAX_IDLE.resolveModelAttribute(context,expiration).asLong();
    final long lifespan=CommonAttributes.LIFESPAN.resolveModelAttribute(context,expiration).asLong();
    final long interval=CommonAttributes.INTERVAL.resolveModelAttribute(context,expiration).asLong();
    builder.expiration().maxIdle(maxIdle).lifespan(lifespan).wakeUpInterval(interval);
    if ((maxIdle > 0) || (lifespan > 0)) {
      builder.expiration().enableReaper();
    }
 else {
      builder.expiration().disableReaper();
    }
  }
  String storeKey=this.findStoreKey(cache);
  if (storeKey != null) {
    ModelNode store=this.getStoreModelNode(cache);
    final boolean shared=CommonAttributes.SHARED.resolveModelAttribute(context,store).asBoolean();
    final boolean preload=CommonAttributes.PRELOAD.resolveModelAttribute(context,store).asBoolean();
    final boolean passivation=CommonAttributes.PASSIVATION.resolveModelAttribute(context,store).asBoolean();
    final boolean fetchState=CommonAttributes.FETCH_STATE.resolveModelAttribute(context,store).asBoolean();
    final boolean purge=CommonAttributes.PURGE.resolveModelAttribute(context,store).asBoolean();
    final boolean singleton=CommonAttributes.SINGLETON.resolveModelAttribute(context,store).asBoolean();
    final boolean async=store.hasDefined(ModelKeys.WRITE_BEHIND) && store.get(ModelKeys.WRITE_BEHIND,ModelKeys.WRITE_BEHIND_NAME).isDefined();
    builder.loaders().shared(shared).preload(preload).passivation(passivation);
    LoaderConfigurationBuilder storeBuilder=builder.loaders().addCacheLoader().fetchPersistentState(fetchState).purgeOnStartup(purge).purgeSynchronously(true);
    storeBuilder.singletonStore().enabled(singleton);
    if (async) {
      ModelNode writeBehind=store.get(ModelKeys.WRITE_BEHIND,ModelKeys.WRITE_BEHIND_NAME);
      storeBuilder.async().enable().flushLockTimeout(CommonAttributes.FLUSH_LOCK_TIMEOUT.resolveModelAttribute(context,writeBehind).asLong()).modificationQueueSize(CommonAttributes.MODIFICATION_QUEUE_SIZE.resolveModelAttribute(context,writeBehind).asInt()).shutdownTimeout(CommonAttributes.SHUTDOWN_TIMEOUT.resolveModelAttribute(context,writeBehind).asLong()).threadPoolSize(CommonAttributes.THREAD_POOL_SIZE.resolveModelAttribute(context,writeBehind).asInt());
    }
    this.buildCacheStore(context,storeBuilder,containerName,store,storeKey,dependencies);
  }
}
