{
  Cache<?,?> groupCache=this.groupCache.getValue();
  Configuration groupCacheConfiguration=groupCache.getCacheConfiguration();
  EmbeddedCacheManager container=groupCache.getCacheManager();
  ConfigurationBuilder builder=new ConfigurationBuilder().read(groupCacheConfiguration);
  builder.storeAsBinary().enable().storeKeysAsBinary(true).storeValuesAsBinary(false);
  if (this.maxSize > 0) {
    if (!groupCacheConfiguration.eviction().strategy().isEnabled()) {
      builder.eviction().strategy(EvictionStrategy.LRU);
    }
    builder.eviction().maxEntries(this.maxSize);
  }
  groupCache.getCacheManager().defineConfiguration(beanName,builder.build());
  Cache<K,MarshalledValue<E,MarshallingContext>> cache=container.<K,MarshalledValue<E,MarshallingContext>>getCache(beanName);
  MarshallingContext context=new MarshallingContext(this.factory,passivationManager);
  MarshalledValueFactory<MarshallingContext> valueFactory=new SimpleMarshalledValueFactory(context);
  LockKeyFactory<K> lockKeyFactory=new LockKeyFactory<K>(){
    @Override public Serializable createLockKey(    K key){
      return new AbstractMap.SimpleImmutableEntry<K,String>(key,beanName);
    }
  }
;
  @SuppressWarnings("unchecked") Registry<String,?> registry=this.registry.getValue();
  return new InfinispanBackingCacheEntryStore<K,V,E,MarshallingContext>(cache,this.invoker,identifierFactory,this.affinityFactory,this.passivateEventsOnReplicate ? passivationManager : null,timeout,this,true,valueFactory,context,this.lockManager.getValue(),lockKeyFactory,registry);
}
