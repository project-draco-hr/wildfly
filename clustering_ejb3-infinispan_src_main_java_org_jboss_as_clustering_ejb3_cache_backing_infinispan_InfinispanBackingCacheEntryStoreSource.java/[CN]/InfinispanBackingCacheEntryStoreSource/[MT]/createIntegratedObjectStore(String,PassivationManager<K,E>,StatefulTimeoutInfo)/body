{
  Cache<?,?> groupCache=this.groupCache.getValue();
  Configuration groupCacheConfiguration=groupCache.getCacheConfiguration();
  EmbeddedCacheManager container=groupCache.getCacheManager();
  ConfigurationBuilder builder=new ConfigurationBuilder().read(groupCacheConfiguration);
  if (this.maxSize > 0) {
    if (!groupCacheConfiguration.eviction().strategy().isEnabled()) {
      builder.eviction().strategy(EvictionStrategy.LRU);
    }
    builder.eviction().maxEntries(this.maxSize);
  }
  groupCache.getCacheManager().defineConfiguration(beanName,builder.build());
  Cache<MarshalledValue<K,MarshallingContext>,MarshalledValue<E,MarshallingContext>> cache=container.<MarshalledValue<K,MarshallingContext>,MarshalledValue<E,MarshallingContext>>getCache(beanName).getAdvancedCache().with(this.getClass().getClassLoader());
  MarshallingContext context=new MarshallingContext(this.factory,passivationManager.getMarshallingConfiguration());
  MarshalledValueFactory<MarshallingContext> keyFactory=new HashableMarshalledValueFactory(context);
  MarshalledValueFactory<MarshallingContext> valueFactory=new SimpleMarshalledValueFactory(context);
  LockKeyFactory<K,MarshallingContext> lockKeyFactory=new LockKeyFactory<K,MarshallingContext>(){
    @Override public Serializable createLockKey(    MarshalledValue<K,MarshallingContext> key){
      return new AbstractMap.SimpleImmutableEntry<MarshalledValue<K,MarshallingContext>,String>(key,beanName);
    }
  }
;
  @SuppressWarnings("unchecked") Registry<String,?> registry=this.registry.getValue();
  return new InfinispanBackingCacheEntryStore<K,V,E,MarshallingContext>(cache,this.invoker,this.passivateEventsOnReplicate ? passivationManager : null,timeout,this,true,keyFactory,valueFactory,context,this.lockManager.getValue(),lockKeyFactory,registry);
}
