{
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final IOExceptionHolder holder=new IOExceptionHolder();
  Cancellable result=modelController.execute(operation,new ResultHandler(){
    @Override public void handleResultFragment(    String[] location,    ModelNode fragment){
      try {
synchronized (outputStream) {
          outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FRAGMENT);
          outputStream.write(ModelControllerClientProtocol.PARAM_LOCATION);
          StreamUtils.writeInt(outputStream,location.length);
          for (          String loc : location) {
            StreamUtils.writeUTFZBytes(outputStream,loc);
          }
          outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);
          fragment.writeExternal(outputStream);
          outputStream.flush();
        }
      }
 catch (      IOException e) {
        handleIOException(e);
      }
    }
    @Override public void handleResultComplete(    ModelNode compensatingOperation){
      try {
        asynchOperations.remove(asynchronousRequestId);
synchronized (outputStream) {
          outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_COMPLETE);
          outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);
          if (compensatingOperation == null) {
            new ModelNode().writeExternal(outputStream);
          }
 else {
            compensatingOperation.writeExternal(outputStream);
          }
        }
        completeLatch.countDown();
      }
 catch (      IOException e) {
        handleIOException(e);
      }
    }
    @Override public void handleFailed(    final ModelNode failureDescription){
      try {
        asynchOperations.remove(asynchronousRequestId);
synchronized (outputStream) {
          outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_RESULT_FAILED);
          outputStream.write(ModelControllerClientProtocol.PARAM_OPERATION);
          failureDescription.writeExternal(outputStream);
        }
        completeLatch.countDown();
      }
 catch (      IOException e) {
        handleIOException(e);
      }
    }
    @Override public void handleCancellation(){
      try {
        asynchOperations.remove(asynchronousRequestId);
synchronized (outputStream) {
          outputStream.write(ModelControllerClientProtocol.PARAM_HANDLE_CANCELLATION);
        }
        completeLatch.countDown();
      }
 catch (      IOException e) {
        handleIOException(e);
      }
    }
    private void handleIOException(    IOException e){
      asynchOperations.remove(asynchronousRequestId);
      holder.setException(e);
      completeLatch.countDown();
    }
  }
);
  if (completeLatch.getCount() == 0) {
  }
 else {
    asynchOperations.put(Integer.valueOf(asynchronousRequestId),result);
synchronized (outputStream) {
      outputStream.write(ModelControllerClientProtocol.PARAM_REQUEST_ID);
      StreamUtils.writeInt(outputStream,asynchronousRequestId);
      outputStream.flush();
    }
    while (true) {
      try {
        completeLatch.await();
        break;
      }
 catch (      InterruptedException e) {
      }
    }
    if (holder.getException() != null) {
      throw holder.getException();
    }
  }
}
