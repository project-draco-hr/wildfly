{
  validator.validate(operation);
  ModelNode opAddr=operation.get(OP_ADDR);
  PathAddress address=PathAddress.pathAddress(opAddr);
  String name=address.getLastElement().getValue();
  String runtimeName=operation.hasDefined(RUNTIME_NAME) ? operation.get(RUNTIME_NAME).asString() : name;
  byte[] hash;
  if (operation.hasDefined(INPUT_STREAM_INDEX) && operation.hasDefined(HASH)) {
    throw new OperationFailedException(new ModelNode().set("Can't pass in both an input-stream-index and a hash"));
  }
 else   if (operation.hasDefined(HASH)) {
    hash=operation.get(HASH).asBytes();
  }
 else   if (operation.hasDefined(INPUT_STREAM_INDEX)) {
    if (!isMaster) {
      throw new OperationFailedException(new ModelNode().set("A slave domain controller cannot accept deployment content uploads"));
    }
    try {
      hash=DeploymentUploadUtil.storeDeploymentContent(context,operation,deploymentRepository);
    }
 catch (    IOException e) {
      throw new OperationFailedException(new ModelNode().set(e.toString()));
    }
  }
 else {
    throw new OperationFailedException(new ModelNode().set("Neither an attachment nor a hash were passed in"));
  }
  if (!isMaster || deploymentRepository.hasDeploymentContent(hash)) {
    ModelNode subModel=context.getSubModel();
    subModel.get(NAME).set(name);
    subModel.get(RUNTIME_NAME).set(runtimeName);
    subModel.get(HASH).set(hash);
  }
 else {
    throw new OperationFailedException(new ModelNode().set(String.format("No deployment content with hash %s is available in the deployment content repository.",HashUtil.bytesToHexString(hash))));
  }
  resultHandler.handleResultComplete();
  return new BasicOperationResult(Util.getResourceRemoveOperation(operation.get(OP_ADDR)));
}
