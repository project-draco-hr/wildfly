{
  if (len == 0)   return 0;
  if (simulateEof) {
    simulateEof=false;
    return -1;
  }
  if (realEof) {
    if (leftOvers == null)     return -1;
    if (bufferingCompleted == false) {
      bufferingCompleted=true;
    }
  }
  int bufferLength=Math.max(boundary.length * 2,len + boundary.length);
  byte[] buffer=new byte[bufferLength];
  int position=consumeLeftOvers(buffer,0,bufferLength);
  if (position < bufferLength)   position+=fullRead(buffer,position,bufferLength - position);
  if (realEof && position == 0)   return -1;
  int returnLength;
  int boundaryPosition=findBoundary(buffer,position);
  if (boundaryPosition == BOUNDARY_NOT_FOUND || boundaryPosition >= len) {
    returnLength=Math.min(len,position);
    createLeftOvers(buffer,returnLength,position);
  }
 else {
    returnLength=boundaryPosition;
    createLeftOvers(buffer,returnLength + boundary.length,position);
    if (returnLength == 0)     return -1;
    simulateEof=true;
  }
  if (!skip)   System.arraycopy(buffer,0,b,off,returnLength);
  return returnLength;
}
