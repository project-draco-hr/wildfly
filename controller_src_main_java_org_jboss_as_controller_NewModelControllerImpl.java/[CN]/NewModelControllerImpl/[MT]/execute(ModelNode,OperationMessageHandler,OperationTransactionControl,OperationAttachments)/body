{
  final ModelNode headers=operation.get(OPERATION_HEADERS);
  final boolean rollbackOnFailure=headers == null || headers.get(ROLLBACK_ON_RUNTIME_FAILURE).asBoolean(true);
  final EnumSet<NewOperationContextImpl.ContextFlag> contextFlags=rollbackOnFailure ? EnumSet.of(NewOperationContextImpl.ContextFlag.ROLLBACK_ON_FAIL) : EnumSet.noneOf(NewOperationContextImpl.ContextFlag.class);
  NewOperationContextImpl context=new NewOperationContextImpl(this,controllerType,contextFlags,handler,attachments,modelReference.get(),control,processState,bootingFlag.getAndSet(false));
  ModelNode response=new ModelNode();
  if (prepareStep != null) {
    context.addStep(response,operation,prepareStep,NewOperationContext.Stage.MODEL);
  }
  final PathAddress address=PathAddress.pathAddress(operation.get(OP_ADDR));
  if (address.isMultiTarget()) {
    context.addStep(response,GlobalOperationHandlers.MultiTargetOperationHandler.FAKE_OPERATION,new GlobalOperationHandlers.MultiTargetOperationHandler(operation),NewOperationContext.Stage.MODEL);
  }
 else {
    final String operationName=operation.require(OP).asString();
    final NewStepHandler stepHandler=rootRegistration.getOperationHandler(address,operationName);
    if (stepHandler != null) {
      context.addStep(response,operation,stepHandler,NewOperationContext.Stage.MODEL);
    }
 else {
      reportNoHandler(operationName,address,response);
    }
  }
  RB_ON_RT_FAILURE.set(Boolean.valueOf(rollbackOnFailure));
  try {
    context.completeStep();
  }
  finally {
    RB_ON_RT_FAILURE.set(null);
  }
  ControlledProcessState.State state=processState.getState();
switch (state) {
case RELOAD_REQUIRED:
case RESTART_REQUIRED:
    response.get(RESPONSE_HEADERS,PROCESS_STATE).set(state.toString());
  break;
default :
break;
}
return response;
}
