{
  final List<ParsedCmpField> keyFields=parsedRole.getKeyFields();
  if (keyFields == null || keyFields.isEmpty()) {
    return loadKeyFields();
  }
  if (relationMetaData.isForeignKeyMappingStyle() && isMultiplicityMany()) {
    throw new RuntimeException("Role: " + relationshipRoleName + " with multiplicity many using "+ "foreign-key mapping is not allowed to have key-fields");
  }
  Map<String,JDBCCMPFieldMetaData> defaultFields=getPrimaryKeyFields();
  Map<String,JDBCCMPFieldMetaData> fields=new HashMap<String,JDBCCMPFieldMetaData>(defaultFields.size());
  for (  ParsedCmpField keyField : keyFields) {
    String fieldName=keyField.getFieldName();
    JDBCCMPFieldMetaData cmpField=defaultFields.remove(fieldName);
    if (cmpField == null) {
      throw new RuntimeException("Role '" + relationshipRoleName + "' on Entity Bean '"+ entity.getName()+ "' : CMP field for key not found: field "+ "name='"+ fieldName+ "'");
    }
    genIndex=keyField.getGenIndex() != null && keyField.getGenIndex();
    cmpField=new JDBCCMPFieldMetaData(entity,keyField,cmpField,false,relationMetaData.isTableMappingStyle(),relationMetaData.isReadOnly(),relationMetaData.getReadTimeOut(),relationMetaData.isTableMappingStyle());
    fields.put(cmpField.getFieldName(),cmpField);
  }
  if (!defaultFields.isEmpty()) {
    throw new RuntimeException("Mappings were not provided for all " + "fields: unmaped fields=" + defaultFields.keySet() + " in role="+ relationshipRoleName);
  }
  return Collections.unmodifiableMap(fields);
}
