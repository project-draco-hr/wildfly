{
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
    final Element element=Element.forName(reader.getLocalName());
switch (element) {
case DISCOVERY_GROUP_REF:
{
        final Location location=reader.getLocation();
        final String groupRef=readStringAttributeElement(reader,DISCOVERY_GROUP_NAME.getXmlName());
        DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef,connectionFactory,location);
        break;
      }
case CONNECTORS:
{
      connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));
      break;
    }
case ENTRIES:
{
    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
      final Element local=Element.forName(reader.getLocalName());
      if (local != Element.ENTRY) {
        throw ParseUtils.unexpectedElement(reader);
      }
      final Location location=reader.getLocation();
      final String entry=readStringAttributeElement(reader,CommonAttributes.NAME);
      JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry,connectionFactory,location);
    }
    break;
  }
case INBOUND_CONFIG:
{
  while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
    final Element local=Element.forName(reader.getLocalName());
switch (local) {
case USE_JNDI:
case JNDI_PARAMS:
case USE_LOCAL_TX:
case SETUP_ATTEMPTS:
case SETUP_INTERVAL:
      handleElementText(reader,local,connectionFactory);
    break;
default :
  throw ParseUtils.unexpectedElement(reader);
}
}
break;
}
case TRANSACTION:
{
final String txType=reader.getAttributeValue(0);
if (txType != null) {
connectionFactory.get(TRANSACTION).set(txType);
}
ParseUtils.requireNoContent(reader);
break;
}
case DISCOVERY_INITIAL_WAIT_TIMEOUT:
case CLIENT_FAILURE_CHECK_PERIOD:
case CONNECTION_TTL:
case CALL_TIMEOUT:
case CONSUMER_WINDOW_SIZE:
case CONSUMER_MAX_RATE:
case CONFIRMATION_WINDOW_SIZE:
case PRODUCER_WINDOW_SIZE:
case PRODUCER_MAX_RATE:
case CACHE_LARGE_MESSAGE_CLIENT:
case MIN_LARGE_MESSAGE_SIZE:
case CLIENT_ID:
case DUPS_OK_BATCH_SIZE:
case TRANSACTION_BATH_SIZE:
case BLOCK_ON_ACK:
case BLOCK_ON_NON_DURABLE_SEND:
case BLOCK_ON_DURABLE_SEND:
case AUTO_GROUP:
case PRE_ACK:
case RETRY_INTERVAL:
case RETRY_INTERVAL_MULTIPLIER:
case MAX_RETRY_INTERVAL:
case FAILOVER_ON_INITIAL_CONNECTION:
case FAILOVER_ON_SERVER_SHUTDOWN:
case LOAD_BALANCING_CLASS_NAME:
case USE_GLOBAL_POOLS:
case GROUP_ID:
handleElementText(reader,element,connectionFactory);
break;
case RECONNECT_ATTEMPTS:
case SCHEDULED_THREAD_POOL_MAX_SIZE:
case THREAD_POOL_MAX_SIZE:
handleElementText(reader,element,"connection",connectionFactory);
break;
default :
{
throw ParseUtils.unexpectedElement(reader);
}
}
}
return connectionFactory;
}
