{
  if (useThreadLocal) {
    LAST_ELEMENT.set(null);
  }
  final MessagingSubsystemUpdate update=new MessagingSubsystemUpdate();
  updates.add(update);
  int tag=reader.getEventType();
  String localName=null;
  do {
    tag=reader.nextTag();
    localName=reader.getLocalName();
    final Element element=Element.forName(reader.getLocalName());
    log.tracef("%s -> %s, event=%s",localName,element,ElementUtils.StaxEvent.tagToEvent(tag));
switch (element) {
case ACCEPTORS:
      processAcceptors(reader,updates);
    break;
case ADDRESS_SETTINGS:
  processAddressSettings(reader,updates);
break;
case ASYNC_CONNECTION_EXECUTION_ENABLED:
unhandledElement(reader,element);
break;
case BACKUP:
unhandledElement(reader,element);
break;
case BACKUP_CONNECTOR_REF:
unhandledElement(reader,element);
break;
case BINDINGS_DIRECTORY:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setBindingsDirectory(text.trim());
}
}
break;
case BROADCAST_PERIOD:
unhandledElement(reader,element);
break;
case CLUSTERED:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setClustered(Boolean.getBoolean(text.trim()));
}
}
break;
case CLUSTER_PASSWORD:
unhandledElement(reader,element);
break;
case CLUSTER_USER:
unhandledElement(reader,element);
break;
case CONNECTION_TTL_OVERRIDE:
unhandledElement(reader,element);
break;
case CONNECTORS:
processConnectors(reader,updates);
break;
case CONNECTOR_REF:
unhandledElement(reader,element);
break;
case CREATE_BINDINGS_DIR:
unhandledElement(reader,element);
break;
case CREATE_JOURNAL_DIR:
unhandledElement(reader,element);
break;
case FILE_DEPLOYMENT_ENABLED:
unhandledElement(reader,element);
break;
case GROUP_ADDRESS:
unhandledElement(reader,element);
break;
case GROUP_PORT:
unhandledElement(reader,element);
break;
case GROUPING_HANDLER:
unhandledElement(reader,element);
break;
case ID_CACHE_SIZE:
unhandledElement(reader,element);
break;
case JMX_DOMAIN:
unhandledElement(reader,element);
break;
case JMX_MANAGEMENT_ENABLED:
unhandledElement(reader,element);
break;
case JOURNAL_BUFFER_SIZE:
unhandledElement(reader,element);
break;
case JOURNAL_BUFFER_TIMEOUT:
unhandledElement(reader,element);
break;
case JOURNAL_COMPACT_MIN_FILES:
unhandledElement(reader,element);
break;
case JOURNAL_COMPACT_PERCENTAGE:
unhandledElement(reader,element);
break;
case JOURNAL_DIRECTORY:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setJournalDirectory(text.trim());
}
}
break;
case JOURNAL_MIN_FILES:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setJournalMinFiles(Integer.valueOf(text.trim()));
}
}
break;
case JOURNAL_SYNC_NON_TRANSACTIONAL:
unhandledElement(reader,element);
break;
case JOURNAL_SYNC_TRANSACTIONAL:
unhandledElement(reader,element);
break;
case JOURNAL_TYPE:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
JournalType jtype=JournalType.valueOf(text.trim());
update.setJournalType(jtype);
}
}
break;
case JOURNAL_FILE_SIZE:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
int size=Integer.valueOf(text.trim());
update.setJournalFileSize(size);
}
}
break;
case JOURNAL_MAX_IO:
unhandledElement(reader,element);
break;
case LARGE_MESSAGES_DIRECTORY:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setLargeMessagesDirectory(text.trim());
}
}
break;
case LOCAL_BIND_ADDRESS:
unhandledElement(reader,element);
break;
case LOCAL_BIND_PORT:
unhandledElement(reader,element);
break;
case LOG_JOURNAL_WRITE_RATE:
unhandledElement(reader,element);
break;
case MANAGEMENT_ADDRESS:
unhandledElement(reader,element);
break;
case MANAGEMENT_NOTIFICATION_ADDRESS:
unhandledElement(reader,element);
break;
case MEMORY_MEASURE_INTERVAL:
unhandledElement(reader,element);
break;
case MEMORY_WARNING_THRESHOLD:
unhandledElement(reader,element);
break;
case MESSAGE_COUNTER_ENABLED:
unhandledElement(reader,element);
break;
case MESSAGE_COUNTER_MAX_DAY_HISTORY:
unhandledElement(reader,element);
break;
case MESSAGE_COUNTER_SAMPLE_PERIOD:
unhandledElement(reader,element);
break;
case MESSAGE_EXPIRY_SCAN_PERIOD:
unhandledElement(reader,element);
break;
case MESSAGE_EXPIRY_THREAD_PRIORITY:
unhandledElement(reader,element);
break;
case PAGING_DIRECTORY:
{
String text=reader.getElementText();
if (text != null && text.length() > 0) {
update.setPagingDirectory(text.trim());
}
}
break;
case PERF_BLAST_PAGES:
unhandledElement(reader,element);
break;
case PERSIST_DELIVERY_COUNT_BEFORE_DELIVERY:
unhandledElement(reader,element);
break;
case PERSIST_ID_CACHE:
unhandledElement(reader,element);
break;
case PERSISTENCE_ENABLED:
unhandledElement(reader,element);
break;
case REFRESH_TIMEOUT:
unhandledElement(reader,element);
break;
case REMOTING_INTERCEPTORS:
unhandledElement(reader,element);
break;
case RUN_SYNC_SPEED_TEST:
unhandledElement(reader,element);
break;
case SECURITY_ENABLED:
unhandledElement(reader,element);
break;
case SECURITY_INVALIDATION_INTERVAL:
unhandledElement(reader,element);
break;
case SECURITY_SETTINGS:
processSecuritySettings(reader,updates);
break;
case SERVER_DUMP_INTERVAL:
unhandledElement(reader,element);
break;
case SHARED_STORE:
unhandledElement(reader,element);
break;
case TRANSACTION_TIMEOUT:
unhandledElement(reader,element);
break;
case TRANSACTION_TIMEOUT_SCAN_PERIOD:
unhandledElement(reader,element);
break;
case WILD_CARD_ROUTING_ENABLED:
unhandledElement(reader,element);
break;
case DEAD_LETTER_ADDRESS_NODE_NAME:
unhandledElement(reader,element);
break;
case EXPIRY_ADDRESS_NODE_NAME:
unhandledElement(reader,element);
break;
case REDELIVERY_DELAY_NODE_NAME:
unhandledElement(reader,element);
break;
case MAX_DELIVERY_ATTEMPTS:
unhandledElement(reader,element);
break;
case MAX_SIZE_BYTES_NODE_NAME:
unhandledElement(reader,element);
break;
case ADDRESS_FULL_MESSAGE_POLICY_NODE_NAME:
unhandledElement(reader,element);
break;
case PAGE_SIZE_BYTES_NODE_NAME:
unhandledElement(reader,element);
break;
case MESSAGE_COUNTER_HISTORY_DAY_LIMIT_NODE_NAME:
unhandledElement(reader,element);
break;
case LVQ_NODE_NAME:
unhandledElement(reader,element);
break;
case REDISTRIBUTION_DELAY_NODE_NAME:
unhandledElement(reader,element);
break;
case SEND_TO_DLA_ON_NO_ROUTE:
unhandledElement(reader,element);
break;
case SUBSYSTEM:
break;
default :
throw ParseUtils.unexpectedElement(reader);
}
}
 while (reader.hasNext() && localName.equals("subsystem") == false);
log.tracef("End %s:%s",reader.getLocation(),reader.getLocalName());
}
