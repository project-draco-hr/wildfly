{
  final Map<String,ProxyTask> tasks=new HashMap<String,ProxyTask>();
  final Map<String,Future<ModelNode>> futures=new HashMap<String,Future<ModelNode>>();
  for (  Map.Entry<String,NewProxyController> entry : hostProxies.entrySet()) {
    String host=entry.getKey();
    ProxyTask task=new ProxyTask(host,operation,context,entry.getValue());
    tasks.put(host,task);
    futures.put(host,executorService.submit(task));
  }
  boolean interrupted=false;
  try {
    for (    Map.Entry<String,ProxyTask> entry : tasks.entrySet()) {
      ProxyTask task=entry.getValue();
      ModelNode result=null;
      try {
        result=entry.getValue().getUncommittedResult();
      }
 catch (      InterruptedException e) {
        result=new ModelNode();
        result.get(OUTCOME).set(FAILED);
        result.get(FAILURE_DESCRIPTION).set(String.format("Interrupted waiting for result from host %s",entry.getKey()));
        interrupted=true;
        task.cancel();
        futures.get(entry.getKey()).cancel(true);
      }
      System.out.println("Result for " + entry.getKey() + " is "+ result);
      domainOperationContext.addHostControllerResult(entry.getKey(),result);
    }
    domainOperationContext.setCompleteRollback(domainOperationContext.hasHostLevelFailures());
    context.completeStep();
  }
  finally {
    try {
      boolean rollback=domainOperationContext.isCompleteRollback();
      for (      ProxyTask task : tasks.values()) {
        task.finalizeTransaction(!rollback);
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
