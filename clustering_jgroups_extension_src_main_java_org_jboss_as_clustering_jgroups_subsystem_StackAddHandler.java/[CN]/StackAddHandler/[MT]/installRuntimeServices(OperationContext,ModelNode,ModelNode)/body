{
  String name=Operations.getPathAddress(operation).getLastElement().getValue();
  if (!model.hasDefined(TransportResourceDefinition.WILDCARD_PATH.getKey())) {
    throw JGroupsLogger.ROOT_LOGGER.transportNotDefined(name);
  }
  Property property=model.get(TransportResourceDefinition.WILDCARD_PATH.getKey()).asProperty();
  String type=property.getName();
  ModelNode transport=property.getValue();
  ModuleIdentifier module=ModelNodes.asModuleIdentifier(ProtocolResourceDefinition.MODULE.resolveModelAttribute(context,transport));
  boolean shared=TransportResourceDefinition.SHARED.resolveModelAttribute(context,transport).asBoolean();
  Transport transportConfig=new Transport(type,module,shared);
  String machine=ModelNodes.asString(TransportResourceDefinition.MACHINE.resolveModelAttribute(context,transport));
  String rack=ModelNodes.asString(TransportResourceDefinition.RACK.resolveModelAttribute(context,transport));
  String site=ModelNodes.asString(TransportResourceDefinition.SITE.resolveModelAttribute(context,transport));
  transportConfig.setTopology(site,rack,machine);
  initProtocolProperties(context,transport,transportConfig);
  Relay relayConfig=null;
  List<Map.Entry<String,Injector<Channel>>> channels=new LinkedList<>();
  if (model.hasDefined(RelayResourceDefinition.PATH.getKey())) {
    ModelNode relay=model.get(RelayResourceDefinition.PATH.getKeyValuePair());
    String siteName=RelayResourceDefinition.SITE.resolveModelAttribute(context,relay).asString();
    relayConfig=new Relay(siteName);
    initProtocolProperties(context,relay,relayConfig);
    if (relay.hasDefined(RemoteSiteResourceDefinition.WILDCARD_PATH.getKey())) {
      List<RemoteSiteConfiguration> remoteSites=relayConfig.getRemoteSites();
      for (      Property remoteSiteProperty : relay.get(RemoteSiteResourceDefinition.WILDCARD_PATH.getKey()).asPropertyList()) {
        String remoteSiteName=remoteSiteProperty.getName();
        String channelName=RemoteSiteResourceDefinition.CHANNEL.resolveModelAttribute(context,remoteSiteProperty.getValue()).asString();
        RemoteSite remoteSite=new RemoteSite(remoteSiteName,channelName);
        remoteSites.add(remoteSite);
        channels.add(new AbstractMap.SimpleImmutableEntry<>(channelName,remoteSite.getChannelInjector()));
      }
    }
  }
  String timerExecutor=ModelNodes.asString(TransportResourceDefinition.TIMER_EXECUTOR.resolveModelAttribute(context,transport));
  String threadFactory=ModelNodes.asString(TransportResourceDefinition.THREAD_FACTORY.resolveModelAttribute(context,transport));
  String diagnosticsSocketBinding=ModelNodes.asString(TransportResourceDefinition.DIAGNOSTICS_SOCKET_BINDING.resolveModelAttribute(context,transport));
  String defaultExecutor=ModelNodes.asString(TransportResourceDefinition.DEFAULT_EXECUTOR.resolveModelAttribute(context,transport));
  String oobExecutor=ModelNodes.asString(TransportResourceDefinition.OOB_EXECUTOR.resolveModelAttribute(context,transport));
  String transportSocketBinding=ModelNodes.asString(ProtocolResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,transport));
  List<ProtocolConfiguration> protocolConfigs=new LinkedList<>();
  ServiceTarget target=context.getServiceTarget();
  ServiceBuilder<ChannelFactory> builder=new JChannelFactoryBuilder(name,transportConfig,protocolConfigs,relayConfig).build(target);
  addSocketBindingDependency(builder,transportSocketBinding,transportConfig.getSocketBindingInjector());
  if (model.hasDefined(ProtocolResourceDefinition.WILDCARD_PATH.getKey())) {
    List<Property> protocols=model.get(ProtocolResourceDefinition.WILDCARD_PATH.getKey()).asPropertyList();
    List<Map.Entry<Protocol,String>> protocolSocketBindings=new ArrayList<>(protocols.size());
    for (    Property protocolProperty : protocols) {
      ModelNode protocol=protocolProperty.getValue();
      module=ModelNodes.asModuleIdentifier(ProtocolResourceDefinition.MODULE.resolveModelAttribute(context,protocol));
      Protocol protocolConfig=new Protocol(protocolProperty.getName(),module);
      initProtocolProperties(context,protocol,protocolConfig);
      protocolConfigs.add(protocolConfig);
      String protocolSocketBinding=ModelNodes.asString(ProtocolResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context,protocol));
      protocolSocketBindings.add(new AbstractMap.SimpleImmutableEntry<>(protocolConfig,protocolSocketBinding));
    }
    for (    Map.Entry<Protocol,String> entry : protocolSocketBindings) {
      addSocketBindingDependency(builder,entry.getValue(),entry.getKey().getSocketBindingInjector());
    }
  }
  addSocketBindingDependency(builder,diagnosticsSocketBinding,transportConfig.getDiagnosticsSocketBindingInjector());
  addExecutorDependency(builder,defaultExecutor,transportConfig.getDefaultExecutorInjector());
  addExecutorDependency(builder,oobExecutor,transportConfig.getOOBExecutorInjector());
  if (timerExecutor != null) {
    builder.addDependency(ThreadsServices.executorName(timerExecutor),ScheduledExecutorService.class,transportConfig.getTimerExecutorInjector());
  }
  if (threadFactory != null) {
    builder.addDependency(ThreadsServices.threadFactoryName(threadFactory),ThreadFactory.class,transportConfig.getThreadFactoryInjector());
  }
  for (  Map.Entry<String,Injector<Channel>> entry : channels) {
    builder.addDependency(ChannelServiceName.CHANNEL.getServiceName(entry.getKey()),Channel.class,entry.getValue());
  }
  builder.install();
  new BinderServiceBuilder<>(JGroupsBindingFactory.createChannelFactoryBinding(name),ProtocolStackServiceName.CHANNEL_FACTORY.getServiceName(name),ChannelFactory.class).build(target).install();
}
