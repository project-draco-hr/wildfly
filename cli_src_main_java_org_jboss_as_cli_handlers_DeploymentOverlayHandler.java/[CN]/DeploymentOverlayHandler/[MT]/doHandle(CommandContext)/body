{
  final ParsedCommandLine args=ctx.getParsedCommandLine();
  if (!args.hasProperties() || l.isPresent(args) && args.getOtherProperties().isEmpty() && args.getPropertyNames().size() == 1) {
    final ModelNode op=new ModelNode();
    op.get(Util.ADDRESS).setEmptyList();
    op.get(Util.OPERATION).set(Util.READ_CHILDREN_NAMES);
    op.get(Util.CHILD_TYPE).set(Util.DEPLOYMENT_OVERLAY);
    final ModelNode response;
    try {
      response=ctx.getModelControllerClient().execute(op);
    }
 catch (    IOException e) {
      throw new CommandLineException("Failed to execute " + Util.READ_CHILDREN_NAMES,e);
    }
    final ModelNode result=response.get(Util.RESULT);
    if (!result.isDefined()) {
      final String descr=Util.getFailureDescription(response);
      if (descr != null) {
        throw new CommandLineException(descr);
      }
      throw new CommandLineException("The response of " + Util.READ_CHILDREN_NAMES + " is missing result: "+ response);
    }
    if (l.isPresent(args)) {
      for (      ModelNode node : result.asList()) {
        ctx.printLine(node.asString());
      }
    }
 else {
      final List<String> names=new ArrayList<String>();
      for (      ModelNode node : result.asList()) {
        names.add(node.asString());
      }
      ctx.printColumns(names);
    }
    return;
  }
  final String action=this.action.getValue(args,true);
  if (ADD.equals(action)) {
    add(ctx,true);
  }
 else   if (UPLOAD.equals(action)) {
    upload(ctx,true);
  }
 else   if (LIST_CONTENT.equals(action)) {
    listContent(ctx);
  }
 else   if (LIST_LINKS.equals(action)) {
    listLinks(ctx);
  }
 else {
    super.doHandle(ctx);
  }
}
