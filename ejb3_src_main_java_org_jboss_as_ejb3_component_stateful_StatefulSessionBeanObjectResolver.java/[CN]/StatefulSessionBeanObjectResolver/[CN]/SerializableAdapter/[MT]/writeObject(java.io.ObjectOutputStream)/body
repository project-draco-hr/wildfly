{
  Class<?> targetClass=this.object.getClass();
  if (new HasAccessibleNoArgConstructorAction(targetClass).check()) {
    throw new InvalidClassException(targetClass.getName());
  }
  output.writeObject(targetClass);
  while (targetClass != null) {
    SerializableClass clazz=registry.lookup(targetClass);
    for (    SerializableField field : clazz.getFields()) {
      Field accessibleField=field.getField();
      try {
switch (field.getKind()) {
case BOOLEAN:
{
            output.writeBoolean(accessibleField.getBoolean(this.object));
            break;
          }
case BYTE:
{
          output.writeByte(accessibleField.getByte(this.object));
          break;
        }
case CHAR:
{
        output.writeChar(accessibleField.getChar(this.object));
        break;
      }
case DOUBLE:
{
      output.writeDouble(accessibleField.getDouble(this.object));
      break;
    }
case FLOAT:
{
    output.writeFloat(accessibleField.getFloat(this.object));
    break;
  }
case INT:
{
  output.writeInt(accessibleField.getInt(this.object));
  break;
}
case LONG:
{
output.writeLong(accessibleField.getLong(this.object));
break;
}
case SHORT:
{
output.writeShort(accessibleField.getShort(this.object));
break;
}
case OBJECT:
{
output.writeObject(accessibleField.get(this.object));
break;
}
}
}
 catch (IllegalAccessException e) {
throw new IllegalStateException(e);
}
}
targetClass=targetClass.getSuperclass();
}
}
