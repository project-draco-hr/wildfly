{
  final Object key=transactionSynchronizationRegistry.getTransactionKey();
  Map<Object,CacheEntry> map=cache.get(key);
  if (map != null) {
    return map;
  }
  map=Collections.synchronizedMap(new HashMap<Object,CacheEntry>());
  final Map<Object,CacheEntry> existing=cache.putIfAbsent(key,map);
  if (existing != null) {
    map=existing;
  }
  transactionSynchronizationRegistry.registerInterposedSynchronization(new Synchronization(){
    @Override public void beforeCompletion(){
    }
    @Override public void afterCompletion(    final int status){
      cache.remove(key);
    }
  }
);
  return map;
}
